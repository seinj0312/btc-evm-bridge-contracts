{
  "address": "0x9fa5Fd5E52D0793e4bc9A170eEF232eD15DaA6Ad",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_genesisHeader",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "_height",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "_periodStart",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "_TeleportDAOToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_exchangeRouter",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "firstHeight",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lastHeight",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "relayer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rewardAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isTDT",
          "type": "bool"
        }
      ],
      "name": "BlockAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "_from",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "_to",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "_gcd",
          "type": "bytes32"
        }
      ],
      "name": "NewTip",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "HEIGHT_INTERVAL",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "TeleportDAOToken",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "WAVAX",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_anchor",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_headers",
          "type": "bytes"
        }
      ],
      "name": "addHeaders",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_oldPeriodStartHeader",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_oldPeriodEndHeader",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_headers",
          "type": "bytes"
        }
      ],
      "name": "addHeadersWithRetarget",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "baseQueries",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "buyBackPeriod",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "_version",
          "type": "bytes4"
        },
        {
          "internalType": "bytes",
          "name": "_vin",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_vout",
          "type": "bytes"
        },
        {
          "internalType": "bytes4",
          "name": "_locktime",
          "type": "bytes4"
        }
      ],
      "name": "calculateTxId",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "chain",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "selfHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "parentHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "merkleRoot",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        }
      ],
      "name": "changeOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "txid",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "blockHeight",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "intermediateNodes",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "payWithTDT",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "neededConfirmations",
          "type": "uint256"
        }
      ],
      "name": "checkTxProof",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "epochLength",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "exchangeRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "feeRatio",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "finalizationParameter",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_digest",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "_offset",
          "type": "uint256"
        }
      ],
      "name": "findAncestor",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_digest",
          "type": "bytes32"
        }
      ],
      "name": "findHeight",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getBestKnownDigest",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "height",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "getBlockHeaderHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCurrentEpochDifficulty",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getLastReorgCommonAncestor",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "height",
          "type": "uint256"
        }
      ],
      "name": "getNumberOfSubmittedHeaders",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPrevEpochDifficulty",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getRelayGenesis",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "initialHeight",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_ancestor",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "_descendant",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "_limit",
          "type": "uint256"
        }
      ],
      "name": "isAncestor",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastBuyBack",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastEpochQueries",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastSubmittedHeight",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_ancestor",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_currentBest",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_newBest",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "_limit",
          "type": "uint256"
        }
      ],
      "name": "markNewHeaviest",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_baseQueries",
          "type": "uint256"
        }
      ],
      "name": "setBaseQueries",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_buyBackPeriod",
          "type": "uint256"
        }
      ],
      "name": "setBuyBackPeriod",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_epochLength",
          "type": "uint256"
        }
      ],
      "name": "setEpochLength",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_exchangeRouter",
          "type": "address"
        }
      ],
      "name": "setExchangeRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_feeRatio",
          "type": "uint256"
        }
      ],
      "name": "setFeeRatio",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_finalizationParameter",
          "type": "uint256"
        }
      ],
      "name": "setFinalizationParameter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_submissionGasUsed",
          "type": "uint256"
        }
      ],
      "name": "setSubmissionGasUsed",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "submissionGasUsed",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xff34d8e6d1a38656d3370a5b7f326205299fb63aa75c2fff38a470fd92f7d00c",
  "receipt": {
    "to": null,
    "from": "0x5364E3557572bd5D5903C0e9C21BE359F2Eac1dA",
    "contractAddress": "0x9fa5Fd5E52D0793e4bc9A170eEF232eD15DaA6Ad",
    "transactionIndex": 0,
    "gasUsed": "3675020",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xf204a836a89bec26241e03f1a48e3e135871ce199f17bb86747819512c3c0141",
    "transactionHash": "0xff34d8e6d1a38656d3370a5b7f326205299fb63aa75c2fff38a470fd92f7d00c",
    "logs": [],
    "blockNumber": 12331320,
    "cumulativeGasUsed": "3675020",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x0000c0209deeaf5a2bb5647b988d94393623c6ffc0cb1d73bf21865145000000000000006cee4d7d00545b073c966d045982cd4f7c82520086ae5e5d027c333db8cb9b10c57b9c62ffff001d24e24fc3",
    2254154,
    "0x0000000000000024409e9c7000b9508a93e8e03d3a5fef7a90988dde30ca71ec",
    "0xa608f5B846b3e4B71C589DFAd3862f5E1C074FaA",
    "0x668D83b86A4A599c144B1124455C9bb6b7653fDF"
  ],
  "numDeployments": 1,
  "solcInputHash": "b766d894e7507eaf09e41e8de1c94935",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_genesisHeader\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_height\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_periodStart\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_TeleportDAOToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchangeRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"firstHeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastHeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isTDT\",\"type\":\"bool\"}],\"name\":\"BlockAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_from\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_to\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_gcd\",\"type\":\"bytes32\"}],\"name\":\"NewTip\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"HEIGHT_INTERVAL\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TeleportDAOToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAVAX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_anchor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_headers\",\"type\":\"bytes\"}],\"name\":\"addHeaders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_oldPeriodStartHeader\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_oldPeriodEndHeader\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_headers\",\"type\":\"bytes\"}],\"name\":\"addHeadersWithRetarget\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseQueries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_version\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"_vin\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_vout\",\"type\":\"bytes\"},{\"internalType\":\"bytes4\",\"name\":\"_locktime\",\"type\":\"bytes4\"}],\"name\":\"calculateTxId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chain\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"selfHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"parentHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"txid\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"blockHeight\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"intermediateNodes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"payWithTDT\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"neededConfirmations\",\"type\":\"uint256\"}],\"name\":\"checkTxProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizationParameter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_digest\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"}],\"name\":\"findAncestor\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_digest\",\"type\":\"bytes32\"}],\"name\":\"findHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBestKnownDigest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getBlockHeaderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpochDifficulty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastReorgCommonAncestor\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"}],\"name\":\"getNumberOfSubmittedHeaders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrevEpochDifficulty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRelayGenesis\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ancestor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_descendant\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"isAncestor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBuyBack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastEpochQueries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastSubmittedHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ancestor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_currentBest\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_newBest\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"markNewHeaviest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_baseQueries\",\"type\":\"uint256\"}],\"name\":\"setBaseQueries\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyBackPeriod\",\"type\":\"uint256\"}],\"name\":\"setBuyBackPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epochLength\",\"type\":\"uint256\"}],\"name\":\"setEpochLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exchangeRouter\",\"type\":\"address\"}],\"name\":\"setExchangeRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeRatio\",\"type\":\"uint256\"}],\"name\":\"setFeeRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_finalizationParameter\",\"type\":\"uint256\"}],\"name\":\"setFinalizationParameter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_submissionGasUsed\",\"type\":\"uint256\"}],\"name\":\"setSubmissionGasUsed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"submissionGasUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addHeaders(bytes,bytes)\":{\"details\":\"We check integrity and consistency of the header chain\",\"params\":{\"_anchor\":\"The header immediately preceeding the new chain\",\"_headers\":\"A tightly-packed list of 80-byte Bitcoin headers\"},\"returns\":{\"_0\":\"True if successfully written, error otherwise\"}},\"addHeadersWithRetarget(bytes,bytes,bytes)\":{\"details\":\"Checks the retarget, the heights, and the linkage\",\"params\":{\"_headers\":\"A tightly-packed list of 80-byte Bitcoin headers\",\"_oldPeriodEndHeader\":\"The last header in the difficulty period being closed\",\"_oldPeriodStartHeader\":\"The first header in the difficulty period being closed\"},\"returns\":{\"_0\":\"True if successfully written, error otherwise\"}},\"constructor\":{\"details\":\"We don't check this AT ALL really. Don't use relays with bad genesis\",\"params\":{\"_genesisHeader\":\"The starting header\",\"_height\":\"The starting height\",\"_periodStart\":\"The hash of the first header in the genesis epoch\"}},\"findAncestor(bytes32,uint256)\":{\"details\":\"Will fail if the header is unknown\",\"params\":{\"_digest\":\"The header digest to search for\"},\"returns\":{\"_0\":\"The height of the header, or error if unknown\"}},\"findHeight(bytes32)\":{\"details\":\"Will fail if the header is unknown\",\"params\":{\"_digest\":\"The header digest to search for\"},\"returns\":{\"_0\":\"The height of the header, or error if unknown\"}},\"getBestKnownDigest()\":{\"details\":\"This updated only by calling markNewHeaviest\",\"returns\":{\"_0\":\"The hash of the best marked chain tip\"}},\"getCurrentEpochDifficulty()\":{\"details\":\"This is updated when a new heavist header has a new diff\",\"returns\":{\"_0\":\"The difficulty of the bestKnownDigest\"}},\"getLastReorgCommonAncestor()\":{\"details\":\"This is updated only by calling markNewHeaviest\",\"returns\":{\"_0\":\"The hash of the shared ancestor of the most recent fork\"}},\"getPrevEpochDifficulty()\":{\"details\":\"This is updated when a difficulty change is accepted\",\"returns\":{\"_0\":\"The difficulty of the previous epoch\"}},\"getRelayGenesis()\":{\"details\":\"This is an initialization parameter\",\"returns\":{\"_0\":\"The hash of the first block of the relay\"}},\"isAncestor(bytes32,bytes32,uint256)\":{\"details\":\"Limit the amount of lookups (and thus gas usage) with _limit\",\"params\":{\"_ancestor\":\"The prospective ancestor\",\"_descendant\":\"The descendant to check\",\"_limit\":\"The maximum number of blocks to check\"},\"returns\":{\"_0\":\"true if ancestor is at most limit blocks lower than descendant, otherwise false\"}},\"markNewHeaviest(bytes32,bytes,bytes,uint256)\":{\"details\":\"We don't check this AT ALL really. Don't use relays with bad genesis\",\"params\":{\"_ancestor\":\"The digest of the most recent common ancestor\",\"_currentBest\":\"The 80-byte header referenced by bestKnownDigest\",\"_limit\":\"Limit the amount of traversal of the chain\",\"_newBest\":\"The 80-byte header to mark as the new best\"},\"returns\":{\"_0\":\"True if successfully updates bestKnownDigest, error otherwise\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addHeaders(bytes,bytes)\":{\"notice\":\"Adds headers to storage after validating\"},\"addHeadersWithRetarget(bytes,bytes,bytes)\":{\"notice\":\"Adds headers to storage, performs additional validation of retarget\"},\"constructor\":{\"notice\":\"Gives a starting point for the relay\"},\"findAncestor(bytes32,uint256)\":{\"notice\":\"Finds an ancestor for a block by its digest\"},\"findHeight(bytes32)\":{\"notice\":\"Finds the height of a header by its digest\"},\"getBestKnownDigest()\":{\"notice\":\"Getter for bestKnownDigest\"},\"getCurrentEpochDifficulty()\":{\"notice\":\"Getter for currentEpochDiff\"},\"getLastReorgCommonAncestor()\":{\"notice\":\"Getter for relayGenesis\"},\"getPrevEpochDifficulty()\":{\"notice\":\"Getter for prevEpochDiff\"},\"getRelayGenesis()\":{\"notice\":\"Getter for relayGenesis\"},\"isAncestor(bytes32,bytes32,uint256)\":{\"notice\":\"Checks if a digest is an ancestor of the current one\"},\"markNewHeaviest(bytes32,bytes,bytes,uint256)\":{\"notice\":\"Gives a starting point for the relay\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/relay/BitcoinRelay.sol\":\"BitcoinRelay\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/erc20/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\ninterface IERC20 {\\n    // events\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    // read-only functions\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    // state-changing functions\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xbfce47b32957e65d24a0a087221880a77cde7bd13f0bb3af913cb9b0877ddad5\"},\"contracts/libraries/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n    \\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b; //TODO: edit it\\n    }\\n}\\n\",\"keccak256\":\"0x8d7c458d27f34a0512d902ee3b662022a586ce1c27a79a0c260c676fd55c454d\"},\"contracts/libraries/TypedMemView.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.7.6;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary TypedMemView {\\n    using SafeMath for uint256;\\n\\n    // Why does this exist?\\n    // the solidity `bytes memory` type has a few weaknesses.\\n    // 1. You can't index ranges effectively\\n    // 2. You can't slice without copying\\n    // 3. The underlying data may represent any type\\n    // 4. Solidity never deallocates memory, and memory costs grow\\n    //    superlinearly\\n\\n    // By using a memory view instead of a `bytes memory` we get the following\\n    // advantages:\\n    // 1. Slices are done on the stack, by manipulating the pointer\\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\\n    // 3. We can insert type info into the pointer, and typecheck at runtime\\n\\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\\n    // algorithms.\\n\\n    // Why bytes29?\\n    // We want to avoid confusion between views, digests, and other common\\n    // types so we chose a large and uncommonly used odd number of bytes\\n    //\\n    // Note that while bytes are left-aligned in a word, integers and addresses\\n    // are right-aligned. This means when working in assembly we have to\\n    // account for the 3 unused bytes on the righthand side\\n    //\\n    // First 5 bytes are a type flag.\\n    // - ff_ffff_fffe is reserved for unknown type.\\n    // - ff_ffff_ffff is reserved for invalid types/errors.\\n    // next 12 are memory address\\n    // next 12 are len\\n    // bottom 3 bytes are empty\\n\\n    // Assumptions:\\n    // - non-modification of memory.\\n    // - No Solidity updates\\n    // - - wrt free mem point\\n    // - - wrt bytes representation in memory\\n    // - - wrt memory addressing in general\\n\\n    // Usage:\\n    // - create type constants\\n    // - use `assertType` for runtime type assertions\\n    // - - unfortunately we can't do this at compile time yet :(\\n    // - recommended: implement modifiers that perform type checking\\n    // - - e.g.\\n    // - - `uint40 constant MY_TYPE = 3;`\\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\\n    // - instantiate a typed view from a bytearray using `ref`\\n    // - use `index` to inspect the contents of the view\\n    // - use `slice` to create smaller views into the same memory\\n    // - - `slice` can increase the offset\\n    // - - `slice can decrease the length`\\n    // - - must specify the output type of `slice`\\n    // - - `slice` will return a null view if you try to overrun\\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\\n    // - use `equal` for typed comparisons.\\n\\n\\n    // The null view\\n    bytes29 public constant NULL = hex\\\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\\";\\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\\n    uint8 constant TWELVE_BYTES = 96;\\n\\n    /**\\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\\n     * @param _b    The byte\\n     * @return      char - The encoded hex character\\n     */\\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\\n        // This can probably be done more efficiently, but it's only in error\\n        // paths, so we don't really care :)\\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\\n        if (_nibble == 0xf0) {return 0x30;} // 0\\n        if (_nibble == 0xf1) {return 0x31;} // 1\\n        if (_nibble == 0xf2) {return 0x32;} // 2\\n        if (_nibble == 0xf3) {return 0x33;} // 3\\n        if (_nibble == 0xf4) {return 0x34;} // 4\\n        if (_nibble == 0xf5) {return 0x35;} // 5\\n        if (_nibble == 0xf6) {return 0x36;} // 6\\n        if (_nibble == 0xf7) {return 0x37;} // 7\\n        if (_nibble == 0xf8) {return 0x38;} // 8\\n        if (_nibble == 0xf9) {return 0x39;} // 9\\n        if (_nibble == 0xfa) {return 0x61;} // a\\n        if (_nibble == 0xfb) {return 0x62;} // b\\n        if (_nibble == 0xfc) {return 0x63;} // c\\n        if (_nibble == 0xfd) {return 0x64;} // d\\n        if (_nibble == 0xfe) {return 0x65;} // e\\n        if (_nibble == 0xff) {return 0x66;} // f\\n    }\\n\\n    /**\\n     * @notice      Returns a uint16 containing the hex-encoded byte.\\n     * @param _b    The byte\\n     * @return      encoded - The hex-encoded byte\\n     */\\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\\n        encoded |= nibbleHex(_b >> 4); // top 4 bits\\n        encoded <<= 8;\\n        encoded |= nibbleHex(_b); // lower 4 bits\\n    }\\n\\n    /**\\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\\n     *              `second` contains the encoded lower 16 bytes.\\n     *\\n     * @param _b    The 32 bytes as uint256\\n     * @return      first - The top 16 bytes\\n     * @return      second - The bottom 16 bytes\\n     */\\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\\n        for (uint8 i = 31; i > 15; i -= 1) {\\n            uint8 _byte = uint8(_b >> (i * 8));\\n            first |= byteHex(_byte);\\n            if (i != 16) {\\n                first <<= 16;\\n            }\\n        }\\n\\n        // abusing underflow here =_=\\n        for (uint8 i = 15; i < 255 ; i -= 1) {\\n            uint8 _byte = uint8(_b >> (i * 8));\\n            second |= byteHex(_byte);\\n            if (i != 0) {\\n                second <<= 16;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice          Changes the endianness of a uint256.\\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\\n     * @param _b        The unsigned integer to reverse\\n     * @return          v - The reversed value\\n     */\\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\\n        v = _b;\\n\\n        // swap bytes\\n        v = ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n        // swap 2-byte long pairs\\n        v = ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n        // swap 4-byte long pairs\\n        v = ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n        // swap 8-byte long pairs\\n        v = ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n        // swap 16-byte long pairs\\n        v = (v >> 128) | (v << 128);\\n    }\\n\\n    /**\\n     * @notice      Create a mask with the highest `_len` bits set.\\n     * @param _len  The length\\n     * @return      mask - The mask\\n     */\\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\\n        // ugly. redo without assembly?\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            mask := sar(\\n                sub(_len, 1),\\n                0x8000000000000000000000000000000000000000000000000000000000000000\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @notice      Return the null view.\\n     * @return      bytes29 - The null view\\n     */\\n    function nullView() internal pure returns (bytes29) {\\n        return NULL;\\n    }\\n\\n    /**\\n     * @notice      Check if the view is null.\\n     * @return      bool - True if the view is null\\n     */\\n    function isNull(bytes29 memView) internal pure returns (bool) {\\n        return memView == NULL;\\n    }\\n\\n    /**\\n     * @notice      Check if the view is not null.\\n     * @return      bool - True if the view is not null\\n     */\\n    function notNull(bytes29 memView) internal pure returns (bool) {\\n        return !isNull(memView);\\n    }\\n\\n    /**\\n     * @notice          Check if the view is of a valid type and points to a valid location\\n     *                  in memory.\\n     * @dev             We perform this check by examining solidity's unallocated memory\\n     *                  pointer and ensuring that the view's upper bound is less than that.\\n     * @param memView   The view\\n     * @return          ret - True if the view is valid\\n     */\\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\\n        if (typeOf(memView) == 0xffffffffff) {return false;}\\n        uint256 _end = end(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ret := not(gt(_end, mload(0x40)))\\n        }\\n    }\\n\\n    /**\\n     * @notice          Require that a typed memory view be valid.\\n     * @dev             Returns the view for easy chaining.\\n     * @param memView   The view\\n     * @return          bytes29 - The validated view\\n     */\\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\\n        require(isValid(memView), \\\"Validity assertion failed\\\");\\n        return memView;\\n    }\\n\\n    /**\\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\\n     * @param memView   The view\\n     * @param _expected The expected type\\n     * @return          bool - True if the memview is of the expected type\\n     */\\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\\n        return typeOf(memView) == _expected;\\n    }\\n\\n    /**\\n     * @notice          Require that a typed memory view has a specific type.\\n     * @dev             Returns the view for easy chaining.\\n     * @param memView   The view\\n     * @param _expected The expected type\\n     * @return          bytes29 - The view with validated type\\n     */\\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\\n        if (!isType(memView, _expected)) {\\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\\n            (, uint256 e) = encodeHex(uint256(_expected));\\n            string memory err = string(\\n                abi.encodePacked(\\n                    \\\"Type assertion failed. Got 0x\\\",\\n                    uint80(g),\\n                    \\\". Expected 0x\\\",\\n                    uint80(e)\\n                )\\n            );\\n            revert(err);\\n        }\\n        return memView;\\n    }\\n\\n    /**\\n     * @notice          Return an identical view with a different type.\\n     * @param memView   The view\\n     * @param _newType  The new type\\n     * @return          newView - The new view with the specified type\\n     */\\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\\n        // then | in the new type\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // shift off the top 5 bytes\\n            newView := or(newView, shr(40, shl(40, memView)))\\n            newView := or(newView, shl(216, _newType))\\n        }\\n    }\\n\\n    /**\\n     * @notice          Unsafe raw pointer construction. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @dev             Unsafe raw pointer construction. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @param _type     The type\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @return          newView - The new view with the specified type, location and length\\n     */\\n    function unsafeBuildUnchecked(uint256 _type, uint256 _loc, uint256 _len) private pure returns (bytes29 newView) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            newView := shl(96, or(newView, _type)) // insert type\\n            newView := shl(96, or(newView, _loc))  // insert loc\\n            newView := shl(24, or(newView, _len))  // empty bottom 3 bytes\\n        }\\n    }\\n\\n    /**\\n     * @notice          Instantiate a new memory view. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @dev             Instantiate a new memory view. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @param _type     The type\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @return          newView - The new view with the specified type, location and length\\n     */\\n    function build(uint256 _type, uint256 _loc, uint256 _len) internal pure returns (bytes29 newView) {\\n        uint256 _end = _loc.add(_len);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            if gt(_end, mload(0x40)) {\\n                _end := 0\\n            }\\n        }\\n        if (_end == 0) {\\n            return NULL;\\n        }\\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Instantiate a memory view from a byte array.\\n     * @dev             Note that due to Solidity memory representation, it is not possible to\\n     *                  implement a deref, as the `bytes` type stores its len in memory.\\n     * @param arr       The byte array\\n     * @param newType   The type\\n     * @return          bytes29 - The memory view\\n     */\\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\\n        uint256 _len = arr.length;\\n\\n        uint256 _loc;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            _loc := add(arr, 0x20)  // our view is of the data, not the struct\\n        }\\n\\n        return build(newType, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Return the associated type information.\\n     * @param memView   The memory view\\n     * @return          _type - The type associated with the view\\n     */\\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // 216 == 256 - 40\\n            _type := shr(216, memView) // shift out lower 24 bytes\\n        }\\n    }\\n\\n    /**\\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the 5-byte type flag is equal\\n     */\\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return (left ^ right) >> (2 * TWELVE_BYTES) == 0;\\n    }\\n\\n    /**\\n     * @notice          Return the memory address of the underlying bytes.\\n     * @param memView   The view\\n     * @return          _loc - The memory address\\n     */\\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\\n            _loc := and(shr(120, memView), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          The number of memory words this memory view occupies, rounded up.\\n     * @param memView   The view\\n     * @return          uint256 - The number of memory words\\n     */\\n    function words(bytes29 memView) internal pure returns (uint256) {\\n        return uint256(len(memView)).add(32) / 32;\\n    }\\n\\n    /**\\n     * @notice          The in-memory footprint of a fresh copy of the view.\\n     * @param memView   The view\\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\\n     */\\n    function footprint(bytes29 memView) internal pure returns (uint256) {\\n        return words(memView) * 32;\\n    }\\n\\n    /**\\n     * @notice          The number of bytes of the view.\\n     * @param memView   The view\\n     * @return          _len - The length of the view\\n     */\\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            _len := and(shr(24, memView), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Returns the endpoint of `memView`.\\n     * @param memView   The view\\n     * @return          uint256 - The endpoint of `memView`\\n     */\\n    function end(bytes29 memView) internal pure returns (uint256) {\\n        return loc(memView) + len(memView);\\n    }\\n\\n    /**\\n     * @notice          Safe slicing without memory modification.\\n     * @param memView   The view\\n     * @param _index    The start index\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function slice(bytes29 memView, uint256 _index, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        uint256 _loc = loc(memView);\\n\\n        // Ensure it doesn't overrun the view\\n        if (_loc.add(_index).add(_len) > end(memView)) {\\n            return NULL;\\n        }\\n\\n        _loc = _loc.add(_index);\\n        return build(newType, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\\n     * @param memView   The view\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function prefix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        return slice(memView, 0, _len, newType);\\n    }\\n\\n    /**\\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\\n     * @param memView   The view\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function postfix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        return slice(memView, uint256(len(memView)).sub(_len), _len, newType);\\n    }\\n\\n    /**\\n     * @notice          Construct an error message for an indexing overrun.\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @param _index    The index\\n     * @param _slice    The slice where the overrun occurred\\n     * @return          err - The err\\n     */\\n    function indexErrOverrun(\\n        uint256 _loc,\\n        uint256 _len,\\n        uint256 _index,\\n        uint256 _slice\\n    ) internal pure returns (string memory err) {\\n        (, uint256 a) = encodeHex(_loc);\\n        (, uint256 b) = encodeHex(_len);\\n        (, uint256 c) = encodeHex(_index);\\n        (, uint256 d) = encodeHex(_slice);\\n        err = string(\\n            abi.encodePacked(\\n                \\\"TypedMemView/index - Overran the view. Slice is at 0x\\\",\\n                uint48(a),\\n                \\\" with length 0x\\\",\\n                uint48(b),\\n                \\\". Attempted to index at offset 0x\\\",\\n                uint48(c),\\n                \\\" with length 0x\\\",\\n                uint48(d),\\n                \\\".\\\"\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice          Load up to 32 bytes from the view onto the stack.\\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\\n     *                  This can be immediately cast to a smaller fixed-length byte array.\\n     *                  To automatically cast to an integer, use `indexUint`.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The 32 byte result\\n     */\\n    function index(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (bytes32 result) {\\n        if (_bytes == 0) {return bytes32(0);}\\n        if (_index.add(_bytes) > len(memView)) {\\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\\n        }\\n        require(_bytes <= 32, \\\"TypedMemView/index - Attempted to index more than 32 bytes\\\");\\n\\n        uint8 bitLength = _bytes * 8;\\n        uint256 _loc = loc(memView);\\n        uint256 _mask = leftMask(bitLength);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            result := and(mload(add(_loc, _index)), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Parse an unsigned integer from the view at `_index`.\\n     * @dev             Requires that the view have >= `_bytes` bytes following that index.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The unsigned integer\\n     */\\n    function indexUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {\\n        return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\\n    }\\n\\n    /**\\n     * @notice          Parse an unsigned integer from LE bytes.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The unsigned integer\\n     */\\n    function indexLEUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {\\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\\n    }\\n\\n    /**\\n     * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\\n     *                  following that index.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @return          address - The address\\n     */\\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\\n        return address(uint160(indexUint(memView, _index, 20)));\\n    }\\n\\n    /**\\n     * @notice          Return the keccak256 hash of the underlying memory\\n     * @param memView   The view\\n     * @return          digest - The keccak256 hash of the underlying memory\\n     */\\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            digest := keccak256(_loc, _len)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Return the sha2 digest of the underlying memory.\\n     * @dev             We explicitly deallocate memory afterwards.\\n     * @param memView   The view\\n     * @return          digest - The sha2 hash of the underlying memory\\n     */\\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\\n     * @param memView   The pre-image\\n     * @return          digest - the Digest\\n     */\\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\\n        }\\n    }\\n\\n    /**\\n     * @notice          Implements bitcoin's hash256 (double sha2)\\n     * @param memView   A view of the preimage\\n     * @return          digest - the Digest\\n     */\\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Return true if the underlying memory is equal. Else false.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the underlying memory is equal\\n     */\\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\\n    }\\n\\n    /**\\n     * @notice          Return false if the underlying memory is equal. Else true.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - False if the underlying memory is equal\\n     */\\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return !untypedEqual(left, right);\\n    }\\n\\n    /**\\n     * @notice          Compares type equality.\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the types are the same\\n     */\\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\\n    }\\n\\n    /**\\n     * @notice          Compares type inequality.\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the types are not the same\\n     */\\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return !equal(left, right);\\n    }\\n\\n    /**\\n     * @notice          Copy the view to a location, return an unsafe memory reference\\n     * @dev             Super Dangerous direct memory access.\\n     *\\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\\n     *                  As such it MUST be consumed IMMEDIATELY.\\n     *                  This function is private to prevent unsafe usage by callers.\\n     * @param memView   The view\\n     * @param _newLoc   The new location\\n     * @return          written - the unsafe memory reference\\n     */\\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\\n        require(notNull(memView), \\\"TypedMemView/copyTo - Null pointer deref\\\");\\n        require(isValid(memView), \\\"TypedMemView/copyTo - Invalid pointer deref\\\");\\n        uint256 _len = len(memView);\\n        uint256 _oldLoc = loc(memView);\\n\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40)\\n            // revert if we're writing in occupied memory\\n            if gt(ptr, _newLoc) {\\n                revert(0x60, 0x20) // empty revert message\\n            }\\n\\n            // use the identity precompile to copy\\n            // guaranteed not to fail, so pop the success\\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\\n        }\\n\\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\\n    }\\n\\n    /**\\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\\n     *                  the new memory\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param memView   The view\\n     * @return          ret - The view pointing to the new memory\\n     */\\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\\n        uint256 ptr;\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n            ret := ptr\\n        }\\n        unsafeCopyTo(memView, ptr + 0x20);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\\n            mstore(ptr, _len) // write len of new array (in bytes)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\\n     * @dev             Super Dangerous direct memory access.\\n     *\\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\\n     *                  As such it MUST be consumed IMMEDIATELY.\\n     *                  This function is private to prevent unsafe usage by callers.\\n     * @param memViews  The views\\n     * @return          unsafeView - The conjoined view pointing to the new memory\\n     */\\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            // revert if we're writing in occupied memory\\n            if gt(ptr, _location) {\\n                revert(0x60, 0x20) // empty revert message\\n            }\\n        }\\n\\n        uint256 _offset = 0;\\n        for (uint256 i = 0; i < memViews.length; i ++) {\\n            bytes29 memView = memViews[i];\\n            unsafeCopyTo(memView, _location + _offset);\\n            _offset += len(memView);\\n        }\\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\\n    }\\n\\n    /**\\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\\n     * @param memViews  The views\\n     * @return          bytes32 - The keccak256 digest\\n     */\\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n        return keccak(unsafeJoin(memViews, ptr));\\n    }\\n\\n    /**\\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\\n     * @param memViews  The views\\n     * @return          bytes32 - The sha256 digest\\n     */\\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n        return sha2(unsafeJoin(memViews, ptr));\\n    }\\n\\n    /**\\n     * @notice          copies all views, joins them into a new bytearray.\\n     * @param memViews  The views\\n     * @return          ret - The new byte array\\n     */\\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n\\n        bytes29 _newView = unsafeJoin(memViews, ptr + 0x20);\\n        uint256 _written = len(_newView);\\n        uint256 _footprint = footprint(_newView);\\n\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // store the legnth\\n            mstore(ptr, _written)\\n            // new pointer is old + 0x20 + the footprint of the body\\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\\n            ret := ptr\\n        }\\n    }\\n}\",\"keccak256\":\"0x00cbfbbcbe4334fe3f66659074dc2785d689c249ebf259a60b65e2e52cde1a73\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/libraries/ViewBTC.sol\":{\"content\":\"pragma solidity 0.7.6;\\n\\n/** @title BitcoinSPV */\\n/** @author Summa (https://summa.one) */\\n\\nimport \\\"./TypedMemView.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary ViewBTC {\\n    using TypedMemView for bytes29;\\n    using SafeMath for uint256;\\n\\n    // The target at minimum Difficulty. Also the target of the genesis block\\n    uint256 public constant DIFF1_TARGET = 0xffff0000000000000000000000000000000000000000000000000000;\\n\\n    uint256 public constant RETARGET_PERIOD = 2 * 7 * 24 * 60 * 60;  // 2 weeks in seconds\\n    uint256 public constant RETARGET_PERIOD_BLOCKS = 2016;  // 2 weeks in blocks\\n\\n    enum BTCTypes {\\n        Unknown,            // 0x0\\n        CompactInt,         // 0x1\\n        ScriptSig,          // 0x2 - with length prefix\\n        Outpoint,           // 0x3\\n        TxIn,               // 0x4\\n        IntermediateTxIns,  // 0x5 - used in vin parsing\\n        Vin,                // 0x6\\n        ScriptPubkey,       // 0x7 - with length prefix\\n        PKH,                // 0x8 - the 20-byte payload digest\\n        WPKH,               // 0x9 - the 20-byte payload digest\\n        WSH,                // 0xa - the 32-byte payload digest\\n        SH,                 // 0xb - the 20-byte payload digest\\n        OpReturnPayload,    // 0xc\\n        TxOut,              // 0xd\\n        IntermediateTxOuts, // 0xe - used in vout parsing\\n        Vout,               // 0xf\\n        Header,             // 0x10\\n        HeaderArray,        // 0x11\\n        MerkleNode,         // 0x12\\n        MerkleStep,         // 0x13\\n        MerkleArray         // 0x14\\n    }\\n\\n    // TODO: any way to bubble up more info?\\n    // @notice             requires `memView` to be of a specified type\\n    // @param memView      a 29-byte view with a 5-byte type\\n    // @param t            the expected type (e.g. BTCTypes.Outpoint, BTCTypes.TxIn, etc)\\n    // @return             passes if it is the correct type, errors if not\\n    modifier typeAssert(bytes29 memView, BTCTypes t) {\\n        memView.assertType(uint40(t));\\n        _;\\n    }\\n\\n    // Revert with an error message re: non-minimal VarInts\\n    function revertNonMinimal(bytes29 ref) private pure returns (string memory) {\\n        (, uint256 g) = TypedMemView.encodeHex(ref.indexUint(0, uint8(ref.len())));\\n        string memory err = string(\\n            abi.encodePacked(\\n                \\\"Non-minimal var int. Got 0x\\\",\\n                uint144(g)\\n            )\\n        );\\n        revert(err);\\n    }\\n\\n    // @notice             reads a compact int from the view at the specified index\\n    // @param memView      a 29-byte view with a 5-byte type\\n    // @param _index       the index\\n    // @return             the compact int at the specified index\\n    function indexCompactInt(bytes29 memView, uint256 _index) internal pure returns (uint64 number) {\\n        uint256 flag = memView.indexUint(_index, 1);\\n        if (flag <= 0xfc) {\\n            return uint64(flag);\\n        } else if (flag == 0xfd) {\\n            number = uint64(memView.indexLEUint(_index + 1, 2));\\n            if (compactIntLength(number) != 3) {revertNonMinimal(memView.slice(_index, 3, 0));}\\n        } else if (flag == 0xfe) {\\n            number = uint64(memView.indexLEUint(_index + 1, 4));\\n            if (compactIntLength(number) != 5) {revertNonMinimal(memView.slice(_index, 5, 0));}\\n        } else if (flag == 0xff) {\\n            number = uint64(memView.indexLEUint(_index + 1, 8));\\n            if (compactIntLength(number) != 9) {revertNonMinimal(memView.slice(_index, 9, 0));}\\n        }\\n    }\\n\\n    // @notice         gives the total length (in bytes) of a CompactInt-encoded number\\n    // @param number   the number as uint64\\n    // @return         the compact integer as uint8\\n    function compactIntLength(uint64 number) internal pure returns (uint8) {\\n        if (number <= 0xfc) {\\n            return 1;\\n        } else if (number <= 0xffff) {\\n            return 3;\\n        } else if (number <= 0xffffffff) {\\n            return 5;\\n        } else {\\n            return 9;\\n        }\\n    }\\n\\n    // @notice             extracts the LE txid from an outpoint\\n    // @param _outpoint    the outpoint\\n    // @return             the LE txid\\n    function txidLE(bytes29 _outpoint) internal pure typeAssert(_outpoint, BTCTypes.Outpoint) returns (bytes32) {\\n        return _outpoint.index(0, 32);\\n    }\\n\\n    // @notice             extracts the index as an integer from the outpoint\\n    // @param _outpoint    the outpoint\\n    // @return             the index\\n    function outpointIdx(bytes29 _outpoint) internal pure typeAssert(_outpoint, BTCTypes.Outpoint) returns (uint32) {\\n        return uint32(_outpoint.indexLEUint(32, 4));\\n    }\\n\\n    // @notice          extracts the outpoint from an input\\n    // @param _input    the input\\n    // @return          the outpoint as a typed memory\\n    function outpoint(bytes29 _input) internal pure typeAssert(_input, BTCTypes.TxIn) returns (bytes29) {\\n        return _input.slice(0, 36, uint40(BTCTypes.Outpoint));\\n    }\\n\\n    // @notice           extracts the script sig from an input\\n    // @param _input     the input\\n    // @return           the script sig as a typed memory\\n    function scriptSig(bytes29 _input) internal pure typeAssert(_input, BTCTypes.TxIn) returns (bytes29) {\\n        uint64 scriptLength = indexCompactInt(_input, 36);\\n        return _input.slice(36, compactIntLength(scriptLength) + scriptLength, uint40(BTCTypes.ScriptSig));\\n    }\\n\\n    // @notice         extracts the sequence from an input\\n    // @param _input   the input\\n    // @return         the sequence\\n    function sequence(bytes29 _input) internal pure typeAssert(_input, BTCTypes.TxIn) returns (uint32) {\\n        uint64 scriptLength = indexCompactInt(_input, 36);\\n        uint256 scriptEnd = 36 + compactIntLength(scriptLength) + scriptLength;\\n        return uint32(_input.indexLEUint(scriptEnd, 4));\\n    }\\n\\n    // @notice         determines the length of the first input in an array of inputs\\n    // @param _inputs  the vin without its length prefix\\n    // @return         the input length\\n    function inputLength(bytes29 _inputs) internal pure typeAssert(_inputs, BTCTypes.IntermediateTxIns) returns (uint256) {\\n        uint64 scriptLength = indexCompactInt(_inputs, 36);\\n        return uint256(compactIntLength(scriptLength)) + uint256(scriptLength) + 36 + 4;\\n    }\\n\\n    // @notice         extracts the input at a specified index\\n    // @param _vin     the vin\\n    // @param _index   the index of the desired input\\n    // @return         the desired input\\n    function indexVin(bytes29 _vin, uint256 _index) internal pure typeAssert(_vin, BTCTypes.Vin) returns (bytes29) {\\n        uint256 _nIns = uint256(indexCompactInt(_vin, 0));\\n        uint256 _viewLen = _vin.len();\\n        require(_index < _nIns, \\\"Vin read overrun\\\");\\n\\n        uint256 _offset = uint256(compactIntLength(uint64(_nIns)));\\n        bytes29 _remaining;\\n        for (uint256 _i = 0; _i < _index; _i += 1) {\\n            _remaining = _vin.postfix(_viewLen.sub(_offset), uint40(BTCTypes.IntermediateTxIns));\\n            _offset += inputLength(_remaining);\\n        }\\n\\n        _remaining = _vin.postfix(_viewLen.sub(_offset), uint40(BTCTypes.IntermediateTxIns));\\n        uint256 _len = inputLength(_remaining);\\n        return _vin.slice(_offset, _len, uint40(BTCTypes.TxIn));\\n    }\\n\\n    // @notice         extracts the raw LE bytes of the output value\\n    // @param _output  the output\\n    // @return         the raw LE bytes of the output value\\n    function valueBytes(bytes29 _output) internal pure typeAssert(_output, BTCTypes.TxOut) returns (bytes8) {\\n        return bytes8(_output.index(0, 8));\\n    }\\n\\n    // @notice         extracts the value from an output\\n    // @param _output  the output\\n    // @return         the value\\n    // function value(bytes29 _output) internal pure typeAssert(_output, BTCTypes.TxOut) returns (uint64) {\\n    //     return uint64(_output.indexLEUint(0, 8));\\n    // }\\n    function value(bytes29 _output) internal pure returns (uint64) {\\n        return uint64(_output.indexLEUint(0, 8));\\n    }\\n\\n    // @notice             extracts the scriptPubkey from an output\\n    // @param _output      the output\\n    // @return             the scriptPubkey\\n    function scriptPubkey(bytes29 _output) internal typeAssert(_output, BTCTypes.TxOut) returns (bytes29) {\\n        uint64 scriptLength = indexCompactInt(_output, 8);\\n        return _output.slice(8, compactIntLength(scriptLength) + scriptLength, uint40(BTCTypes.ScriptPubkey));\\n    }\\n\\n    function scriptPubkeyBytes(bytes29 _output) internal typeAssert(_output, BTCTypes.TxOut) returns (bytes32) {\\n        uint64 scriptLength = indexCompactInt(_output, 8);\\n        bytes29 scriptPubkeyView = _output.slice(8, compactIntLength(scriptLength) + scriptLength, uint40(BTCTypes.ScriptPubkey));\\n        return scriptPubkeyView.index(compactIntLength(scriptLength), uint8(scriptLength));\\n    }\\n\\n    // @notice             determines the length of the first output in an array of outputs\\n    // @param _outputs     the vout without its length prefix\\n    // @return             the output length\\n    function outputLength(bytes29 _outputs) internal pure typeAssert(_outputs, BTCTypes.IntermediateTxOuts) returns (uint256) {\\n        uint64 scriptLength = indexCompactInt(_outputs, 8);\\n        return uint256(compactIntLength(scriptLength)) + uint256(scriptLength) + 8;\\n    }\\n\\n    // @notice         extracts the output at a specified index\\n    // @param _vout    the vout\\n    // @param _index   the index of the desired output\\n    // @return         the desired output\\n    // function indexVout(bytes29 _vout, uint256 _index) internal pure typeAssert(_vout, BTCTypes.Vout) returns (bytes29) {\\n    //     uint256 _nOuts = uint256(indexCompactInt(_vout, 0));\\n    //     uint256 _viewLen = _vout.len();\\n    //     require(_index < _nOuts, \\\"Vout read overrun\\\");\\n\\n    //     uint256 _offset = uint256(compactIntLength(uint64(_nOuts)));\\n    //     bytes29 _remaining;\\n    //     for (uint256 _i = 0; _i < _index; _i += 1) {\\n    //         _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n    //         _offset += outputLength(_remaining);\\n    //     }\\n\\n    //     _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n    //     uint256 _len = outputLength(_remaining);\\n    //     return _vout.slice(_offset, _len, uint40(BTCTypes.TxOut));\\n    // }\\n    function indexVout(bytes29 _vout, uint256 _index) internal pure returns (bytes29) {\\n        uint256 _nOuts = uint256(indexCompactInt(_vout, 0));\\n        uint256 _viewLen = _vout.len();\\n        require(_index < _nOuts, \\\"Vout read overrun\\\");\\n\\n        uint256 _offset = uint256(compactIntLength(uint64(_nOuts)));\\n        bytes29 _remaining;\\n        for (uint256 _i = 0; _i < _index; _i += 1) {\\n            _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n            _offset += outputLength(_remaining);\\n        }\\n\\n        _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n        uint256 _len = outputLength(_remaining);\\n        return _vout.slice(_offset, _len, uint40(BTCTypes.TxOut));\\n    }\\n\\n    // @notice         extracts the Op Return Payload\\n    // @param _spk     the scriptPubkey\\n    // @return         the Op Return Payload (or null if not a valid Op Return output)\\n    function opReturnPayload(bytes29 _spk) internal pure typeAssert(_spk, BTCTypes.ScriptPubkey) returns (bytes29) {\\n        uint64 _bodyLength = indexCompactInt(_spk, 0);\\n        uint64 _payloadLen = uint64(_spk.indexUint(2, 1));\\n        if (_bodyLength > 77 || _bodyLength < 4 || _spk.indexUint(1, 1) != 0x6a || _spk.indexUint(2, 1) != _bodyLength - 2) {\\n            return TypedMemView.nullView();\\n        }\\n        return _spk.slice(3, _payloadLen, uint40(BTCTypes.OpReturnPayload));\\n    }\\n\\n    // @notice         extracts the payload from a scriptPubkey\\n    // @param _spk     the scriptPubkey\\n    // @return         the payload (or null if not a valid PKH, SH, WPKH, or WSH output)\\n    function payload(bytes29 _spk) internal pure typeAssert(_spk, BTCTypes.ScriptPubkey) returns (bytes29) {\\n        uint256 _spkLength = _spk.len();\\n        uint256 _bodyLength = indexCompactInt(_spk, 0);\\n        if (_bodyLength > 0x22 || _bodyLength < 0x16 || _bodyLength + 1 != _spkLength) {\\n            return TypedMemView.nullView();\\n        }\\n\\n        // Legacy\\n        if (_bodyLength == 0x19 && _spk.indexUint(0, 4) == 0x1976a914 && _spk.indexUint(_spkLength - 2, 2) == 0x88ac) {\\n            return _spk.slice(4, 20, uint40(BTCTypes.PKH));\\n        } else if (_bodyLength == 0x17 && _spk.indexUint(0, 3) == 0x17a914 && _spk.indexUint(_spkLength - 1, 1) == 0x87) {\\n            return _spk.slice(3, 20, uint40(BTCTypes.SH));\\n        }\\n\\n        // Witness v0\\n        if (_spk.indexUint(1, 1) == 0) {\\n            uint256 _payloadLen = _spk.indexUint(2, 1);\\n            if (_bodyLength != 0x22 && _bodyLength != 0x16 || _payloadLen != _bodyLength - 2) {\\n                return TypedMemView.nullView();\\n            }\\n            uint40 newType = uint40(_payloadLen == 0x20 ? BTCTypes.WSH : BTCTypes.WPKH);\\n            return _spk.slice(3, _payloadLen, newType);\\n        }\\n\\n        return TypedMemView.nullView();\\n    }\\n\\n    // @notice     (loosely) verifies an spk and converts to a typed memory\\n    // @dev        will return null in error cases. Will not check for disabled opcodes.\\n    // @param _spk the spk\\n    // @return     the typed spk (or null if error)\\n    function tryAsSPK(bytes29 _spk) internal pure typeAssert(_spk, BTCTypes.Unknown) returns (bytes29) {\\n        if (_spk.len() == 0) {\\n            return TypedMemView.nullView();\\n        }\\n        uint64 _len = indexCompactInt(_spk, 0);\\n        if (_spk.len() == compactIntLength(_len) + _len) {\\n            return _spk.castTo(uint40(BTCTypes.ScriptPubkey));\\n        } else {\\n            return TypedMemView.nullView();\\n        }\\n    }\\n\\n    // @notice     verifies the vin and converts to a typed memory\\n    // @dev        will return null in error cases\\n    // @param _vin the vin\\n    // @return     the typed vin (or null if error)\\n    function tryAsVin(bytes29 _vin) internal pure typeAssert(_vin, BTCTypes.Unknown) returns (bytes29) {\\n        if (_vin.len() == 0) {\\n            return TypedMemView.nullView();\\n        }\\n        uint64 _nIns = indexCompactInt(_vin, 0);\\n        uint256 _viewLen = _vin.len();\\n        if (_nIns == 0) {\\n            return TypedMemView.nullView();\\n        }\\n\\n        uint256 _offset = uint256(compactIntLength(_nIns));\\n        for (uint256 i = 0; i < _nIns; i++) {\\n            if (_offset >= _viewLen) {\\n                // We've reached the end, but are still trying to read more\\n                return TypedMemView.nullView();\\n            }\\n            bytes29 _remaining = _vin.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxIns));\\n            _offset += inputLength(_remaining);\\n        }\\n        if (_offset != _viewLen) {\\n            return TypedMemView.nullView();\\n        }\\n        return _vin.castTo(uint40(BTCTypes.Vin));\\n    }\\n\\n    // @notice         verifies the vout and converts to a typed memory\\n    // @dev            will return null in error cases\\n    // @param _vout    the vout\\n    // @return         the typed vout (or null if error)\\n    function tryAsVout(bytes29 _vout) internal pure typeAssert(_vout, BTCTypes.Unknown) returns (bytes29) {\\n        if (_vout.len() == 0) {\\n            return TypedMemView.nullView();\\n        }\\n        uint64 _nOuts = indexCompactInt(_vout, 0);\\n        uint256 _viewLen = _vout.len();\\n        if (_nOuts == 0) {\\n            return TypedMemView.nullView();\\n        }\\n\\n        uint256 _offset = uint256(compactIntLength(_nOuts));\\n        for (uint256 i = 0; i < _nOuts; i++) {\\n            if (_offset >= _viewLen) {\\n                // We've reached the end, but are still trying to read more\\n                return TypedMemView.nullView();\\n            }\\n            bytes29 _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n            _offset += outputLength(_remaining);\\n        }\\n        if (_offset != _viewLen) {\\n            return TypedMemView.nullView();\\n        }\\n        return _vout.castTo(uint40(BTCTypes.Vout));\\n    }\\n\\n    // @notice         verifies the header and converts to a typed memory\\n    // @dev            will return null in error cases\\n    // @param _header  the header\\n    // @return         the typed header (or null if error)\\n    function tryAsHeader(bytes29 _header) internal pure typeAssert(_header, BTCTypes.Unknown) returns (bytes29) {\\n        if (_header.len() != 80) {\\n            return TypedMemView.nullView();\\n        }\\n        return _header.castTo(uint40(BTCTypes.Header));\\n    }\\n\\n\\n    // @notice         Index a header array.\\n    // @dev            Errors on overruns\\n    // @param _arr     The header array\\n    // @param index    The 0-indexed location of the header to get\\n    // @return         the typed header at `index`\\n    function indexHeaderArray(bytes29 _arr, uint256 index) internal pure typeAssert(_arr, BTCTypes.HeaderArray) returns (bytes29) {\\n        uint256 _start = index.mul(80);\\n        return _arr.slice(_start, 80, uint40(BTCTypes.Header));\\n    }\\n\\n\\n    // @notice     verifies the header array and converts to a typed memory\\n    // @dev        will return null in error cases\\n    // @param _arr the header array\\n    // @return     the typed header array (or null if error)\\n    function tryAsHeaderArray(bytes29 _arr) internal pure typeAssert(_arr, BTCTypes.Unknown) returns (bytes29) {\\n        if (_arr.len() % 80 != 0) {\\n            return TypedMemView.nullView();\\n        }\\n        return _arr.castTo(uint40(BTCTypes.HeaderArray));\\n    }\\n\\n    // @notice     verifies the merkle array and converts to a typed memory\\n    // @dev        will return null in error cases\\n    // @param _arr the merkle array\\n    // @return     the typed merkle array (or null if error)\\n    function tryAsMerkleArray(bytes29 _arr) internal pure typeAssert(_arr, BTCTypes.Unknown) returns (bytes29) {\\n        if (_arr.len() % 32 != 0) {\\n            return TypedMemView.nullView();\\n        }\\n        return _arr.castTo(uint40(BTCTypes.MerkleArray));\\n    }\\n\\n    // @notice         extracts the merkle root from the header\\n    // @param _header  the header\\n    // @return         the merkle root\\n    // function merkleRoot(bytes29 _header) internal pure typeAssert(_header, BTCTypes.Header) returns (bytes32) {\\n    //     return _header.index(36, 32);\\n    // }\\n\\n    function merkleRoot(bytes29 _header) internal pure returns (bytes32) {\\n        return _header.index(36, 32);\\n    }\\n\\n    // @notice         extracts the target from the header\\n    // @param _header  the header\\n    // @return         the target\\n    function target(bytes29  _header) internal pure typeAssert(_header, BTCTypes.Header) returns (uint256) {\\n        uint256 _mantissa = _header.indexLEUint(72, 3);\\n        uint256 _exponent = _header.indexUint(75, 1).sub(3);\\n        return _mantissa.mul(256 ** _exponent);\\n    }\\n\\n    // @notice         calculates the difficulty from a target\\n    // @param _target  the target\\n    // @return         the difficulty\\n    function toDiff(uint256  _target) internal pure returns (uint256) {\\n        return DIFF1_TARGET.div(_target);\\n    }\\n\\n    // @notice         extracts the difficulty from the header\\n    // @param _header  the header\\n    // @return         the difficulty\\n    function diff(bytes29  _header) internal pure typeAssert(_header, BTCTypes.Header) returns (uint256) {\\n        return toDiff(target(_header));\\n    }\\n\\n    // @notice         extracts the timestamp from the header\\n    // @param _header  the header\\n    // @return         the timestamp\\n    function time(bytes29  _header) internal pure typeAssert(_header, BTCTypes.Header) returns (uint32) {\\n        return uint32(_header.indexLEUint(68, 4));\\n    }\\n\\n    // @notice         extracts the parent hash from the header\\n    // @param _header  the header\\n    // @return         the parent hash\\n    function parent(bytes29 _header) internal pure typeAssert(_header, BTCTypes.Header) returns (bytes32) {\\n        return _header.index(4, 32);\\n    }\\n\\n    // @notice         calculates the Proof of Work hash of the header\\n    // @param _header  the header\\n    // @return         the Proof of Work hash\\n    function workHash(bytes29 _header) internal view typeAssert(_header, BTCTypes.Header) returns (bytes32) {\\n        return _header.hash256();\\n    }\\n\\n    // @notice         calculates the Proof of Work hash of the header, and converts to an integer\\n    // @param _header  the header\\n    // @return         the Proof of Work hash as an integer\\n    function work(bytes29 _header) internal view typeAssert(_header, BTCTypes.Header) returns (uint256) {\\n        return TypedMemView.reverseUint256(uint256(workHash(_header)));\\n    }\\n\\n    // @notice          Concatenates and hashes two inputs for merkle proving\\n    // @dev             Not recommended to call directly.\\n    // @param _a        The first hash\\n    // @param _b        The second hash\\n    // @return          The double-sha256 of the concatenated hashes\\n    function _merkleStep(bytes32 _a, bytes32 _b) internal view returns (bytes32 digest) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            mstore(ptr, _a)\\n            mstore(add(ptr, 0x20), _b)\\n            pop(staticcall(gas(), 2, ptr, 0x40, ptr, 0x20)) // sha2 #1\\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    // @notice         verifies a merkle proof\\n    // @param _leaf    the leaf\\n    // @param _proof   the merkle proof\\n    // @param _root    the merkle root\\n    // @param _index   the index\\n    // @return         true if valid, false if otherwise\\n    // function checkMerkle(\\n    //     bytes32 _leaf,\\n    //     bytes29 _proof,\\n    //     bytes32 _root,\\n    //     uint256 _index\\n    // ) internal view typeAssert(_proof, BTCTypes.MerkleArray) returns (bool) {\\n    //     uint256 nodes = _proof.len() / 32;\\n    //     if (nodes == 0) {\\n    //         return _leaf == _root;\\n    //     }\\n\\n    //     uint256 _idx = _index;\\n    //     bytes32 _current = _leaf;\\n\\n    //     for (uint i = 0; i < nodes; i++) {\\n    //         bytes32 _next = _proof.index(i * 32, 32);\\n    //         if (_idx % 2 == 1) {\\n    //             _current = _merkleStep(_next, _current);\\n    //         } else {\\n    //             _current = _merkleStep(_current, _next);\\n    //         }\\n    //         _idx >>= 1;\\n    //     }\\n\\n    //     return _current == _root;\\n    // }\\n    function checkMerkle(\\n        bytes32 _leaf, // _leaf is LE\\n        bytes29 _proof, // _proof nodes are LE\\n        bytes32 _root, // _root is BE (same as the merkle root that is stored in the block header)\\n        uint256 _index\\n    ) internal returns (bool) {\\n        uint256 nodes = _proof.len() / 32;\\n        if (nodes == 0) {\\n            return _leaf == _root;\\n        }\\n\\n        uint256 _idx = _index;\\n        bytes32 _current = _leaf;\\n\\n        for (uint i = 0; i < nodes; i++) {\\n            bytes32 _next = _proof.index(i * 32, 32);\\n            if (_idx % 2 == 1) {\\n                _current = _merkleStep(_next, _current);\\n            } else {\\n                _current = _merkleStep(_current, _next);\\n            }\\n            _idx >>= 1;\\n        }\\n\\n        return revertBytes32(_current) == _root;\\n    }\\n\\n    function revertBytes32 (bytes32 input) internal returns(bytes32) {\\n        bytes memory temp;\\n        bytes32 result;\\n        for (uint i = 0; i < 32; i++) {\\n            temp = abi.encodePacked(temp, input[31-i]);\\n        }\\n        assembly {\\n            result := mload(add(temp, 32))\\n        }\\n        return result;\\n    }\\n    // @notice                 performs the bitcoin difficulty retarget\\n    // @dev                    implements the Bitcoin algorithm precisely\\n    // @param _previousTarget  the target of the previous period\\n    // @param _firstTimestamp  the timestamp of the first block in the difficulty period\\n    // @param _secondTimestamp the timestamp of the last block in the difficulty period\\n    // @return                 the new period's target threshold\\n    function retargetAlgorithm(\\n        uint256 _previousTarget,\\n        uint256 _firstTimestamp,\\n        uint256 _secondTimestamp\\n    ) internal pure returns (uint256) {\\n        uint256 _elapsedTime = _secondTimestamp.sub(_firstTimestamp);\\n\\n        // Normalize ratio to factor of 4 if very long or very short\\n        if (_elapsedTime < RETARGET_PERIOD.div(4)) {\\n            _elapsedTime = RETARGET_PERIOD.div(4);\\n        }\\n        if (_elapsedTime > RETARGET_PERIOD.mul(4)) {\\n            _elapsedTime = RETARGET_PERIOD.mul(4);\\n        }\\n\\n        /*\\n            NB: high targets e.g. ffff0020 can cause overflows here\\n                so we divide it by 256**2, then multiply by 256**2 later\\n                we know the target is evenly divisible by 256**2, so this isn't an issue\\n        */\\n        uint256 _adjusted = _previousTarget.div(65536).mul(_elapsedTime);\\n        return _adjusted.div(RETARGET_PERIOD).mul(65536);\\n    }\\n}\",\"keccak256\":\"0x8e0dd74955a8b68e55672cd2b42c4eceb5dc363f7d3a9f0ef08dfd89fc9dad1c\"},\"contracts/libraries/ViewSPV.sol\":{\"content\":\"pragma solidity 0.7.6;\\n\\n/** @title ViewSPV */\\n/** @author Summa (https://summa.one) */\\n\\nimport \\\"./TypedMemView.sol\\\";\\nimport \\\"./ViewBTC.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\nlibrary ViewSPV {\\n    using TypedMemView for bytes;\\n    using TypedMemView for bytes29;\\n    using ViewBTC for bytes29;\\n    using SafeMath for uint256;\\n\\n    uint256 constant ERR_BAD_LENGTH = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n    uint256 constant ERR_INVALID_CHAIN = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe;\\n    uint256 constant ERR_LOW_WORK = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd;\\n\\n    function getErrBadLength() internal pure returns (uint256) {\\n        return ERR_BAD_LENGTH;\\n    }\\n\\n    function getErrInvalidChain() internal pure returns (uint256) {\\n        return ERR_INVALID_CHAIN;\\n    }\\n\\n    function getErrLowWork() internal pure returns (uint256) {\\n        return ERR_LOW_WORK;\\n    }\\n\\n    // @notice             requires `memView` to be of a specified type\\n    // @param memView      a 29-byte view with a 5-byte type\\n    // @param t            the expected type (e.g. BTCTypes.Outpoint, BTCTypes.TxIn, etc)\\n    // @return             passes if it is the correct type, errors if not\\n    modifier typeAssert(bytes29 memView, ViewBTC.BTCTypes t) {\\n        memView.assertType(uint40(t));\\n        _;\\n    }\\n\\n    // @notice                     Validates a tx inclusion in the block\\n    // @dev                        `index` is not a reliable indicator of location within a block\\n    // @param _txid                The txid (LE)\\n    // @param _merkleRoot          The merkle root (as in the block header)\\n    // @param _intermediateNodes   The proof's intermediate nodes (digests between leaf and root)\\n    // @param _index               The leaf's index in the tree (0-indexed)\\n    // @return                     true if fully valid, false otherwise\\n    // function prove(\\n    //     bytes32 _txid,\\n    //     bytes32 _merkleRoot,\\n    //     bytes29 _intermediateNodes,\\n    //     uint _index\\n    // ) internal view typeAssert(_intermediateNodes, ViewBTC.BTCTypes.MerkleArray) returns (bool) {\\n    //     // Shortcut the empty-block case\\n    //     if (_txid == _merkleRoot && _index == 0 && _intermediateNodes.len() == 0) {\\n    //         return true;\\n    //     }\\n\\n    //     return ViewBTC.checkMerkle(_txid, _intermediateNodes, _merkleRoot, _index);\\n    // }\\n    function prove(\\n        bytes32 _txid,\\n        bytes32 _merkleRoot,\\n        bytes29 _intermediateNodes,\\n        uint _index\\n    ) internal returns (bool) {\\n        // Shortcut the empty-block case\\n        if (revertBytes32(_txid) == _merkleRoot && _index == 0 && _intermediateNodes.len() == 0) {\\n            return true;\\n        }\\n\\n        return ViewBTC.checkMerkle(_txid, _intermediateNodes, _merkleRoot, _index);\\n    }\\n\\n    function revertBytes32 (bytes32 input) internal returns(bytes32) {\\n        bytes memory temp;\\n        bytes32 result;\\n        for (uint i = 0; i < 32; i++) {\\n            temp = abi.encodePacked(temp, input[31-i]);\\n        }\\n        assembly {\\n            result := mload(add(temp, 32))\\n        }\\n        return result;\\n    }\\n\\n    // @notice             Hashes transaction to get txid\\n    // @dev                Supports Legacy and Witness\\n    // @param _version     4-bytes version\\n    // @param _vin         Raw bytes length-prefixed input vector\\n    // @param _vout        Raw bytes length-prefixed output vector\\n    // @param _locktime    4-byte tx locktime\\n    // @return             32-byte transaction id, little endian\\n    function calculateTxId(\\n        bytes4 _version,\\n        bytes29 _vin,\\n        bytes29 _vout,\\n        bytes4 _locktime\\n    ) internal view typeAssert(_vin, ViewBTC.BTCTypes.Vin) typeAssert(_vout, ViewBTC.BTCTypes.Vout) returns (bytes32) {\\n        // TODO: write in assembly\\n        return abi.encodePacked(_version, _vin.clone(), _vout.clone(), _locktime).ref(0).hash256();\\n    }\\n\\n    // TODO: add test for checkWork\\n    // @notice             Checks validity of header work\\n    // @param _header      Header view\\n    // @param _target      The target threshold\\n    // @return             true if header work is valid, false otherwise\\n    function checkWork(bytes29 _header, uint256 _target) internal view typeAssert(_header, ViewBTC.BTCTypes.Header) returns (bool) {\\n        return _header.work() < _target;\\n    }\\n\\n\\n    // @notice                     Checks validity of header chain\\n    // @dev                        Compares current header parent to previous header's digest\\n    // @param _header              The raw bytes header\\n    // @param _prevHeaderDigest    The previous header's digest\\n    // @return                     true if the connect is valid, false otherwise\\n    function checkParent(bytes29 _header, bytes32 _prevHeaderDigest) internal pure typeAssert(_header, ViewBTC.BTCTypes.Header) returns (bool) {\\n        return _header.parent() == _prevHeaderDigest;\\n    }\\n\\n    // @notice             Checks validity of header chain\\n    // @notice             Compares the hash of each header to the prevHash in the next header\\n    // @param _headers     Raw byte array of header chain\\n    // @return             The total accumulated difficulty of the header chain, or an error code\\n    function checkChain(bytes29 _headers) internal view typeAssert(_headers, ViewBTC.BTCTypes.HeaderArray) returns (uint256 _totalDifficulty) {\\n        bytes32 _digest;\\n        uint256 _headerCount = _headers.len() / 80;\\n        for (uint256 i = 0; i < _headerCount; i += 1) {\\n            bytes29 _header = _headers.indexHeaderArray(i);\\n            if (i != 0) {\\n                if (!checkParent(_header, _digest)) {return ERR_INVALID_CHAIN;}\\n            }\\n            _digest = _header.workHash();\\n            uint256 _work = TypedMemView.reverseUint256(uint256(_digest));\\n            uint256 _target = _header.target();\\n\\n            if (_work > _target) {return ERR_LOW_WORK;}\\n\\n            _totalDifficulty += ViewBTC.toDiff(_target);\\n        }\\n    }\\n}\",\"keccak256\":\"0xeea5ed3e75d7ae65b2772c82564da30ff66d5e9550e437d2f1544df427532d50\"},\"contracts/relay/BitcoinRelay.sol\":{\"content\":\"pragma solidity ^0.7.6;\\n\\n/** @title Relay */\\n/** @author Summa (https://summa.one) */\\n\\nimport \\\"../libraries/SafeMath.sol\\\";\\nimport \\\"../libraries/TypedMemView.sol\\\";\\nimport \\\"../libraries/ViewBTC.sol\\\";\\nimport \\\"../libraries/ViewSPV.sol\\\";\\nimport \\\"./interfaces/IBitcoinRelay.sol\\\";\\nimport \\\"../routers/interfaces/IExchangeRouter.sol\\\";\\nimport \\\"../erc20/interfaces/IERC20.sol\\\";\\n\\ncontract BitcoinRelay is IBitcoinRelay {\\n    using SafeMath for uint256;\\n    using TypedMemView for bytes;\\n    using TypedMemView for bytes29;\\n    using ViewBTC for bytes29;\\n    using ViewSPV for bytes29;\\n\\n    /* using BytesLib for bytes;\\n    using BTCUtils for bytes;\\n    using ValidateSPV for bytes; */\\n\\n    // How often do we store the height?\\n    // A higher number incurs less storage cost, but more lookup cost\\n    // uint32 public constant HEIGHT_INTERVAL = 4;\\n    uint32 public constant HEIGHT_INTERVAL = 1;\\n    uint public override initialHeight;\\n    uint public override lastSubmittedHeight;\\n    uint public override finalizationParameter;\\n\\n    bytes32 internal relayGenesis;\\n    bytes32 internal bestKnownDigest;\\n    bytes32 internal lastReorgCommonAncestor;\\n    mapping (bytes32 => bytes32) internal previousBlock;\\n    mapping (bytes32 => uint256) internal blockHeight;\\n    mapping (uint => blockHeader[]) public chain;\\n    address public override owner;\\n\\n    uint256 internal currentEpochDiff;\\n    uint256 internal prevEpochDiff;\\n\\n    // reward parameters\\n    address public override TeleportDAOToken;\\n    uint public override feeRatio; // multiplied by 100 \\n    uint public override submissionGasUsed;\\n    uint public override epochLength; \\n    uint public override lastEpochQueries;\\n    uint public override baseQueries;\\n    uint public override lastBuyBack;\\n    uint public override buyBackPeriod;\\n    address public override exchangeRouter;\\n    address public override WAVAX;\\n    mapping (uint => uint) private numberOfQueries;\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /// @notice                   Gives a starting point for the relay\\n    /// @dev                      We don't check this AT ALL really. Don't use relays with bad genesis\\n    /// @param  _genesisHeader    The starting header\\n    /// @param  _height           The starting height\\n    /// @param  _periodStart      The hash of the first header in the genesis epoch\\n    constructor(\\n        bytes memory _genesisHeader, \\n        uint256 _height, \\n        bytes32 _periodStart, \\n        address _TeleportDAOToken, \\n        address _exchangeRouter\\n    ) public {\\n        bytes29 _genesisView = _genesisHeader.ref(0).tryAsHeader();\\n        require(_genesisView.notNull(), \\\"Stop being dumb\\\");\\n        bytes32 _genesisDigest = _genesisView.hash256();\\n        // add the initial block header to the chain\\n        blockHeader memory newBlockHeader;\\n        newBlockHeader.selfHash = _genesisDigest;\\n        newBlockHeader.merkleRoot = _genesisView.merkleRoot();\\n        chain[_height].push(newBlockHeader);\\n        // require(\\n        //     _periodStart & bytes32(0x0000000000000000000000000000000000000000000000000000000000ffffff) == bytes32(0),\\n        //     \\\"Period start hash does not have work. Hint: wrong byte order?\\\");\\n        relayGenesis = _genesisDigest;\\n        bestKnownDigest = _genesisDigest;\\n        lastReorgCommonAncestor = _genesisDigest;\\n        blockHeight[_genesisDigest] = _height;\\n        blockHeight[_periodStart] = _height.sub(_height % 2016);\\n        currentEpochDiff = _genesisView.diff();\\n        // added parameters\\n        finalizationParameter = 1; // TODO: edit it\\n        lastSubmittedHeight = _height;\\n        initialHeight = _height;\\n        // reward parameters\\n        TeleportDAOToken = _TeleportDAOToken;\\n        feeRatio = 0; // TODO: edit it;\\n        epochLength = 1;\\n        baseQueries = epochLength;\\n        lastEpochQueries = baseQueries;\\n        buyBackPeriod = 2; // TODO: edit it\\n        submissionGasUsed = 100000; // TODO: edit it\\n        exchangeRouter = _exchangeRouter;\\n        if (exchangeRouter != address(0)) {\\n            WAVAX = IExchangeRouter(exchangeRouter).WAVAX(); // call exchangeRouter to get WAVAX address\\n        }\\n        owner = msg.sender;\\n    }\\n\\n    fallback () external payable {\\n    }\\n\\n    function changeOwner(address _owner) external override onlyOwner {\\n        owner = _owner;\\n    }\\n\\n    function setFinalizationParameter(uint _finalizationParameter) external override onlyOwner {\\n        finalizationParameter = _finalizationParameter;\\n    }\\n\\n    function setFeeRatio(uint _feeRatio) external override onlyOwner {\\n        feeRatio = _feeRatio;\\n    }\\n\\n    function setEpochLength(uint _epochLength) external override onlyOwner {\\n        epochLength = _epochLength;\\n    }\\n\\n    function setBuyBackPeriod(uint _buyBackPeriod) external override onlyOwner {\\n        buyBackPeriod = _buyBackPeriod;\\n    }\\n\\n    function setBaseQueries(uint _baseQueries) external override onlyOwner {\\n        baseQueries = _baseQueries;\\n    }\\n\\n    function setSubmissionGasUsed(uint _submissionGasUsed) external override onlyOwner {\\n        submissionGasUsed = _submissionGasUsed;\\n    }\\n\\n    function setExchangeRouter(address _exchangeRouter) external override onlyOwner {\\n        exchangeRouter = _exchangeRouter;\\n    }\\n\\n    /// @notice     Getter for currentEpochDiff\\n    /// @dev        This is updated when a new heavist header has a new diff\\n    /// @return     The difficulty of the bestKnownDigest\\n    function getCurrentEpochDifficulty() external view override returns (uint256) {\\n        return currentEpochDiff;\\n    }\\n    /// @notice     Getter for prevEpochDiff\\n    /// @dev        This is updated when a difficulty change is accepted\\n    /// @return     The difficulty of the previous epoch\\n    function getPrevEpochDifficulty() external view override returns (uint256) {\\n        return prevEpochDiff;\\n    }\\n\\n    /// @notice     Getter for relayGenesis\\n    /// @dev        This is an initialization parameter\\n    /// @return     The hash of the first block of the relay\\n    function getRelayGenesis() public view override returns (bytes32) {\\n        return relayGenesis;\\n    }\\n\\n    /// @notice     Getter for bestKnownDigest\\n    /// @dev        This updated only by calling markNewHeaviest\\n    /// @return     The hash of the best marked chain tip\\n    function getBestKnownDigest() public view override returns (bytes32) {\\n        return bestKnownDigest;\\n    }\\n\\n    /// @notice     Getter for relayGenesis\\n    /// @dev        This is updated only by calling markNewHeaviest\\n    /// @return     The hash of the shared ancestor of the most recent fork\\n    function getLastReorgCommonAncestor() public view override returns (bytes32) {\\n        return lastReorgCommonAncestor;\\n    }\\n\\n    /// @notice         Finds the height of a header by its digest\\n    /// @dev            Will fail if the header is unknown\\n    /// @param _digest  The header digest to search for\\n    /// @return         The height of the header, or error if unknown\\n    function findHeight(bytes32 _digest) external view override returns (uint256) {\\n        return _findHeight(_digest);\\n    }\\n\\n    /// @notice         Finds an ancestor for a block by its digest\\n    /// @dev            Will fail if the header is unknown\\n    /// @param _digest  The header digest to search for\\n    /// @return         The height of the header, or error if unknown\\n    function findAncestor(bytes32 _digest, uint256 _offset) external view override returns (bytes32) {\\n        return _findAncestor(_digest, _offset);\\n    }\\n\\n    /// @notice             Checks if a digest is an ancestor of the current one\\n    /// @dev                Limit the amount of lookups (and thus gas usage) with _limit\\n    /// @param _ancestor    The prospective ancestor\\n    /// @param _descendant  The descendant to check\\n    /// @param _limit       The maximum number of blocks to check\\n    /// @return             true if ancestor is at most limit blocks lower than descendant, otherwise false\\n    function isAncestor(bytes32 _ancestor, bytes32 _descendant, uint256 _limit) external view override returns (bool) {\\n        return _isAncestor(_ancestor, _descendant, _limit);\\n    }\\n\\n    function checkTxProof (\\n        bytes32 txid, // in BE form\\n        uint blockHeight,\\n        bytes calldata intermediateNodes, // in LE form\\n        uint index,\\n        bool payWithTDT,\\n        uint neededConfirmations\\n    ) public override returns (bool) {\\n        if (blockHeight + neededConfirmations < lastSubmittedHeight + 1) {\\n            for (uint i = 0; i < chain[blockHeight].length; i ++) {\\n                bytes32 _merkleRoot = revertBytes32(chain[blockHeight][i].merkleRoot);\\n                bytes29 intermediateNodes = intermediateNodes.ref(0).tryAsMerkleArray();\\n                bytes32 txIdLE = revertBytes32(txid);\\n                if (ViewSPV.prove(txIdLE, _merkleRoot, intermediateNodes, index)) {\\n                    // getFee(payWithTDT);\\n                    return true;\\n                }\\n            }\\n            require(false, \\\"tx has not been included\\\");\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function getFee (bool payWithTDT) internal {\\n        uint feeAmount;\\n        feeAmount = (submissionGasUsed*tx.gasprice*feeRatio*epochLength)/(100*lastEpochQueries);\\n        if (payWithTDT == false) {\\n            // require(msg.value >= feeAmount, \\\"fee is not enough\\\");\\n            if (msg.value >= feeAmount){\\n                msg.sender.send(feeAmount);\\n            }\\n        } else { // payWithTDT == true\\n            feeAmount = getFeeAmountInTDT(feeAmount);\\n            uint TDTBalance = IERC20(TeleportDAOToken).balanceOf(address(this));\\n            if (feeAmount > 0 && TDTBalance >= feeAmount) {\\n                IERC20(TeleportDAOToken).transferFrom(msg.sender, address(this), feeAmount); // tx.origin instead of msg.sender\\n            }\\n        }\\n    }\\n\\n    /// @notice             Adds headers to storage after validating\\n    /// @dev                We check integrity and consistency of the header chain\\n    /// @param  _anchor     The header immediately preceeding the new chain\\n    /// @param  _headers    A tightly-packed list of 80-byte Bitcoin headers\\n    /// @return             True if successfully written, error otherwise\\n    function addHeaders(bytes calldata _anchor, bytes calldata _headers) external override returns (bool) {\\n        bytes29 _headersView = _headers.ref(0).tryAsHeaderArray();\\n        bytes29 _anchorView = _anchor.ref(0).tryAsHeader();\\n\\n        require(_headersView.notNull(), \\\"Header array length must be divisible by 80\\\");\\n        require(_anchorView.notNull(), \\\"Anchor must be 80 bytes\\\");\\n\\n        return _addHeaders(_anchorView, _headersView, false);\\n    }\\n\\n    /// @notice                       Adds headers to storage, performs additional validation of retarget\\n    /// @dev                          Checks the retarget, the heights, and the linkage\\n    /// @param  _oldPeriodStartHeader The first header in the difficulty period being closed\\n    /// @param  _oldPeriodEndHeader   The last header in the difficulty period being closed\\n    /// @param  _headers              A tightly-packed list of 80-byte Bitcoin headers\\n    /// @return                       True if successfully written, error otherwise\\n    function addHeadersWithRetarget(\\n        bytes calldata _oldPeriodStartHeader,\\n        bytes calldata _oldPeriodEndHeader,\\n        bytes calldata _headers\\n    ) external override returns (bool) {\\n        bytes29 _oldStart = _oldPeriodStartHeader.ref(0).tryAsHeader();\\n        bytes29 _oldEnd = _oldPeriodEndHeader.ref(0).tryAsHeader();\\n        bytes29 _headersView = _headers.ref(0).tryAsHeaderArray();\\n\\n        require(\\n            _oldStart.notNull() && _oldEnd.notNull() && _headersView.notNull(),\\n            \\\"Bad args. Check header and array byte lengths.\\\"\\n        );\\n\\n        return _addHeadersWithRetarget(_oldStart, _oldEnd, _headersView);\\n    }\\n\\n    /// @notice                   Gives a starting point for the relay\\n    /// @dev                      We don't check this AT ALL really. Don't use relays with bad genesis\\n    /// @param  _ancestor         The digest of the most recent common ancestor\\n    /// @param  _currentBest      The 80-byte header referenced by bestKnownDigest\\n    /// @param  _newBest          The 80-byte header to mark as the new best\\n    /// @param  _limit            Limit the amount of traversal of the chain\\n    /// @return                   True if successfully updates bestKnownDigest, error otherwise\\n    function markNewHeaviest(\\n        bytes32 _ancestor,\\n        bytes calldata _currentBest,\\n        bytes calldata _newBest,\\n        uint256 _limit\\n    ) external override returns (bool) {\\n        bytes29 _new = _newBest.ref(0).tryAsHeader();\\n        bytes29 _current = _currentBest.ref(0).tryAsHeader();\\n        require(\\n            _new.notNull() && _current.notNull(),\\n            \\\"Bad args. Check header and array byte lengths.\\\"\\n        );\\n        return _markNewHeaviest(_ancestor, _current, _new, _limit);\\n    }\\n\\n    /// @notice             Adds headers to storage after validating\\n    /// @dev                We check integrity and consistency of the header chain\\n    /// @param  _anchor     The header immediately preceeding the new chain\\n    /// @param  _headers    A tightly-packed list of new 80-byte Bitcoin headers to record\\n    /// @param  _internal   True if called internally from addHeadersWithRetarget, false otherwise\\n    /// @return             True if successfully written, error otherwise\\n    function _addHeaders(bytes29 _anchor, bytes29 _headers, bool _internal) internal returns (bool) {\\n        // Extract basic info\\n        bytes32 _previousDigest = _anchor.hash256();\\n        uint256 _anchorHeight = _findHeight(_previousDigest);  /* NB: errors if unknown */\\n        uint256 _target = _headers.indexHeaderArray(0).target();\\n        // TODO: uncomment it\\n        // require(\\n        //     _internal || _anchor.target() == _target,\\n        //     \\\"Unexpected retarget on external call\\\"\\n        // );\\n\\n        /*\\n        NB:\\n        1. check that the header has sufficient work\\n        2. check that headers are in a coherent chain (no retargets, hash links good)\\n        3. Store the block connection\\n        4. Store the height\\n        */\\n        uint256 _height;\\n        bytes32 _currentDigest;\\n        for (uint256 i = 0; i < _headers.len() / 80; i += 1) {\\n            bytes29 _header = _headers.indexHeaderArray(i);\\n            _height = _anchorHeight.add(i + 1);\\n            _currentDigest = _header.hash256();\\n\\n            /* NB: we do still need to make chain level checks tho */\\n            // require(_header.target() == _target, \\\"Target changed unexpectedly\\\");\\n            require(_header.checkParent(_previousDigest), \\\"Headers do not form a consistent chain\\\");\\n            /*\\n            NB:\\n            if the block is already authenticated, we don't need to a work check\\n            Or write anything to state. This saves gas\\n            */\\n            // the below check prevents adding a replicated block header\\n            if (previousBlock[_currentDigest] == bytes32(0)) {\\n                require(\\n                    TypedMemView.reverseUint256(uint256(_currentDigest)) <= _target,\\n                    \\\"Header work is insufficient\\\"\\n                );\\n                previousBlock[_currentDigest] = _previousDigest;\\n                if (_height % HEIGHT_INTERVAL == 0) {\\n                    /*\\n                    NB: We store the height only every 4th header to save gas\\n                    */\\n                    blockHeight[_currentDigest] = _height;\\n                }\\n                addToChain(_header, _height);\\n            }\\n            _previousDigest = _currentDigest;\\n        }\\n        uint rewardAmount;\\n        bool isTDT;\\n        (rewardAmount, isTDT) = sendReward(msg.sender, _headers.len()); \\n        emit BlockAdded(_height - _headers.len()/80 + 1, _height, msg.sender, rewardAmount, isTDT);\\n        return true;\\n    }\\n\\n    function sendReward (address relayer, uint numberOfBlocks) internal returns (uint, bool) {\\n        uint rewardAmountInTNT = numberOfBlocks*submissionGasUsed*tx.gasprice*feeRatio/100; // TNT is target native token\\n        uint rewardAmountInTDT = getRewardAmountInTDT(rewardAmountInTNT);\\n        uint contractTDTBalance;\\n        if (TeleportDAOToken != address(0)) {\\n            contractTDTBalance = IERC20(TeleportDAOToken).balanceOf(address(this));\\n        } else {\\n            contractTDTBalance = 0;\\n        }\\n        uint contractTNTBalance = address(this).balance;\\n        if (rewardAmountInTDT <= contractTDTBalance && rewardAmountInTDT > 0) {\\n            // call ERC20 token contract to transfer reward tokens to the relayer\\n            IERC20(TeleportDAOToken).transfer(relayer, rewardAmountInTDT);\\n            return (rewardAmountInTDT, true);\\n        } else if (rewardAmountInTNT <= contractTNTBalance && rewardAmountInTNT > 0) {\\n            // transfer TNT from relay to relayer \\n            msg.sender.transfer(rewardAmountInTNT);\\n            return (rewardAmountInTNT, false);\\n        }\\n    }\\n\\n    function getRewardAmountInTDT(uint rewardAmountInTNT) internal returns(uint) { \\n        // TODO: calculate the reward using the swap rate between the token and TDT\\n        return 0; \\n    }\\n    \\n    function getFeeAmountInTDT(uint feeAmount) internal returns(uint) { \\n        // TODO: calculate the fee using the swap rate between the token and TDT\\n        return 0; \\n    }\\n\\n    function addToChain(bytes29 _header, uint _height) internal {\\n        // prevent relayers to submit too old block headers\\n        // TODO: replace 6 with a correct number\\n        require(_height + 2*finalizationParameter >= lastSubmittedHeight, \\\"block header is too old\\\");\\n        blockHeader memory newBlockHeader;\\n        newBlockHeader.selfHash = _header.hash256();\\n        newBlockHeader.parentHash = _header.parent();\\n        newBlockHeader.merkleRoot = _header.merkleRoot();\\n        chain[_height].push(newBlockHeader);\\n        if(_height > lastSubmittedHeight){\\n            lastSubmittedHeight++;\\n            pruneChain();\\n        }\\n    }\\n\\n    function pruneChain() internal {\\n        if ((lastSubmittedHeight - initialHeight) >= finalizationParameter){\\n            uint idx = finalizationParameter;\\n            uint currentHeight = lastSubmittedHeight;\\n            uint stableIdx = 0;\\n            while (idx > 0) {\\n                // bytes29 header = chain[currentHeight][stableIdx];\\n                bytes32 parentHeaderHash = chain[currentHeight][stableIdx].parentHash;\\n                stableIdx = findIndex(parentHeaderHash, currentHeight-1);\\n                idx--;\\n                currentHeight--;\\n            }\\n            // keep the finalized block header and delete rest of headers\\n            chain[currentHeight][0] = chain[currentHeight][stableIdx];\\n            if(chain[currentHeight].length > 1){\\n                deleteHeight(currentHeight);\\n            }\\n        }\\n    }\\n\\n    function findIndex(bytes32 headerHash, uint height) internal returns(uint) {\\n        for(uint index = 0; index < chain[height].length; index ++) {\\n            if(headerHash == chain[height][index].selfHash) {\\n                return index;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    function deleteHeight(uint height) internal {\\n        uint idx = 1;\\n        while(idx < chain[height].length){\\n            delete chain[height][idx];\\n            idx++;\\n        }\\n    }\\n\\n    /// @notice                       Adds headers to storage, performs additional validation of retarget\\n    /// @dev                          Checks the retarget, the heights, and the linkage\\n    /// @param  _oldStart             The first header in the difficulty period being closed\\n    /// @param  _oldEnd               The last header in the difficulty period being closed\\n    /// @param  _headers              A tightly-packed list of 80-byte Bitcoin headers\\n    /// @return                       True if successfully written, error otherwise\\n    function _addHeadersWithRetarget(\\n        bytes29 _oldStart,\\n        bytes29 _oldEnd,\\n        bytes29 _headers\\n    ) internal returns (bool) {\\n\\n        /* NB: requires that both blocks are known */\\n        uint256 _startHeight = _findHeight(_oldStart.hash256());\\n        uint256 _endHeight = _findHeight(_oldEnd.hash256());\\n\\n        /* NB: retargets should happen at 2016 block intervals */\\n        require(\\n            _endHeight % 2016 == 2015,\\n            \\\"Must provide the last header of the closing difficulty period\\\");\\n        require(\\n            _endHeight == _startHeight.add(2015),\\n            \\\"Must provide exactly 1 difficulty period\\\");\\n        require(\\n            _oldStart.diff() == _oldEnd.diff(),\\n            \\\"Period header difficulties do not match\\\");\\n\\n        /* NB: This comparison looks weird because header nBits encoding truncates targets */\\n        bytes29 _newStart = _headers.indexHeaderArray(0);\\n        uint256 _actualTarget = _newStart.target();\\n        uint256 _expectedTarget = ViewBTC.retargetAlgorithm(\\n            _oldStart.target(),\\n            _oldStart.time(),\\n            _oldEnd.time()\\n        );\\n        require(\\n            (_actualTarget & _expectedTarget) == _actualTarget,\\n            \\\"Invalid retarget provided\\\");\\n\\n        // If the current known prevEpochDiff doesn't match, and this old period is near the chaintip/\\n        // update the stored prevEpochDiff\\n        // Don't update if this is a deep past epoch\\n        uint256 _oldDiff = _oldStart.diff();\\n        if (prevEpochDiff != _oldDiff && _endHeight > _findHeight(bestKnownDigest).sub(2016)) {\\n            prevEpochDiff = _oldDiff;\\n        }\\n\\n        // Pass all but the first through to be added\\n        return _addHeaders(_oldEnd, _headers, true);\\n    }\\n\\n    /// @notice         Finds the height of a header by its digest\\n    /// @dev            Will fail if the header is unknown\\n    /// @param _digest  The header digest to search for\\n    /// @return         The height of the header\\n    function _findHeight(bytes32 _digest) internal view returns (uint256) {\\n        uint256 _height = 0;\\n        bytes32 _current = _digest;\\n        for (uint256 i = 0; i < HEIGHT_INTERVAL + 1; i = i.add(1)) {\\n            _height = blockHeight[_current];\\n            if (_height == 0) {\\n                _current = previousBlock[_current];\\n            } else {\\n                return _height.add(i);\\n            }\\n        }\\n        revert(\\\"Unknown block\\\");\\n    }\\n\\n    /// @notice         Finds an ancestor for a block by its digest\\n    /// @dev            Will fail if the header is unknown\\n    /// @param _digest  The header digest to search for\\n    /// @return         The height of the header, or error if unknown\\n    function _findAncestor(bytes32 _digest, uint256 _offset) internal view returns (bytes32) {\\n        bytes32 _current = _digest;\\n        for (uint256 i = 0; i < _offset; i = i.add(1)) {\\n            _current = previousBlock[_current];\\n        }\\n        require(_current != bytes32(0), \\\"Unknown ancestor\\\");\\n        return _current;\\n    }\\n\\n    /// @notice             Checks if a digest is an ancestor of the current one\\n    /// @dev                Limit the amount of lookups (and thus gas usage) with _limit\\n    /// @param _ancestor    The prospective ancestor\\n    /// @param _descendant  The descendant to check\\n    /// @param _limit       The maximum number of blocks to check\\n    /// @return             true if ancestor is at most limit blocks lower than descendant, otherwise false\\n    function _isAncestor(bytes32 _ancestor, bytes32 _descendant, uint256 _limit) internal view returns (bool) {\\n        bytes32 _current = _descendant;\\n        /* NB: 200 gas/read, so gas is capped at ~200 * limit */\\n        for (uint256 i = 0; i < _limit; i = i.add(1)) {\\n            if (_current == _ancestor) {\\n                return true;\\n            }\\n            _current = previousBlock[_current];\\n        }\\n        return false;\\n    }\\n\\n    /// @notice                   Marks the new best-known chain tip\\n    /// @param  _ancestor         The digest of the most recent common ancestor\\n    /// @param  _current          The 80-byte header referenced by bestKnownDigest\\n    /// @param  _new              The 80-byte header to mark as the new best\\n    /// @param  _limit            Limit the amount of traversal of the chain\\n    /// @return                   True if successfully updates bestKnownDigest, error otherwise\\n    function _markNewHeaviest(\\n        bytes32 _ancestor,\\n        bytes29 _current,  // Header\\n        bytes29 _new,      // Header\\n        uint256 _limit\\n    ) internal returns (bool) {\\n        require(_limit <= 2016, \\\"Requested limit is greater than 1 difficulty period\\\");\\n\\n        bytes32 _newBestDigest = _new.hash256();\\n        bytes32 _currentBestDigest = _current.hash256();\\n        require(_currentBestDigest == bestKnownDigest, \\\"Passed in best is not best known\\\");\\n        require(\\n            previousBlock[_newBestDigest] != bytes32(0),\\n            \\\"New best is unknown\\\"\\n        );\\n        require(\\n            _isMostRecentAncestor(_ancestor, bestKnownDigest, _newBestDigest, _limit),\\n            \\\"Ancestor must be heaviest common ancestor\\\"\\n        );\\n        require(\\n            _heaviestFromAncestor(_ancestor, _current, _new) == _newBestDigest,\\n            \\\"New best hash does not have more work than previous\\\"\\n        );\\n\\n        bestKnownDigest = _newBestDigest;\\n        lastReorgCommonAncestor = _ancestor;\\n\\n        uint256 _newDiff = _new.diff();\\n        if (_newDiff != currentEpochDiff) {\\n            currentEpochDiff = _newDiff;\\n        }\\n\\n        emit NewTip(\\n            _currentBestDigest,\\n            _newBestDigest,\\n            _ancestor);\\n        return true;\\n    }\\n\\n    /// @notice             Checks if a digest is an ancestor of the current one\\n    /// @dev                Limit the amount of lookups (and thus gas usage) with _limit\\n    /// @param _ancestor    The prospective shared ancestor\\n    /// @param _left        A chain tip\\n    /// @param _right       A chain tip\\n    /// @param _limit       The maximum number of blocks to check\\n    /// @return             true if it is the most recent common ancestor within _limit, false otherwise\\n    function _isMostRecentAncestor(\\n        bytes32 _ancestor,\\n        bytes32 _left,\\n        bytes32 _right,\\n        uint256 _limit\\n    ) internal view returns (bool) {\\n        /* NB: sure why not */\\n        if (_ancestor == _left && _ancestor == _right) {\\n            return true;\\n        }\\n\\n        bytes32 _leftCurrent = _left;\\n        bytes32 _rightCurrent = _right;\\n        bytes32 _leftPrev = _left;\\n        bytes32 _rightPrev = _right;\\n\\n        for(uint256 i = 0; i < _limit; i = i.add(1)) {\\n            if (_leftPrev != _ancestor) {\\n                _leftCurrent = _leftPrev;  // cheap\\n                _leftPrev = previousBlock[_leftPrev];  // expensive\\n            }\\n            if (_rightPrev != _ancestor) {\\n                _rightCurrent = _rightPrev;  // cheap\\n                _rightPrev = previousBlock[_rightPrev];  // expensive\\n            }\\n        }\\n        if (_leftCurrent == _rightCurrent) {return false;} /* NB: If the same, they're a nearer ancestor */\\n        if (_leftPrev != _rightPrev) {return false;} /* NB: Both must be ancestor */\\n        return true;\\n    }\\n\\n    /// @notice             Decides which header is heaviest from the ancestor\\n    /// @dev                Does not support reorgs above 2017 blocks (:\\n    /// @param _ancestor    The prospective shared ancestor\\n    /// @param _left        A chain tip\\n    /// @param _right       A chain tip\\n    /// @return             true if it is the most recent common ancestor within _limit, false otherwise\\n    function _heaviestFromAncestor(\\n        bytes32 _ancestor,\\n        bytes29 _left,\\n        bytes29 _right\\n    ) internal view returns (bytes32) {\\n        uint256 _ancestorHeight = _findHeight(_ancestor);\\n        uint256 _leftHeight = _findHeight(_left.hash256());\\n        uint256 _rightHeight = _findHeight(_right.hash256());\\n\\n        require(\\n            _leftHeight >= _ancestorHeight && _rightHeight >= _ancestorHeight,\\n            \\\"A descendant height is below the ancestor height\\\");\\n\\n        /* NB: we can shortcut if one block is in a new difficulty window and the other isn't */\\n        uint256 _nextPeriodStartHeight = _ancestorHeight.add(2016).sub(_ancestorHeight % 2016);\\n        bool _leftInPeriod = _leftHeight < _nextPeriodStartHeight;\\n        bool _rightInPeriod = _rightHeight < _nextPeriodStartHeight;\\n\\n        /*\\n        NB:\\n        1. Left is in a new window, right is in the old window. Left is heavier\\n        2. Right is in a new window, left is in the old window. Right is heavier\\n        3. Both are in the same window, choose the higher one\\n        4. They're in different new windows. Choose the heavier one\\n        */\\n        if (!_leftInPeriod && _rightInPeriod) {return _left.hash256();}\\n        if (_leftInPeriod && !_rightInPeriod) {return _right.hash256();}\\n        if (_leftInPeriod && _rightInPeriod) {\\n            return _leftHeight >= _rightHeight ? _left.hash256() : _right.hash256();\\n        } else {  // if (!_leftInPeriod && !_rightInPeriod) {\\n            if (((_leftHeight % 2016).mul(_left.diff())) <\\n                (_rightHeight % 2016).mul(_right.diff())) {\\n                return _right.hash256();\\n            } else {\\n                return _left.hash256();\\n            }\\n        }\\n    }\\n\\n    function revertBytes32 (bytes32 input) internal returns(bytes32) {\\n        bytes memory temp;\\n        bytes32 result;\\n        for (uint i = 0; i < 32; i++) {\\n            temp = abi.encodePacked(temp, input[31-i]);\\n        }\\n        assembly {\\n            result := mload(add(temp, 32))\\n        }\\n        return result;\\n    }\\n\\n    function revertBytes (bytes memory input) internal returns(bytes memory) {\\n        bytes memory result;\\n        uint len = input.length;\\n        for (uint i = 0; i < len; i++) {\\n            result = abi.encodePacked(result, input[len-i-1]);\\n        }\\n        return result;\\n    }\\n    \\n    function calculateTxId (\\n        bytes4 _version,\\n        bytes memory _vin,\\n        bytes memory _vout,\\n        bytes4 _locktime\\n    ) external override returns(bytes32) {\\n        bytes32 inputHash1 = sha256(abi.encodePacked(_version, _vin, _vout, _locktime));\\n        bytes32 inputHash2 = sha256(abi.encodePacked(inputHash1));\\n        console.log(\\\"inputHash2\\\");\\n        console.logBytes32(inputHash2);\\n        return inputHash2;\\n    }\\n\\n    function getBlockHeaderHash (uint height, uint index) external override returns(bytes32) {\\n        return revertBytes32(chain[height][index].selfHash);\\n    }\\n\\n\\tfunction getNumberOfSubmittedHeaders (uint height) external view override returns (uint) {\\n        return chain[height].length;\\n    }\\n}\\n\",\"keccak256\":\"0x736d93a02472cd658e2b08bde0d7d4d7d206e9286fba48bc4abf653e2f988461\"},\"contracts/relay/interfaces/IBitcoinRelay.sol\":{\"content\":\"pragma solidity 0.7.6;\\n\\ninterface IBitcoinRelay {\\n    // structures\\n    struct blockHeader{\\n        bytes32 selfHash;\\n\\t\\tbytes32 parentHash;\\n\\t\\tbytes32 merkleRoot;\\n    }\\n\\n    // events\\n    event BlockAdded(uint256 firstHeight, uint256 lastHeight, address relayer, uint rewardAmount, bool isTDT);\\n    event NewTip(bytes32 indexed _from, bytes32 indexed _to, bytes32 indexed _gcd);\\n\\n    // read-only functions\\n    function owner() external view returns (address);\\n    function getCurrentEpochDifficulty() external view returns (uint256);\\n    function getPrevEpochDifficulty() external view returns (uint256);\\n    function getRelayGenesis() external view returns (bytes32);\\n    function getBestKnownDigest() external view returns (bytes32);\\n    function getLastReorgCommonAncestor() external view returns (bytes32);\\n    function initialHeight() external view returns(uint);\\n    function lastSubmittedHeight() external view returns(uint);\\n    function finalizationParameter() external view returns(uint);\\n    function TeleportDAOToken() external view returns(address);\\n\\tfunction feeRatio() external view returns(uint);\\n\\tfunction epochLength() external view returns(uint);\\n\\tfunction lastEpochQueries() external view returns(uint);\\n\\tfunction baseQueries() external view returns(uint);\\n\\tfunction submissionGasUsed() external view returns(uint);\\n\\t// function chain(uint) external returns(blockHeader[] memory);\\n\\tfunction getBlockHeaderHash (uint height, uint index) external returns(bytes32);\\n\\tfunction getNumberOfSubmittedHeaders (uint height) external view returns (uint);\\n\\t// function availableTDT() external view returns(uint);\\n    // function availableTNT() external view returns(uint);\\n\\tfunction lastBuyBack() external view returns(uint);\\n\\tfunction buyBackPeriod() external view returns(uint);\\n\\tfunction exchangeRouter() external view returns(address);\\n\\tfunction WAVAX() external view returns(address);\\n    function findHeight(bytes32 _digest) external view returns (uint256);\\n    function findAncestor(bytes32 _digest, uint256 _offset) external view returns (bytes32);\\n    function isAncestor(bytes32 _ancestor, bytes32 _descendant, uint256 _limit) external view returns (bool);\\n\\n    // state-changing functions\\n    function changeOwner(address _owner) external;\\n    function setFinalizationParameter(uint _finalizationParameter) external;\\n    function setFeeRatio(uint _feeRatio) external;\\n    function setEpochLength(uint _epochLength) external;\\n    function setBuyBackPeriod(uint _buyBackPeriod) external;\\n    function setBaseQueries(uint _baseQueries) external;\\n    function setSubmissionGasUsed(uint _submissionGasUsed) external;\\n    function setExchangeRouter(address _exchangeRouter) external;\\n    function checkTxProof(\\n        bytes32 txid,\\n        uint blockHeight,\\n        bytes calldata intermediateNodes,\\n        uint index,\\n        bool payWithTDT,\\n        uint neededConfirmations\\n    ) external returns (bool);\\n    function addHeaders(bytes calldata _anchor, bytes calldata _headers) external returns (bool);\\n    function addHeadersWithRetarget(\\n        bytes calldata _oldPeriodStartHeader,\\n        bytes calldata _oldPeriodEndHeader,\\n        bytes calldata _headers\\n    ) external returns (bool);\\n    function markNewHeaviest(\\n        bytes32 _ancestor,\\n        bytes calldata _currentBest,\\n        bytes calldata _newBest,\\n        uint256 _limit\\n    ) external returns (bool);\\n    function calculateTxId (\\n        bytes4 _version,\\n        bytes memory _vin,\\n        bytes memory _vout,\\n        bytes4 _locktime\\n    ) external returns(bytes32);\\n\\n}\",\"keccak256\":\"0x3b8ad1a1ea89e7fb16e802ad6afb59bbca9bd991242aeb8385c09dad77563851\"},\"contracts/routers/interfaces/IExchangeRouter.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\ninterface IExchangeRouter {\\n    // read-only functions\\n    function liquidityPoolFactory() external view returns (address);\\n    // function bitcoinInstantPool() external view returns (address);\\n    // function wrappedBitcoin() external view returns (address);\\n    function WAVAX() external view returns (address);\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external returns (uint[] memory amounts);\\n\\n    // state-changing functions\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityAVAX(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountAVAXMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityAVAX(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountAVAXMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountAVAX);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts, bool result);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactAVAXForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n    function swapTokensForExactAVAX(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to, uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactTokensForAVAX(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to, uint deadline\\n    ) external returns (uint[] memory amounts, bool result);\\n    function swapAVAXForExactTokens(\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\",\"keccak256\":\"0x498fbfb3d4028594c685b3b7c6b6b293bf25ff877399fe54626ae224d3552aa4\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b506040516200480d3803806200480d833981810160405260a08110156200003757600080fd5b81019080805160405193929190846401000000008211156200005857600080fd5b9083019060208201858111156200006e57600080fd5b82516401000000008111828201881017156200008957600080fd5b82525081516020918201929091019080838360005b83811015620000b85781810151838201526020016200009e565b50505050905090810190601f168015620000e65780820380516001836020036101000a031916815260200191505b50604090815260208281015191830151606084015160809094015192955093506000906200013d906200012690889084906200156b620003c1821b17901c565b62ffffff1916620003e960201b6200158f1760201c565b90506200015b8162ffffff19166200048460201b620015f11760201c565b6200019f576040805162461bcd60e51b815260206004820152600f60248201526e29ba37b8103132b4b73390323ab6b160891b604482015290519081900360640190fd5b6000620001bd8262ffffff19166200049a60201b620016031760201c565b9050620001c962000f91565b818152620001e962ffffff198416620004ec602090811b6200165117901c565b6040828101918252600089815260086020908152828220805460018082018355918452828420875160039283029091019081558388015192810192909255945160029091015592859055600485905560058590558481526007835220889055620002649088906107e0820690620016666200050c821b17901c565b6007600088815260200190815260200160002081905550620002978362ffffff19166200056560201b620016b61760201c565b600a55600160028181558882556000898155600c80546001600160a01b03808b166001600160a01b031992831617909255600d92909255600f8490556011849055601093909355601391909155620186a0600e5560148054878416921691909117908190551615620003a057601460009054906101000a90046001600160a01b03166001600160a01b03166373b295c26040518163ffffffff1660e01b815260040160206040518083038186803b1580156200035257600080fd5b505afa15801562000367573d6000803e3d6000fd5b505050506040513d60208110156200037e57600080fd5b5051601580546001600160a01b0319166001600160a01b039092169190911790555b5050600980546001600160a01b031916331790555062000fb1945050505050565b815160009060208401620003de64ffffffffff851682846200058b565b925050505b92915050565b600081816200040e815b8362ffffff1916620005e560201b620016d61790919060201c565b506200042b8462ffffff19166200073060201b620018141760201c565b6001600160601b03166050146200045957620004516200073f60201b620018231760201c565b92506200047d565b6200047a60108562ffffff19166200074760201b6200182b1790919060201c565b92505b5050919050565b6000620004918262000759565b1590505b919050565b600080620004a88362000765565b6001600160601b031690506000620004c08462000730565b6001600160601b03169050604051602081838560025afa5060208160208360025afa5051949350505050565b6000620003e362ffffff198316602460206200183d62000774821b17811c565b80820382811115620003e3576040805162461bcd60e51b815260206004820152601560248201527f64732d6d6174682d7375622d756e646572666c6f770000000000000000000000604482015290519081900360640190fd5b60008160106200057581620003f3565b506200047a6200058585620008bd565b62000960565b600080620005a883856200098160201b620019631790919060201c565b9050604051811115620005b9575060005b80620005cd5762ffffff19915050620005de565b620005da858585620009da565b9150505b9392505050565b6000620005f38383620009ed565b6200072957600062000616620006098562000a11565b64ffffffffff1662000a17565b9150600090506200062e64ffffffffff851662000a17565b604080517f5479706520617373657274696f6e206661696c65642e20476f742030780000006020808301919091526001600160b01b031960b088811b8216603d8501526c05c408af0e0cac6e8cac84060f609b1b604785015285901b1660548301528251603e818403018152605e83019384905262461bcd60e51b909352606282018181528351608284015283519496509294508493839260a2019185019080838360005b83811015620006ed578181015183820152602001620006d3565b50505050905090810190601f1680156200071b5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5090919050565b60181c6001600160601b031690565b62ffffff1990565b60d81b6001600160d81b039091161790565b62ffffff199081161490565b60781c6001600160601b031690565b600060ff82166200078857506000620005de565b620007938462000730565b6001600160601b0316620007b98360ff16856200098160201b620019631790919060201c565b11156200084057620007f7620007cf8562000765565b6001600160601b0316620007e38662000730565b6001600160601b03168560ff861662000ab9565b60405162461bcd60e51b8152602060048201818152835160248401528351909283926044909101919085019080838360008315620006ed578181015183820152602001620006d3565b60208260ff161115620008855760405162461bcd60e51b815260040180806020018281038252603a8152602001806200479e603a913960400191505060405180910390fd5b600882026000620008968662000765565b6001600160601b031690506000620008ae8362000bb9565b91909501511695945050505050565b6000816010620008cd81620003f3565b506000620008f4604860038762ffffff191662000bc860201b620019b2179092919060201c565b9050600062000936600362000922604b60018a62ffffff191662000be960201b620019c7179092919060201c565b6200050c60201b620016661790919060201c565b905062000956816101000a8362000c0d60201b620019e81790919060201c565b9695505050505050565b6000620003e38261ffff60d01b62000c7c60201b62001a4b1790919060201c565b80820182811015620003e3576040805162461bcd60e51b815260206004820152601460248201527f64732d6d6174682d6164642d6f766572666c6f77000000000000000000000000604482015290519081900360640190fd5b606092831b9190911790911b1760181b90565b600064ffffffffff821662000a028462000a11565b64ffffffffff16149392505050565b60d81c90565b600080601f5b600f8160ff16111562000a665760ff600882021684901c62000a3f8162000c90565b61ffff16841793508160ff1660101462000a5b57601084901b93505b506000190162000a1d565b50600f5b60ff8160ff16101562000ab35760ff600882021684901c62000a8c8162000c90565b61ffff16831792508160ff1660001462000aa857601083901b92505b506000190162000a6a565b50915091565b6060600062000ac88662000a17565b91506000905062000ad98662000a17565b91506000905062000aea8662000a17565b91506000905062000afb8662000a17565b915050838383836040516020018080620047d8603591396001600160d01b031960d087811b821660358401526e040eed2e8d040d8cadccee8d04060f608b1b603b84015286901b16604a82015260500160216200477d82396001600160d01b031960d094851b811660218301526e040eed2e8d040d8cadccee8d04060f608b1b60278301529290931b909116603683015250601760f91b603c82015260408051601d818403018152603d90920190529b9a5050505050505050505050565b600160ff1b6000199091011d90565b600062000be162000bdb85858562000774565b62000cc4565b949350505050565b600060ff60086020849003021662000c0385858562000774565b901c949350505050565b600081158062000c2a5750508082028282828162000c2757fe5b04145b620003e3576040805162461bcd60e51b815260206004820152601460248201527f64732d6d6174682d6d756c2d6f766572666c6f77000000000000000000000000604482015290519081900360640190fd5b600081838162000c8857fe5b049392505050565b600062000ca4600f600484901c1662000e05565b60ff161760081b62ffff001662000cbb8262000e05565b60ff1617919050565b600881811c7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff167fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff009290911b9190911617601081811c7dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff167fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff00009290911b9190911617602081811c7bffffffff00000000ffffffff00000000ffffffff00000000ffffffff167fffffffff00000000ffffffff00000000ffffffff00000000ffffffff000000009290911b9190911617604081811c77ffffffffffffffff0000000000000000ffffffffffffffff167fffffffffffffffff0000000000000000ffffffffffffffff00000000000000009290911b9190911617608081811c91901b1790565b600060f08083179060ff8216141562000e2357603091505062000495565b8060ff1660f1141562000e3b57603191505062000495565b8060ff1660f2141562000e5357603291505062000495565b8060ff1660f3141562000e6b57603391505062000495565b8060ff1660f4141562000e8357603491505062000495565b8060ff1660f5141562000e9b57603591505062000495565b8060ff1660f6141562000eb357603691505062000495565b8060ff1660f7141562000ecb57603791505062000495565b8060ff1660f8141562000ee357603891505062000495565b8060ff1660f9141562000efb57603991505062000495565b8060ff1660fa141562000f1357606191505062000495565b8060ff1660fb141562000f2b57606291505062000495565b8060ff1660fc141562000f4357606391505062000495565b8060ff1660fd141562000f5b57606491505062000495565b8060ff1660fe141562000f7357606591505062000495565b8060ff1660ff141562000f8b57606691505062000495565b50919050565b604080516060810182526000808252602082018190529181019190915290565b6137bc8062000fc16000396000f3fe6080604052600436106102305760003560e01c806374c3a3a91161012e578063a6f9dae1116100ab578063c32f5c9a1161006f578063c32f5c9a146109c4578063c58242cd14610b17578063e2761af014610b2c578063e3d8d8d814610b41578063fa041af514610b5657610230565b8063a6f9dae1146108ec578063b36161bd1461091f578063b985621a14610949578063b9bbd9bd1461097f578063c20dc664146109af57610230565b80638da5cb5b116100f25780638da5cb5b14610859578063926d44e21461086e5780639f15641414610898578063a072bc50146108ad578063a3db54eb146108c257610230565b806374c3a3a9146105fa5780637fa637fc146106cc578063826017b0146107e7578063838b7ccb146108115780638521fb1c1461084457610230565b806341744dd4116101bc5780636594168311610180578063659416831461041957806365da41b91461044357806370d53c181461052257806373b295c21461055057806373b63c821461056557610230565b806341744dd4146103865780634997f71b1461039b57806354eea796146103b057806357d775f8146103da57806360b5c390146103ef57610230565b80631cb85818116102035780631cb85818146102c95780631ea77144146102de5780632b97be241461032c5780632f796d901461034157806330017b3b1461035657610230565b8063108f438d14610232578063113764be146102635780631910d9731461028a57806319f4ff2f1461029f575b005b34801561023e57600080fd5b50610247610b6b565b604080516001600160a01b039092168252519081900360200190f35b34801561026f57600080fd5b50610278610b7a565b60408051918252519081900360200190f35b34801561029657600080fd5b50610278610b80565b3480156102ab57600080fd5b50610230600480360360208110156102c257600080fd5b5035610b86565b3480156102d557600080fd5b50610247610ba2565b3480156102ea57600080fd5b5061030e6004803603604081101561030157600080fd5b5080359060200135610bb1565b60408051938452602084019290925282820152519081900360600190f35b34801561033857600080fd5b50610278610bf3565b34801561034d57600080fd5b50610278610bf9565b34801561036257600080fd5b506102786004803603604081101561037957600080fd5b5080359060200135610bff565b34801561039257600080fd5b50610278610c14565b3480156103a757600080fd5b50610278610c1a565b3480156103bc57600080fd5b50610230600480360360208110156103d357600080fd5b5035610c20565b3480156103e657600080fd5b50610278610c3c565b3480156103fb57600080fd5b506102786004803603602081101561041257600080fd5b5035610c42565b34801561042557600080fd5b506102306004803603602081101561043c57600080fd5b5035610c55565b34801561044f57600080fd5b5061050e6004803603604081101561046657600080fd5b810190602081018135600160201b81111561048057600080fd5b82018360208201111561049257600080fd5b803590602001918460018302840111600160201b831117156104b357600080fd5b919390929091602081019035600160201b8111156104d057600080fd5b8201836020820111156104e257600080fd5b803590602001918460018302840111600160201b8311171561050357600080fd5b509092509050610c71565b604080519115158252519081900360200190f35b34801561052e57600080fd5b50610537610de1565b6040805163ffffffff9092168252519081900360200190f35b34801561055c57600080fd5b50610247610de6565b34801561057157600080fd5b5061050e600480360360c081101561058857600080fd5b813591602081013591810190606081016040820135600160201b8111156105ae57600080fd5b8201836020820111156105c057600080fd5b803590602001918460018302840111600160201b831117156105e157600080fd5b9193509150803590602081013515159060400135610df5565b34801561060657600080fd5b5061050e6004803603608081101561061d57600080fd5b81359190810190604081016020820135600160201b81111561063e57600080fd5b82018360208201111561065057600080fd5b803590602001918460018302840111600160201b8311171561067157600080fd5b919390929091602081019035600160201b81111561068e57600080fd5b8201836020820111156106a057600080fd5b803590602001918460018302840111600160201b831117156106c157600080fd5b919350915035610f40565b3480156106d857600080fd5b5061050e600480360360608110156106ef57600080fd5b810190602081018135600160201b81111561070957600080fd5b82018360208201111561071b57600080fd5b803590602001918460018302840111600160201b8311171561073c57600080fd5b919390929091602081019035600160201b81111561075957600080fd5b82018360208201111561076b57600080fd5b803590602001918460018302840111600160201b8311171561078c57600080fd5b919390929091602081019035600160201b8111156107a957600080fd5b8201836020820111156107bb57600080fd5b803590602001918460018302840111600160201b831117156107dc57600080fd5b509092509050611050565b3480156107f357600080fd5b506102306004803603602081101561080a57600080fd5b50356111c1565b34801561081d57600080fd5b506102306004803603602081101561083457600080fd5b50356001600160a01b03166111dd565b34801561085057600080fd5b50610278611216565b34801561086557600080fd5b5061024761121c565b34801561087a57600080fd5b506102786004803603602081101561089157600080fd5b503561122b565b3480156108a457600080fd5b5061027861123d565b3480156108b957600080fd5b50610278611243565b3480156108ce57600080fd5b50610230600480360360208110156108e557600080fd5b5035611249565b3480156108f857600080fd5b506102306004803603602081101561090f57600080fd5b50356001600160a01b0316611265565b34801561092b57600080fd5b506102306004803603602081101561094257600080fd5b503561129e565b34801561095557600080fd5b5061050e6004803603606081101561096c57600080fd5b50803590602081013590604001356112ba565b34801561098b57600080fd5b50610278600480360360408110156109a257600080fd5b50803590602001356112d1565b3480156109bb57600080fd5b50610278611307565b3480156109d057600080fd5b50610278600480360360808110156109e757600080fd5b6001600160e01b03198235169190810190604081016020820135600160201b811115610a1257600080fd5b820183602082011115610a2457600080fd5b803590602001918460018302840111600160201b83111715610a4557600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295949360208101935035915050600160201b811115610a9757600080fd5b820183602082011115610aa957600080fd5b803590602001918460018302840111600160201b83111715610aca57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550505090356001600160e01b031916915061130d9050565b348015610b2357600080fd5b50610278611553565b348015610b3857600080fd5b50610278611559565b348015610b4d57600080fd5b5061027861155f565b348015610b6257600080fd5b50610278611565565b600c546001600160a01b031681565b600a5490565b60045490565b6009546001600160a01b03163314610b9d57600080fd5b600d55565b6014546001600160a01b031681565b60086020528160005260406000208181548110610bcd57600080fd5b600091825260209091206003909102018054600182015460029092015490935090915083565b600b5490565b60015481565b6000610c0b8383611a5e565b90505b92915050565b600d5481565b60135481565b6009546001600160a01b03163314610c3757600080fd5b600f55565b600f5481565b6000610c4d82611ad4565b90505b919050565b6009546001600160a01b03163314610c6c57600080fd5b601155565b600080610cc6610cbb600086868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b62ffffff1916611b73565b90506000610d1c610d11600089898080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b62ffffff191661158f565b9050610d2d62ffffff1983166115f1565b610d685760405162461bcd60e51b815260040180806020018281038252602b815260200180613586602b913960400191505060405180910390fd5b610d7762ffffff1982166115f1565b610dc8576040805162461bcd60e51b815260206004820152601760248201527f416e63686f72206d757374206265203830206279746573000000000000000000604482015290519081900360640190fd5b610dd481836000611bc5565b925050505b949350505050565b600181565b6015546001600160a01b031681565b60006001546001018288011015610f315760005b600088815260086020526040902054811015610ee35760008881526008602052604081208054610e55919084908110610e3e57fe5b906000526020600020906003020160020154611e22565b90506000610eab610ea060008b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b62ffffff1916611ed8565b90506000610eb88c611e22565b9050610ec68184848b611f2a565b15610ed8576001945050505050610f35565b505050600101610e09565b506040805162461bcd60e51b815260206004820152601860248201527f747820686173206e6f74206265656e20696e636c756465640000000000000000604482015290519081900360640190fd5b5060005b979650505050505050565b600080610f8a610d11600087878080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b90506000610fd5610d1160008a8a8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b9050610fe662ffffff1983166115f1565b8015610ffc5750610ffc62ffffff1982166115f1565b6110375760405162461bcd60e51b815260040180806020018281038252602e815260200180613637602e913960400191505060405180910390fd5b61104389828487611f7b565b9998505050505050505050565b60008061109a610d1160008a8a8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b905060006110e5610d11600089898080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b90506000611130610cbb600088888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b905061114162ffffff1984166115f1565b8015611157575061115762ffffff1983166115f1565b801561116d575061116d62ffffff1982166115f1565b6111a85760405162461bcd60e51b815260040180806020018281038252602e815260200180613637602e913960400191505060405180910390fd5b6111b383838361218a565b9a9950505050505050505050565b6009546001600160a01b031633146111d857600080fd5b601355565b6009546001600160a01b031633146111f457600080fd5b601480546001600160a01b0319166001600160a01b0392909216919091179055565b60125481565b6009546001600160a01b031681565b60009081526008602052604090205490565b60105481565b60025481565b6009546001600160a01b0316331461126057600080fd5b600e55565b6009546001600160a01b0316331461127c57600080fd5b600980546001600160a01b0319166001600160a01b0392909216919091179055565b6009546001600160a01b031633146112b557600080fd5b600255565b60006112c78484846123b6565b90505b9392505050565b60008281526008602052604081208054610c0b9190849081106112f057fe5b906000526020600020906003020160000154611e22565b600e5481565b60008060028686868660405160200180856001600160e01b031916815260040184805190602001908083835b602083106113585780518252601f199092019160209182019101611339565b51815160209384036101000a600019018019909216911617905286519190930192860191508083835b602083106113a05780518252601f199092019160209182019101611381565b6001836020036101000a038019825116818451168082178552505050505050905001826001600160e01b03191681526004019450505050506040516020818303038152906040526040518082805190602001908083835b602083106114165780518252601f1990920191602091820191016113f7565b51815160209384036101000a60001901801990921691161790526040519190930194509192505080830381855afa158015611455573d6000803e3d6000fd5b5050506040513d602081101561146a57600080fd5b5051604080516020818101849052825180830382018152918301928390528151939450600093600293918291908401908083835b602083106114bd5780518252601f19909201916020918201910161149e565b51815160209384036101000a60001901801990921691161790526040519190930194509192505080830381855afa1580156114fc573d6000803e3d6000fd5b5050506040513d602081101561151157600080fd5b505160408051808201909152600a81526934b7383aba2430b9b41960b11b602082015290915061154090612405565b611549816124ae565b9695505050505050565b60055490565b60005481565b60035490565b60115481565b81516000906020840161158664ffffffffff851682846124ef565b95945050505050565b600081816115a5815b62ffffff198416906116d6565b506115b562ffffff198516611814565b6001600160601b03166050146115d4576115cd611823565b92506115ea565b6115e760105b62ffffff1986169061182b565b92505b5050919050565b60006115fc82612529565b1592915050565b60008061160f83612535565b6001600160601b03169050600061162584611814565b6001600160601b03169050604051602081838560025afa5060208160208360025afa5051949350505050565b6000610c4d62ffffff1983166024602061183d565b80820382811115610c0e576040805162461bcd60e51b815260206004820152601560248201527464732d6d6174682d7375622d756e646572666c6f7760581b604482015290519081900360640190fd5b60008160106116c481611598565b506115e76116d185612544565b612595565b60006116e283836125a6565b61180d5760006117006116f4856125c8565b64ffffffffff166125ce565b91505060006117158464ffffffffff166125ce565b604080517f5479706520617373657274696f6e206661696c65642e20476f742030780000006020808301919091526001600160b01b031960b088811b8216603d8501526c05c408af0e0cac6e8cac84060f609b1b604785015285901b1660548301528251603e818403018152605e83019384905262461bcd60e51b909352606282018181528351608284015283519496509294508493839260a2019185019080838360005b838110156117d25781810151838201526020016117ba565b50505050905090810190601f1680156117ff5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5090919050565b60181c6001600160601b031690565b62ffffff1990565b60d81b6001600160d81b039091161790565b600060ff821661184f575060006112ca565b61185884611814565b6001600160601b031661186e8460ff8516611963565b11156118ec576118a561188085612535565b6001600160601b031661189286611814565b6001600160601b0316858560ff16612666565b60405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156117d25781810151838201526020016117ba565b60208260ff16111561192f5760405162461bcd60e51b815260040180806020018281038252603a815260200180613698603a913960400191505060405180910390fd5b60088202600061193e86612535565b6001600160601b03169050600061195483612759565b91909501511695945050505050565b80820182811015610c0e576040805162461bcd60e51b815260206004820152601460248201527364732d6d6174682d6164642d6f766572666c6f7760601b604482015290519081900360640190fd5b60006112c76119c285858561183d565b612768565b60008160200360080260ff166119de85858561183d565b901c949350505050565b6000811580611a0357505080820282828281611a0057fe5b04145b610c0e576040805162461bcd60e51b815260206004820152601460248201527364732d6d6174682d6d756c2d6f766572666c6f7760601b604482015290519081900360640190fd5b6000818381611a5657fe5b049392505050565b600082815b83811015611a8e576000918252600660205260409091205490611a87816001611963565b9050611a63565b5080610c0b576040805162461bcd60e51b815260206004820152601060248201526f2ab735b737bbb71030b731b2b9ba37b960811b604482015290519081900360640190fd5b60008082815b6002811015611b3557600082815260076020526040902054925082611b0f576000918252600660205260409091205490611b23565b611b198382611963565b9350505050610c50565b611b2e816001611963565b9050611ada565b506040805162461bcd60e51b815260206004820152600d60248201526c556e6b6e6f776e20626c6f636b60981b604482015290519081900360640190fd5b60008181611b8081611598565b506050611b9262ffffff198616611814565b6001600160601b031681611ba257fe5b066001600160601b0316600014611bbb576115cd611823565b6115e760116115da565b600080611bd762ffffff198616611603565b90506000611be482611ad4565b90506000611c06611bfb62ffffff198816836128a2565b62ffffff1916612544565b905060008060005b6050611c1f62ffffff198b16611814565b6001600160601b031681611c2f57fe5b046001600160601b0316811015611d65576000611c5262ffffff198b16836128a2565b9050611c618660018401611963565b9350611c7262ffffff198216611603565b9250611c8462ffffff198216886128d4565b611cbf5760405162461bcd60e51b815260040180806020018281038252602681526020018061352d6026913960400191505060405180910390fd5b600083815260066020526040902054611d575784611cdc84612768565b1115611d2f576040805162461bcd60e51b815260206004820152601b60248201527f48656164657220776f726b20697320696e73756666696369656e740000000000604482015290519081900360640190fd5b60008381526006602090815260408083208a905560079091529020849055611d5781856128fd565b509094508490600101611c0e565b50600080611d8a33611d7c62ffffff198d16611814565b6001600160601b03166129f9565b90925090507f61281e68068a59c1359fe7670bb60800cecee1a08ee1d3a1d953553a348698ae6050611dc162ffffff198d16611814565b6001600160601b031681611dd157fe5b60408051929091046001600160601b0316870360010182526020820187905233828201526060820185905283151560808301525160a0918190039190910190a15060019a9950505050505050505050565b6000606081805b6020811015611ecc57828582601f0360208110611e4257fe5b1a60f81b6040516020018083805190602001908083835b60208310611e785780518252601f199092019160209182019101611e59565b6001836020036101000a038019825116818451168082178552505050505050905001826001600160f81b03191681526001019250505060405160208183030381529060405292508080600101915050611e29565b50506020015192915050565b60008181611ee581611598565b506020611ef762ffffff198616611814565b6001600160601b031681611f0757fe5b066001600160601b0316600014611f20576115cd611823565b6115e760146115da565b600083611f3686612bc0565b148015611f41575081155b8015611f625750611f5762ffffff198416611814565b6001600160601b0316155b15611f6f57506001610dd9565b61158685848685612c6a565b60006107e0821115611fbe5760405162461bcd60e51b81526004018080602001828103825260338152602001806135536033913960400191505060405180910390fd5b6000611fcf62ffffff198516611603565b90506000611fe262ffffff198716611603565b9050600454811461203a576040805162461bcd60e51b815260206004820181905260248201527f50617373656420696e2062657374206973206e6f742062657374206b6e6f776e604482015290519081900360640190fd5b600082815260066020526040902054612090576040805162461bcd60e51b81526020600482015260136024820152722732bb903132b9ba1034b9903ab735b737bbb760691b604482015290519081900360640190fd5b61209e876004548487612d22565b6120d95760405162461bcd60e51b815260040180806020018281038252602981526020018061375e6029913960400191505060405180910390fd5b816120e5888888612dcd565b146121215760405162461bcd60e51b81526004018080602001828103825260338152602001806136656033913960400191505060405180910390fd5b60048290556005879055600061213c62ffffff1987166116b6565b9050600a54811461214d57600a8190555b8783837f3cc13de64df0f0239626235c51a2da251bbc8c85664ecce39263da3ee03f606c60405160405180910390a4506001979650505050505050565b6000806121a461219f62ffffff198716611603565b611ad4565b905060006121ba61219f62ffffff198716611603565b90506107e081066107df146122005760405162461bcd60e51b815260040180806020018281038252603d8152602001806135fa603d913960400191505060405180910390fd5b61220c826107df611963565b81146122495760405162461bcd60e51b81526004018080602001828103825260288152602001806135b16028913960400191505060405180910390fd5b61225862ffffff1986166116b6565b61226762ffffff1988166116b6565b146122a35760405162461bcd60e51b81526004018080602001828103825260278152602001806137026027913960400191505060405180910390fd5b60006122b562ffffff198616826128a2565b905060006122c862ffffff198316612544565b9050600061230d6122de62ffffff198b16612544565b6122ed62ffffff198c16612f42565b63ffffffff1661230262ffffff198c16612f42565b63ffffffff16612f64565b90508181831614612365576040805162461bcd60e51b815260206004820152601960248201527f496e76616c69642072657461726765742070726f766964656400000000000000604482015290519081900360640190fd5b600061237662ffffff198b166116b6565b905080600b541415801561239f575061239c6107e0612396600454611ad4565b90611666565b85115b156123aa57600b8190555b6111b389896001611bc5565b600082815b838110156123f957858214156123d6576001925050506112ca565b60009182526006602052604090912054906123f2816001611963565b90506123bb565b50600095945050505050565b6124ab816040516024018080602001828103825283818151815260200191508051906020019080838360005b83811015612449578181015183820152602001612431565b50505050905090810190601f1680156124765780820380516001836020036101000a031916815260200191505b5060408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b1790529250612fee915050565b50565b6040805160248082018490528251808303909101815260449091019091526020810180516001600160e01b03166327b7cf8560e01b1790526124ab90612fee565b6000806124fc8484611963565b905060405181111561250c575060005b8061251e5762ffffff199150506112ca565b61158685858561300f565b62ffffff199081161490565b60781c6001600160601b031690565b600081601061255281611598565b50600061256862ffffff198616604860036119b2565b90506000612584600361239662ffffff198916604b60016119c7565b90506115498261010083900a6119e8565b6000610c4d61ffff60d01b83611a4b565b60008164ffffffffff166125b9846125c8565b64ffffffffff16149392505050565b60d81c90565b600080601f5b600f8160ff1611156126185760ff600882021684901c6125f381613022565b61ffff16841793508160ff1660101461260e57601084901b93505b50600019016125d4565b50600f5b60ff8160ff1610156126605760ff600882021684901c61263b81613022565b61ffff16831792508160ff1660001461265657601083901b92505b506000190161261c565b50915091565b60606000612673866125ce565b9150506000612681866125ce565b915050600061268f866125ce565b915050600061269d866125ce565b915050838383836040516020018080613729603591396001600160d01b031960d087811b821660358401526e040eed2e8d040d8cadccee8d04060f608b1b603b84015286901b16604a82015260500160216135d982396001600160d01b031960d094851b811660218301526e040eed2e8d040d8cadccee8d04060f608b1b60278301529290931b909116603683015250601760f91b603c82015260408051601d818403018152603d90920190529b9a5050505050505050505050565b600160ff1b6000199091011d90565b600881811c7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff167fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff009290911b9190911617601081811c7dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff167fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff00009290911b9190911617602081811c7bffffffff00000000ffffffff00000000ffffffff00000000ffffffff167fffffffff00000000ffffffff00000000ffffffff00000000ffffffff000000009290911b9190911617604081811c77ffffffffffffffff0000000000000000ffffffffffffffff1677ffffffffffffffff0000000000000000ffffffffffffffff199290911b9190911617608081811c91901b1790565b60008260116128b081611598565b5060006128be8560506119e8565b905061154962ffffff1987168260506010613052565b60008260106128e281611598565b50836128f362ffffff1987166130b7565b1495945050505050565b6001546002546002028201101561295b576040805162461bcd60e51b815260206004820152601760248201527f626c6f636b2068656164657220697320746f6f206f6c64000000000000000000604482015290519081900360640190fd5b61296361350c565b61297262ffffff198416611603565b815261298362ffffff1984166130b7565b602082015261299762ffffff198416611651565b604080830191825260008481526008602090815291812080546001818101835591835291839020855160039093020191825591840151818301559151600290920191909155548211156129f45760018054810190556129f46130d9565b505050565b60008060006064600d543a600e548702020281612a1257fe5b0490506000612a20826131d9565b600c549091506000906001600160a01b031615612ab557600c54604080516370a0823160e01b815230600482015290516001600160a01b03909216916370a0823191602480820192602092909190829003018186803b158015612a8257600080fd5b505afa158015612a96573d6000803e3d6000fd5b505050506040513d6020811015612aac57600080fd5b50519050612ab9565b5060005b47818311801590612aca5750600083115b15612b6157600c546040805163a9059cbb60e01b81526001600160a01b038b81166004830152602482018790529151919092169163a9059cbb9160448083019260209291908290030181600087803b158015612b2557600080fd5b505af1158015612b39573d6000803e3d6000fd5b505050506040513d6020811015612b4f57600080fd5b5092955060019450612bb99350505050565b808411158015612b715750600084115b15612bb457604051339085156108fc029086906000818181858888f19350505050158015612ba3573d6000803e3d6000fd5b508360009550955050505050612bb9565b505050505b9250929050565b6000606081805b6020811015611ecc57828582601f0360208110612be057fe5b1a60f81b6040516020018083805190602001908083835b60208310612c165780518252601f199092019160209182019101612bf7565b6001836020036101000a038019825116818451168082178552505050505050905001826001600160f81b03191681526001019250505060405160208183030381529060405292508080600101915050612bc7565b6000806020612c7e62ffffff198716611814565b6001600160601b031681612c8e57fe5b046001600160601b031690508060001415612cad575050838214610dd9565b828660005b83811015612d0a576000612cd162ffffff198a1660208085029061183d565b90506002840660011415612cf057612ce981846131df565b9250612cfd565b612cfa83826131df565b92505b50600192831c9201612cb2565b5085612d158261320b565b1498975050505050505050565b60008385148015612d3257508285145b15612d3f57506001610dd9565b8383818160005b86811015612d9457898314612d68576000838152600660205260409020549294505b898214612d82576000828152600660205260409020549193505b612d8d816001611963565b9050612d46565b5082841415612daa576000945050505050610dd9565b808214612dbe576000945050505050610dd9565b50600198975050505050505050565b600080612dd985611ad4565b90506000612def61219f62ffffff198716611603565b90506000612e0561219f62ffffff198716611603565b9050828210158015612e175750828110155b612e525760405162461bcd60e51b81526004018080602001828103825260308152602001806136d26030913960400191505060405180910390fd5b6000612e686107e08506612396866107e0611963565b9050808310818310811582612e7a5750805b15612e9b57612e8e62ffffff198a16611603565b96505050505050506112ca565b818015612ea6575080155b15612eba57612e8e62ffffff198916611603565b818015612ec45750805b15612ef45783851015612ee557612ee062ffffff198916611603565b612e8e565b612e8e62ffffff198a16611603565b612f12612f0662ffffff198a166116b6565b6107e0865b06906119e8565b612f2d612f2462ffffff198c166116b6565b6107e088612f0b565b1015612ee557612e8e62ffffff198916611603565b6000816010612f5081611598565b506115e762ffffff198516604460046119b2565b600080612f718385611666565b9050612f81621275006004611a4b565b811015612f9957612f96621275006004611a4b565b90505b612fa76212750060046119e8565b811115612fbf57612fbc6212750060046119e8565b90505b6000612fd882612fd28862010000611a4b565b906119e8565b905061154962010000612fd28362127500611a4b565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b606092831b9190911790911b1760181b90565b600061303460048360ff16901c6132b5565b60ff161760081b62ffff0016613049826132b5565b60ff1617919050565b60008061305e86612535565b6001600160601b0316905061307286613421565b613086856130808489611963565b90611963565b11156130995762ffffff19915050610dd9565b6130a38186611963565b90506115498364ffffffffff1682866124ef565b60008160106130c581611598565b506115e762ffffff1985166004602061183d565b60025460005460015403106131d75760025460015460005b821561314757600082815260086020526040812080548390811061311157fe5b90600052602060002090600302016001015490506131328160018503613446565b60001994850194939093019291506130f19050565b600082815260086020526040902080548290811061316157fe5b90600052602060002090600302016008600084815260200190815260200160002060008154811061318e57fe5b6000918252602080832084546003909302019182556001808501548184015560029485015494909201939093558482526008909252604090205411156129f4576129f4826134ac565b565b50600090565b600060405183815282602082015260208160408360025afa5060208160208360025afa50519392505050565b6000606081805b6020811015611ecc57828582601f036020811061322b57fe5b1a60f81b6040516020018083805190602001908083835b602083106132615780518252601f199092019160209182019101613242565b6001836020036101000a038019825116818451168082178552505050505050905001826001600160f81b03191681526001019250505060405160208183030381529060405292508080600101915050613212565b600060f08083179060ff821614156132d1576030915050610c50565b8060ff1660f114156132e7576031915050610c50565b8060ff1660f214156132fd576032915050610c50565b8060ff1660f31415613313576033915050610c50565b8060ff1660f41415613329576034915050610c50565b8060ff1660f5141561333f576035915050610c50565b8060ff1660f61415613355576036915050610c50565b8060ff1660f7141561336b576037915050610c50565b8060ff1660f81415613381576038915050610c50565b8060ff1660f91415613397576039915050610c50565b8060ff1660fa14156133ad576061915050610c50565b8060ff1660fb14156133c3576062915050610c50565b8060ff1660fc14156133d9576063915050610c50565b8060ff1660fd14156133ef576064915050610c50565b8060ff1660fe1415613405576065915050610c50565b8060ff1660ff141561341b576066915050610c50565b50919050565b600061342c82611814565b61343583612535565b016001600160601b03169050919050565b6000805b6000838152600860205260409020548110156134a257600083815260086020526040902080548290811061347a57fe5b90600052602060002090600302016000015484141561349a579050610c0e565b60010161344a565b5060009392505050565b60015b6000828152600860205260409020548110156135085760008281526008602052604090208054829081106134df57fe5b6000918252602082206003909102018181556001808201839055600290910191909155016134af565b5050565b60408051606081018252600080825260208201819052918101919091529056fe4865616465727320646f206e6f7420666f726d206120636f6e73697374656e7420636861696e526571756573746564206c696d69742069732067726561746572207468616e203120646966666963756c747920706572696f64486561646572206172726179206c656e677468206d75737420626520646976697369626c652062792038304d7573742070726f766964652065786163746c79203120646966666963756c747920706572696f642e20417474656d7074656420746f20696e646578206174206f66667365742030784d7573742070726f7669646520746865206c61737420686561646572206f662074686520636c6f73696e6720646966666963756c747920706572696f6442616420617267732e20436865636b2068656164657220616e642061727261792062797465206c656e677468732e4e65772062657374206861736820646f6573206e6f742068617665206d6f726520776f726b207468616e2070726576696f757354797065644d656d566965772f696e646578202d20417474656d7074656420746f20696e646578206d6f7265207468616e203332206279746573412064657363656e64616e74206865696768742069732062656c6f772074686520616e636573746f7220686569676874506572696f642068656164657220646966666963756c7469657320646f206e6f74206d6174636854797065644d656d566965772f696e646578202d204f76657272616e2074686520766965772e20536c696365206973206174203078416e636573746f72206d75737420626520686561766965737420636f6d6d6f6e20616e636573746f72a26469706673582212207662b5040fdbda095a70ad8d748f4c1c10d2072f91be5f32376a249e2ad3863e64736f6c634300070600332e20417474656d7074656420746f20696e646578206174206f666673657420307854797065644d656d566965772f696e646578202d20417474656d7074656420746f20696e646578206d6f7265207468616e20333220627974657354797065644d656d566965772f696e646578202d204f76657272616e2074686520766965772e20536c696365206973206174203078",
  "deployedBytecode": "0x6080604052600436106102305760003560e01c806374c3a3a91161012e578063a6f9dae1116100ab578063c32f5c9a1161006f578063c32f5c9a146109c4578063c58242cd14610b17578063e2761af014610b2c578063e3d8d8d814610b41578063fa041af514610b5657610230565b8063a6f9dae1146108ec578063b36161bd1461091f578063b985621a14610949578063b9bbd9bd1461097f578063c20dc664146109af57610230565b80638da5cb5b116100f25780638da5cb5b14610859578063926d44e21461086e5780639f15641414610898578063a072bc50146108ad578063a3db54eb146108c257610230565b806374c3a3a9146105fa5780637fa637fc146106cc578063826017b0146107e7578063838b7ccb146108115780638521fb1c1461084457610230565b806341744dd4116101bc5780636594168311610180578063659416831461041957806365da41b91461044357806370d53c181461052257806373b295c21461055057806373b63c821461056557610230565b806341744dd4146103865780634997f71b1461039b57806354eea796146103b057806357d775f8146103da57806360b5c390146103ef57610230565b80631cb85818116102035780631cb85818146102c95780631ea77144146102de5780632b97be241461032c5780632f796d901461034157806330017b3b1461035657610230565b8063108f438d14610232578063113764be146102635780631910d9731461028a57806319f4ff2f1461029f575b005b34801561023e57600080fd5b50610247610b6b565b604080516001600160a01b039092168252519081900360200190f35b34801561026f57600080fd5b50610278610b7a565b60408051918252519081900360200190f35b34801561029657600080fd5b50610278610b80565b3480156102ab57600080fd5b50610230600480360360208110156102c257600080fd5b5035610b86565b3480156102d557600080fd5b50610247610ba2565b3480156102ea57600080fd5b5061030e6004803603604081101561030157600080fd5b5080359060200135610bb1565b60408051938452602084019290925282820152519081900360600190f35b34801561033857600080fd5b50610278610bf3565b34801561034d57600080fd5b50610278610bf9565b34801561036257600080fd5b506102786004803603604081101561037957600080fd5b5080359060200135610bff565b34801561039257600080fd5b50610278610c14565b3480156103a757600080fd5b50610278610c1a565b3480156103bc57600080fd5b50610230600480360360208110156103d357600080fd5b5035610c20565b3480156103e657600080fd5b50610278610c3c565b3480156103fb57600080fd5b506102786004803603602081101561041257600080fd5b5035610c42565b34801561042557600080fd5b506102306004803603602081101561043c57600080fd5b5035610c55565b34801561044f57600080fd5b5061050e6004803603604081101561046657600080fd5b810190602081018135600160201b81111561048057600080fd5b82018360208201111561049257600080fd5b803590602001918460018302840111600160201b831117156104b357600080fd5b919390929091602081019035600160201b8111156104d057600080fd5b8201836020820111156104e257600080fd5b803590602001918460018302840111600160201b8311171561050357600080fd5b509092509050610c71565b604080519115158252519081900360200190f35b34801561052e57600080fd5b50610537610de1565b6040805163ffffffff9092168252519081900360200190f35b34801561055c57600080fd5b50610247610de6565b34801561057157600080fd5b5061050e600480360360c081101561058857600080fd5b813591602081013591810190606081016040820135600160201b8111156105ae57600080fd5b8201836020820111156105c057600080fd5b803590602001918460018302840111600160201b831117156105e157600080fd5b9193509150803590602081013515159060400135610df5565b34801561060657600080fd5b5061050e6004803603608081101561061d57600080fd5b81359190810190604081016020820135600160201b81111561063e57600080fd5b82018360208201111561065057600080fd5b803590602001918460018302840111600160201b8311171561067157600080fd5b919390929091602081019035600160201b81111561068e57600080fd5b8201836020820111156106a057600080fd5b803590602001918460018302840111600160201b831117156106c157600080fd5b919350915035610f40565b3480156106d857600080fd5b5061050e600480360360608110156106ef57600080fd5b810190602081018135600160201b81111561070957600080fd5b82018360208201111561071b57600080fd5b803590602001918460018302840111600160201b8311171561073c57600080fd5b919390929091602081019035600160201b81111561075957600080fd5b82018360208201111561076b57600080fd5b803590602001918460018302840111600160201b8311171561078c57600080fd5b919390929091602081019035600160201b8111156107a957600080fd5b8201836020820111156107bb57600080fd5b803590602001918460018302840111600160201b831117156107dc57600080fd5b509092509050611050565b3480156107f357600080fd5b506102306004803603602081101561080a57600080fd5b50356111c1565b34801561081d57600080fd5b506102306004803603602081101561083457600080fd5b50356001600160a01b03166111dd565b34801561085057600080fd5b50610278611216565b34801561086557600080fd5b5061024761121c565b34801561087a57600080fd5b506102786004803603602081101561089157600080fd5b503561122b565b3480156108a457600080fd5b5061027861123d565b3480156108b957600080fd5b50610278611243565b3480156108ce57600080fd5b50610230600480360360208110156108e557600080fd5b5035611249565b3480156108f857600080fd5b506102306004803603602081101561090f57600080fd5b50356001600160a01b0316611265565b34801561092b57600080fd5b506102306004803603602081101561094257600080fd5b503561129e565b34801561095557600080fd5b5061050e6004803603606081101561096c57600080fd5b50803590602081013590604001356112ba565b34801561098b57600080fd5b50610278600480360360408110156109a257600080fd5b50803590602001356112d1565b3480156109bb57600080fd5b50610278611307565b3480156109d057600080fd5b50610278600480360360808110156109e757600080fd5b6001600160e01b03198235169190810190604081016020820135600160201b811115610a1257600080fd5b820183602082011115610a2457600080fd5b803590602001918460018302840111600160201b83111715610a4557600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295949360208101935035915050600160201b811115610a9757600080fd5b820183602082011115610aa957600080fd5b803590602001918460018302840111600160201b83111715610aca57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550505090356001600160e01b031916915061130d9050565b348015610b2357600080fd5b50610278611553565b348015610b3857600080fd5b50610278611559565b348015610b4d57600080fd5b5061027861155f565b348015610b6257600080fd5b50610278611565565b600c546001600160a01b031681565b600a5490565b60045490565b6009546001600160a01b03163314610b9d57600080fd5b600d55565b6014546001600160a01b031681565b60086020528160005260406000208181548110610bcd57600080fd5b600091825260209091206003909102018054600182015460029092015490935090915083565b600b5490565b60015481565b6000610c0b8383611a5e565b90505b92915050565b600d5481565b60135481565b6009546001600160a01b03163314610c3757600080fd5b600f55565b600f5481565b6000610c4d82611ad4565b90505b919050565b6009546001600160a01b03163314610c6c57600080fd5b601155565b600080610cc6610cbb600086868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b62ffffff1916611b73565b90506000610d1c610d11600089898080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b62ffffff191661158f565b9050610d2d62ffffff1983166115f1565b610d685760405162461bcd60e51b815260040180806020018281038252602b815260200180613586602b913960400191505060405180910390fd5b610d7762ffffff1982166115f1565b610dc8576040805162461bcd60e51b815260206004820152601760248201527f416e63686f72206d757374206265203830206279746573000000000000000000604482015290519081900360640190fd5b610dd481836000611bc5565b925050505b949350505050565b600181565b6015546001600160a01b031681565b60006001546001018288011015610f315760005b600088815260086020526040902054811015610ee35760008881526008602052604081208054610e55919084908110610e3e57fe5b906000526020600020906003020160020154611e22565b90506000610eab610ea060008b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b62ffffff1916611ed8565b90506000610eb88c611e22565b9050610ec68184848b611f2a565b15610ed8576001945050505050610f35565b505050600101610e09565b506040805162461bcd60e51b815260206004820152601860248201527f747820686173206e6f74206265656e20696e636c756465640000000000000000604482015290519081900360640190fd5b5060005b979650505050505050565b600080610f8a610d11600087878080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b90506000610fd5610d1160008a8a8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b9050610fe662ffffff1983166115f1565b8015610ffc5750610ffc62ffffff1982166115f1565b6110375760405162461bcd60e51b815260040180806020018281038252602e815260200180613637602e913960400191505060405180910390fd5b61104389828487611f7b565b9998505050505050505050565b60008061109a610d1160008a8a8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b905060006110e5610d11600089898080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b90506000611130610cbb600088888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929392505061156b9050565b905061114162ffffff1984166115f1565b8015611157575061115762ffffff1983166115f1565b801561116d575061116d62ffffff1982166115f1565b6111a85760405162461bcd60e51b815260040180806020018281038252602e815260200180613637602e913960400191505060405180910390fd5b6111b383838361218a565b9a9950505050505050505050565b6009546001600160a01b031633146111d857600080fd5b601355565b6009546001600160a01b031633146111f457600080fd5b601480546001600160a01b0319166001600160a01b0392909216919091179055565b60125481565b6009546001600160a01b031681565b60009081526008602052604090205490565b60105481565b60025481565b6009546001600160a01b0316331461126057600080fd5b600e55565b6009546001600160a01b0316331461127c57600080fd5b600980546001600160a01b0319166001600160a01b0392909216919091179055565b6009546001600160a01b031633146112b557600080fd5b600255565b60006112c78484846123b6565b90505b9392505050565b60008281526008602052604081208054610c0b9190849081106112f057fe5b906000526020600020906003020160000154611e22565b600e5481565b60008060028686868660405160200180856001600160e01b031916815260040184805190602001908083835b602083106113585780518252601f199092019160209182019101611339565b51815160209384036101000a600019018019909216911617905286519190930192860191508083835b602083106113a05780518252601f199092019160209182019101611381565b6001836020036101000a038019825116818451168082178552505050505050905001826001600160e01b03191681526004019450505050506040516020818303038152906040526040518082805190602001908083835b602083106114165780518252601f1990920191602091820191016113f7565b51815160209384036101000a60001901801990921691161790526040519190930194509192505080830381855afa158015611455573d6000803e3d6000fd5b5050506040513d602081101561146a57600080fd5b5051604080516020818101849052825180830382018152918301928390528151939450600093600293918291908401908083835b602083106114bd5780518252601f19909201916020918201910161149e565b51815160209384036101000a60001901801990921691161790526040519190930194509192505080830381855afa1580156114fc573d6000803e3d6000fd5b5050506040513d602081101561151157600080fd5b505160408051808201909152600a81526934b7383aba2430b9b41960b11b602082015290915061154090612405565b611549816124ae565b9695505050505050565b60055490565b60005481565b60035490565b60115481565b81516000906020840161158664ffffffffff851682846124ef565b95945050505050565b600081816115a5815b62ffffff198416906116d6565b506115b562ffffff198516611814565b6001600160601b03166050146115d4576115cd611823565b92506115ea565b6115e760105b62ffffff1986169061182b565b92505b5050919050565b60006115fc82612529565b1592915050565b60008061160f83612535565b6001600160601b03169050600061162584611814565b6001600160601b03169050604051602081838560025afa5060208160208360025afa5051949350505050565b6000610c4d62ffffff1983166024602061183d565b80820382811115610c0e576040805162461bcd60e51b815260206004820152601560248201527464732d6d6174682d7375622d756e646572666c6f7760581b604482015290519081900360640190fd5b60008160106116c481611598565b506115e76116d185612544565b612595565b60006116e283836125a6565b61180d5760006117006116f4856125c8565b64ffffffffff166125ce565b91505060006117158464ffffffffff166125ce565b604080517f5479706520617373657274696f6e206661696c65642e20476f742030780000006020808301919091526001600160b01b031960b088811b8216603d8501526c05c408af0e0cac6e8cac84060f609b1b604785015285901b1660548301528251603e818403018152605e83019384905262461bcd60e51b909352606282018181528351608284015283519496509294508493839260a2019185019080838360005b838110156117d25781810151838201526020016117ba565b50505050905090810190601f1680156117ff5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5090919050565b60181c6001600160601b031690565b62ffffff1990565b60d81b6001600160d81b039091161790565b600060ff821661184f575060006112ca565b61185884611814565b6001600160601b031661186e8460ff8516611963565b11156118ec576118a561188085612535565b6001600160601b031661189286611814565b6001600160601b0316858560ff16612666565b60405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156117d25781810151838201526020016117ba565b60208260ff16111561192f5760405162461bcd60e51b815260040180806020018281038252603a815260200180613698603a913960400191505060405180910390fd5b60088202600061193e86612535565b6001600160601b03169050600061195483612759565b91909501511695945050505050565b80820182811015610c0e576040805162461bcd60e51b815260206004820152601460248201527364732d6d6174682d6164642d6f766572666c6f7760601b604482015290519081900360640190fd5b60006112c76119c285858561183d565b612768565b60008160200360080260ff166119de85858561183d565b901c949350505050565b6000811580611a0357505080820282828281611a0057fe5b04145b610c0e576040805162461bcd60e51b815260206004820152601460248201527364732d6d6174682d6d756c2d6f766572666c6f7760601b604482015290519081900360640190fd5b6000818381611a5657fe5b049392505050565b600082815b83811015611a8e576000918252600660205260409091205490611a87816001611963565b9050611a63565b5080610c0b576040805162461bcd60e51b815260206004820152601060248201526f2ab735b737bbb71030b731b2b9ba37b960811b604482015290519081900360640190fd5b60008082815b6002811015611b3557600082815260076020526040902054925082611b0f576000918252600660205260409091205490611b23565b611b198382611963565b9350505050610c50565b611b2e816001611963565b9050611ada565b506040805162461bcd60e51b815260206004820152600d60248201526c556e6b6e6f776e20626c6f636b60981b604482015290519081900360640190fd5b60008181611b8081611598565b506050611b9262ffffff198616611814565b6001600160601b031681611ba257fe5b066001600160601b0316600014611bbb576115cd611823565b6115e760116115da565b600080611bd762ffffff198616611603565b90506000611be482611ad4565b90506000611c06611bfb62ffffff198816836128a2565b62ffffff1916612544565b905060008060005b6050611c1f62ffffff198b16611814565b6001600160601b031681611c2f57fe5b046001600160601b0316811015611d65576000611c5262ffffff198b16836128a2565b9050611c618660018401611963565b9350611c7262ffffff198216611603565b9250611c8462ffffff198216886128d4565b611cbf5760405162461bcd60e51b815260040180806020018281038252602681526020018061352d6026913960400191505060405180910390fd5b600083815260066020526040902054611d575784611cdc84612768565b1115611d2f576040805162461bcd60e51b815260206004820152601b60248201527f48656164657220776f726b20697320696e73756666696369656e740000000000604482015290519081900360640190fd5b60008381526006602090815260408083208a905560079091529020849055611d5781856128fd565b509094508490600101611c0e565b50600080611d8a33611d7c62ffffff198d16611814565b6001600160601b03166129f9565b90925090507f61281e68068a59c1359fe7670bb60800cecee1a08ee1d3a1d953553a348698ae6050611dc162ffffff198d16611814565b6001600160601b031681611dd157fe5b60408051929091046001600160601b0316870360010182526020820187905233828201526060820185905283151560808301525160a0918190039190910190a15060019a9950505050505050505050565b6000606081805b6020811015611ecc57828582601f0360208110611e4257fe5b1a60f81b6040516020018083805190602001908083835b60208310611e785780518252601f199092019160209182019101611e59565b6001836020036101000a038019825116818451168082178552505050505050905001826001600160f81b03191681526001019250505060405160208183030381529060405292508080600101915050611e29565b50506020015192915050565b60008181611ee581611598565b506020611ef762ffffff198616611814565b6001600160601b031681611f0757fe5b066001600160601b0316600014611f20576115cd611823565b6115e760146115da565b600083611f3686612bc0565b148015611f41575081155b8015611f625750611f5762ffffff198416611814565b6001600160601b0316155b15611f6f57506001610dd9565b61158685848685612c6a565b60006107e0821115611fbe5760405162461bcd60e51b81526004018080602001828103825260338152602001806135536033913960400191505060405180910390fd5b6000611fcf62ffffff198516611603565b90506000611fe262ffffff198716611603565b9050600454811461203a576040805162461bcd60e51b815260206004820181905260248201527f50617373656420696e2062657374206973206e6f742062657374206b6e6f776e604482015290519081900360640190fd5b600082815260066020526040902054612090576040805162461bcd60e51b81526020600482015260136024820152722732bb903132b9ba1034b9903ab735b737bbb760691b604482015290519081900360640190fd5b61209e876004548487612d22565b6120d95760405162461bcd60e51b815260040180806020018281038252602981526020018061375e6029913960400191505060405180910390fd5b816120e5888888612dcd565b146121215760405162461bcd60e51b81526004018080602001828103825260338152602001806136656033913960400191505060405180910390fd5b60048290556005879055600061213c62ffffff1987166116b6565b9050600a54811461214d57600a8190555b8783837f3cc13de64df0f0239626235c51a2da251bbc8c85664ecce39263da3ee03f606c60405160405180910390a4506001979650505050505050565b6000806121a461219f62ffffff198716611603565b611ad4565b905060006121ba61219f62ffffff198716611603565b90506107e081066107df146122005760405162461bcd60e51b815260040180806020018281038252603d8152602001806135fa603d913960400191505060405180910390fd5b61220c826107df611963565b81146122495760405162461bcd60e51b81526004018080602001828103825260288152602001806135b16028913960400191505060405180910390fd5b61225862ffffff1986166116b6565b61226762ffffff1988166116b6565b146122a35760405162461bcd60e51b81526004018080602001828103825260278152602001806137026027913960400191505060405180910390fd5b60006122b562ffffff198616826128a2565b905060006122c862ffffff198316612544565b9050600061230d6122de62ffffff198b16612544565b6122ed62ffffff198c16612f42565b63ffffffff1661230262ffffff198c16612f42565b63ffffffff16612f64565b90508181831614612365576040805162461bcd60e51b815260206004820152601960248201527f496e76616c69642072657461726765742070726f766964656400000000000000604482015290519081900360640190fd5b600061237662ffffff198b166116b6565b905080600b541415801561239f575061239c6107e0612396600454611ad4565b90611666565b85115b156123aa57600b8190555b6111b389896001611bc5565b600082815b838110156123f957858214156123d6576001925050506112ca565b60009182526006602052604090912054906123f2816001611963565b90506123bb565b50600095945050505050565b6124ab816040516024018080602001828103825283818151815260200191508051906020019080838360005b83811015612449578181015183820152602001612431565b50505050905090810190601f1680156124765780820380516001836020036101000a031916815260200191505b5060408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b1790529250612fee915050565b50565b6040805160248082018490528251808303909101815260449091019091526020810180516001600160e01b03166327b7cf8560e01b1790526124ab90612fee565b6000806124fc8484611963565b905060405181111561250c575060005b8061251e5762ffffff199150506112ca565b61158685858561300f565b62ffffff199081161490565b60781c6001600160601b031690565b600081601061255281611598565b50600061256862ffffff198616604860036119b2565b90506000612584600361239662ffffff198916604b60016119c7565b90506115498261010083900a6119e8565b6000610c4d61ffff60d01b83611a4b565b60008164ffffffffff166125b9846125c8565b64ffffffffff16149392505050565b60d81c90565b600080601f5b600f8160ff1611156126185760ff600882021684901c6125f381613022565b61ffff16841793508160ff1660101461260e57601084901b93505b50600019016125d4565b50600f5b60ff8160ff1610156126605760ff600882021684901c61263b81613022565b61ffff16831792508160ff1660001461265657601083901b92505b506000190161261c565b50915091565b60606000612673866125ce565b9150506000612681866125ce565b915050600061268f866125ce565b915050600061269d866125ce565b915050838383836040516020018080613729603591396001600160d01b031960d087811b821660358401526e040eed2e8d040d8cadccee8d04060f608b1b603b84015286901b16604a82015260500160216135d982396001600160d01b031960d094851b811660218301526e040eed2e8d040d8cadccee8d04060f608b1b60278301529290931b909116603683015250601760f91b603c82015260408051601d818403018152603d90920190529b9a5050505050505050505050565b600160ff1b6000199091011d90565b600881811c7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff167fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff009290911b9190911617601081811c7dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff167fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff00009290911b9190911617602081811c7bffffffff00000000ffffffff00000000ffffffff00000000ffffffff167fffffffff00000000ffffffff00000000ffffffff00000000ffffffff000000009290911b9190911617604081811c77ffffffffffffffff0000000000000000ffffffffffffffff1677ffffffffffffffff0000000000000000ffffffffffffffff199290911b9190911617608081811c91901b1790565b60008260116128b081611598565b5060006128be8560506119e8565b905061154962ffffff1987168260506010613052565b60008260106128e281611598565b50836128f362ffffff1987166130b7565b1495945050505050565b6001546002546002028201101561295b576040805162461bcd60e51b815260206004820152601760248201527f626c6f636b2068656164657220697320746f6f206f6c64000000000000000000604482015290519081900360640190fd5b61296361350c565b61297262ffffff198416611603565b815261298362ffffff1984166130b7565b602082015261299762ffffff198416611651565b604080830191825260008481526008602090815291812080546001818101835591835291839020855160039093020191825591840151818301559151600290920191909155548211156129f45760018054810190556129f46130d9565b505050565b60008060006064600d543a600e548702020281612a1257fe5b0490506000612a20826131d9565b600c549091506000906001600160a01b031615612ab557600c54604080516370a0823160e01b815230600482015290516001600160a01b03909216916370a0823191602480820192602092909190829003018186803b158015612a8257600080fd5b505afa158015612a96573d6000803e3d6000fd5b505050506040513d6020811015612aac57600080fd5b50519050612ab9565b5060005b47818311801590612aca5750600083115b15612b6157600c546040805163a9059cbb60e01b81526001600160a01b038b81166004830152602482018790529151919092169163a9059cbb9160448083019260209291908290030181600087803b158015612b2557600080fd5b505af1158015612b39573d6000803e3d6000fd5b505050506040513d6020811015612b4f57600080fd5b5092955060019450612bb99350505050565b808411158015612b715750600084115b15612bb457604051339085156108fc029086906000818181858888f19350505050158015612ba3573d6000803e3d6000fd5b508360009550955050505050612bb9565b505050505b9250929050565b6000606081805b6020811015611ecc57828582601f0360208110612be057fe5b1a60f81b6040516020018083805190602001908083835b60208310612c165780518252601f199092019160209182019101612bf7565b6001836020036101000a038019825116818451168082178552505050505050905001826001600160f81b03191681526001019250505060405160208183030381529060405292508080600101915050612bc7565b6000806020612c7e62ffffff198716611814565b6001600160601b031681612c8e57fe5b046001600160601b031690508060001415612cad575050838214610dd9565b828660005b83811015612d0a576000612cd162ffffff198a1660208085029061183d565b90506002840660011415612cf057612ce981846131df565b9250612cfd565b612cfa83826131df565b92505b50600192831c9201612cb2565b5085612d158261320b565b1498975050505050505050565b60008385148015612d3257508285145b15612d3f57506001610dd9565b8383818160005b86811015612d9457898314612d68576000838152600660205260409020549294505b898214612d82576000828152600660205260409020549193505b612d8d816001611963565b9050612d46565b5082841415612daa576000945050505050610dd9565b808214612dbe576000945050505050610dd9565b50600198975050505050505050565b600080612dd985611ad4565b90506000612def61219f62ffffff198716611603565b90506000612e0561219f62ffffff198716611603565b9050828210158015612e175750828110155b612e525760405162461bcd60e51b81526004018080602001828103825260308152602001806136d26030913960400191505060405180910390fd5b6000612e686107e08506612396866107e0611963565b9050808310818310811582612e7a5750805b15612e9b57612e8e62ffffff198a16611603565b96505050505050506112ca565b818015612ea6575080155b15612eba57612e8e62ffffff198916611603565b818015612ec45750805b15612ef45783851015612ee557612ee062ffffff198916611603565b612e8e565b612e8e62ffffff198a16611603565b612f12612f0662ffffff198a166116b6565b6107e0865b06906119e8565b612f2d612f2462ffffff198c166116b6565b6107e088612f0b565b1015612ee557612e8e62ffffff198916611603565b6000816010612f5081611598565b506115e762ffffff198516604460046119b2565b600080612f718385611666565b9050612f81621275006004611a4b565b811015612f9957612f96621275006004611a4b565b90505b612fa76212750060046119e8565b811115612fbf57612fbc6212750060046119e8565b90505b6000612fd882612fd28862010000611a4b565b906119e8565b905061154962010000612fd28362127500611a4b565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b606092831b9190911790911b1760181b90565b600061303460048360ff16901c6132b5565b60ff161760081b62ffff0016613049826132b5565b60ff1617919050565b60008061305e86612535565b6001600160601b0316905061307286613421565b613086856130808489611963565b90611963565b11156130995762ffffff19915050610dd9565b6130a38186611963565b90506115498364ffffffffff1682866124ef565b60008160106130c581611598565b506115e762ffffff1985166004602061183d565b60025460005460015403106131d75760025460015460005b821561314757600082815260086020526040812080548390811061311157fe5b90600052602060002090600302016001015490506131328160018503613446565b60001994850194939093019291506130f19050565b600082815260086020526040902080548290811061316157fe5b90600052602060002090600302016008600084815260200190815260200160002060008154811061318e57fe5b6000918252602080832084546003909302019182556001808501548184015560029485015494909201939093558482526008909252604090205411156129f4576129f4826134ac565b565b50600090565b600060405183815282602082015260208160408360025afa5060208160208360025afa50519392505050565b6000606081805b6020811015611ecc57828582601f036020811061322b57fe5b1a60f81b6040516020018083805190602001908083835b602083106132615780518252601f199092019160209182019101613242565b6001836020036101000a038019825116818451168082178552505050505050905001826001600160f81b03191681526001019250505060405160208183030381529060405292508080600101915050613212565b600060f08083179060ff821614156132d1576030915050610c50565b8060ff1660f114156132e7576031915050610c50565b8060ff1660f214156132fd576032915050610c50565b8060ff1660f31415613313576033915050610c50565b8060ff1660f41415613329576034915050610c50565b8060ff1660f5141561333f576035915050610c50565b8060ff1660f61415613355576036915050610c50565b8060ff1660f7141561336b576037915050610c50565b8060ff1660f81415613381576038915050610c50565b8060ff1660f91415613397576039915050610c50565b8060ff1660fa14156133ad576061915050610c50565b8060ff1660fb14156133c3576062915050610c50565b8060ff1660fc14156133d9576063915050610c50565b8060ff1660fd14156133ef576064915050610c50565b8060ff1660fe1415613405576065915050610c50565b8060ff1660ff141561341b576066915050610c50565b50919050565b600061342c82611814565b61343583612535565b016001600160601b03169050919050565b6000805b6000838152600860205260409020548110156134a257600083815260086020526040902080548290811061347a57fe5b90600052602060002090600302016000015484141561349a579050610c0e565b60010161344a565b5060009392505050565b60015b6000828152600860205260409020548110156135085760008281526008602052604090208054829081106134df57fe5b6000918252602082206003909102018181556001808201839055600290910191909155016134af565b5050565b60408051606081018252600080825260208201819052918101919091529056fe4865616465727320646f206e6f7420666f726d206120636f6e73697374656e7420636861696e526571756573746564206c696d69742069732067726561746572207468616e203120646966666963756c747920706572696f64486561646572206172726179206c656e677468206d75737420626520646976697369626c652062792038304d7573742070726f766964652065786163746c79203120646966666963756c747920706572696f642e20417474656d7074656420746f20696e646578206174206f66667365742030784d7573742070726f7669646520746865206c61737420686561646572206f662074686520636c6f73696e6720646966666963756c747920706572696f6442616420617267732e20436865636b2068656164657220616e642061727261792062797465206c656e677468732e4e65772062657374206861736820646f6573206e6f742068617665206d6f726520776f726b207468616e2070726576696f757354797065644d656d566965772f696e646578202d20417474656d7074656420746f20696e646578206d6f7265207468616e203332206279746573412064657363656e64616e74206865696768742069732062656c6f772074686520616e636573746f7220686569676874506572696f642068656164657220646966666963756c7469657320646f206e6f74206d6174636854797065644d656d566965772f696e646578202d204f76657272616e2074686520766965772e20536c696365206973206174203078416e636573746f72206d75737420626520686561766965737420636f6d6d6f6e20616e636573746f72a26469706673582212207662b5040fdbda095a70ad8d748f4c1c10d2072f91be5f32376a249e2ad3863e64736f6c63430007060033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "addHeaders(bytes,bytes)": {
        "details": "We check integrity and consistency of the header chain",
        "params": {
          "_anchor": "The header immediately preceeding the new chain",
          "_headers": "A tightly-packed list of 80-byte Bitcoin headers"
        },
        "returns": {
          "_0": "True if successfully written, error otherwise"
        }
      },
      "addHeadersWithRetarget(bytes,bytes,bytes)": {
        "details": "Checks the retarget, the heights, and the linkage",
        "params": {
          "_headers": "A tightly-packed list of 80-byte Bitcoin headers",
          "_oldPeriodEndHeader": "The last header in the difficulty period being closed",
          "_oldPeriodStartHeader": "The first header in the difficulty period being closed"
        },
        "returns": {
          "_0": "True if successfully written, error otherwise"
        }
      },
      "constructor": {
        "details": "We don't check this AT ALL really. Don't use relays with bad genesis",
        "params": {
          "_genesisHeader": "The starting header",
          "_height": "The starting height",
          "_periodStart": "The hash of the first header in the genesis epoch"
        }
      },
      "findAncestor(bytes32,uint256)": {
        "details": "Will fail if the header is unknown",
        "params": {
          "_digest": "The header digest to search for"
        },
        "returns": {
          "_0": "The height of the header, or error if unknown"
        }
      },
      "findHeight(bytes32)": {
        "details": "Will fail if the header is unknown",
        "params": {
          "_digest": "The header digest to search for"
        },
        "returns": {
          "_0": "The height of the header, or error if unknown"
        }
      },
      "getBestKnownDigest()": {
        "details": "This updated only by calling markNewHeaviest",
        "returns": {
          "_0": "The hash of the best marked chain tip"
        }
      },
      "getCurrentEpochDifficulty()": {
        "details": "This is updated when a new heavist header has a new diff",
        "returns": {
          "_0": "The difficulty of the bestKnownDigest"
        }
      },
      "getLastReorgCommonAncestor()": {
        "details": "This is updated only by calling markNewHeaviest",
        "returns": {
          "_0": "The hash of the shared ancestor of the most recent fork"
        }
      },
      "getPrevEpochDifficulty()": {
        "details": "This is updated when a difficulty change is accepted",
        "returns": {
          "_0": "The difficulty of the previous epoch"
        }
      },
      "getRelayGenesis()": {
        "details": "This is an initialization parameter",
        "returns": {
          "_0": "The hash of the first block of the relay"
        }
      },
      "isAncestor(bytes32,bytes32,uint256)": {
        "details": "Limit the amount of lookups (and thus gas usage) with _limit",
        "params": {
          "_ancestor": "The prospective ancestor",
          "_descendant": "The descendant to check",
          "_limit": "The maximum number of blocks to check"
        },
        "returns": {
          "_0": "true if ancestor is at most limit blocks lower than descendant, otherwise false"
        }
      },
      "markNewHeaviest(bytes32,bytes,bytes,uint256)": {
        "details": "We don't check this AT ALL really. Don't use relays with bad genesis",
        "params": {
          "_ancestor": "The digest of the most recent common ancestor",
          "_currentBest": "The 80-byte header referenced by bestKnownDigest",
          "_limit": "Limit the amount of traversal of the chain",
          "_newBest": "The 80-byte header to mark as the new best"
        },
        "returns": {
          "_0": "True if successfully updates bestKnownDigest, error otherwise"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "addHeaders(bytes,bytes)": {
        "notice": "Adds headers to storage after validating"
      },
      "addHeadersWithRetarget(bytes,bytes,bytes)": {
        "notice": "Adds headers to storage, performs additional validation of retarget"
      },
      "constructor": {
        "notice": "Gives a starting point for the relay"
      },
      "findAncestor(bytes32,uint256)": {
        "notice": "Finds an ancestor for a block by its digest"
      },
      "findHeight(bytes32)": {
        "notice": "Finds the height of a header by its digest"
      },
      "getBestKnownDigest()": {
        "notice": "Getter for bestKnownDigest"
      },
      "getCurrentEpochDifficulty()": {
        "notice": "Getter for currentEpochDiff"
      },
      "getLastReorgCommonAncestor()": {
        "notice": "Getter for relayGenesis"
      },
      "getPrevEpochDifficulty()": {
        "notice": "Getter for prevEpochDiff"
      },
      "getRelayGenesis()": {
        "notice": "Getter for relayGenesis"
      },
      "isAncestor(bytes32,bytes32,uint256)": {
        "notice": "Checks if a digest is an ancestor of the current one"
      },
      "markNewHeaviest(bytes32,bytes,bytes,uint256)": {
        "notice": "Gives a starting point for the relay"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 8674,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "initialHeight",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 8677,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "lastSubmittedHeight",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 8680,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "finalizationParameter",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 8682,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "relayGenesis",
        "offset": 0,
        "slot": "3",
        "type": "t_bytes32"
      },
      {
        "astId": 8684,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "bestKnownDigest",
        "offset": 0,
        "slot": "4",
        "type": "t_bytes32"
      },
      {
        "astId": 8686,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "lastReorgCommonAncestor",
        "offset": 0,
        "slot": "5",
        "type": "t_bytes32"
      },
      {
        "astId": 8690,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "previousBlock",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_bytes32,t_bytes32)"
      },
      {
        "astId": 8694,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "blockHeight",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_bytes32,t_uint256)"
      },
      {
        "astId": 8699,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "chain",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_uint256,t_array(t_struct(blockHeader)10783_storage)dyn_storage)"
      },
      {
        "astId": 8702,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "owner",
        "offset": 0,
        "slot": "9",
        "type": "t_address"
      },
      {
        "astId": 8704,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "currentEpochDiff",
        "offset": 0,
        "slot": "10",
        "type": "t_uint256"
      },
      {
        "astId": 8706,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "prevEpochDiff",
        "offset": 0,
        "slot": "11",
        "type": "t_uint256"
      },
      {
        "astId": 8709,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "TeleportDAOToken",
        "offset": 0,
        "slot": "12",
        "type": "t_address"
      },
      {
        "astId": 8712,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "feeRatio",
        "offset": 0,
        "slot": "13",
        "type": "t_uint256"
      },
      {
        "astId": 8715,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "submissionGasUsed",
        "offset": 0,
        "slot": "14",
        "type": "t_uint256"
      },
      {
        "astId": 8718,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "epochLength",
        "offset": 0,
        "slot": "15",
        "type": "t_uint256"
      },
      {
        "astId": 8721,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "lastEpochQueries",
        "offset": 0,
        "slot": "16",
        "type": "t_uint256"
      },
      {
        "astId": 8724,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "baseQueries",
        "offset": 0,
        "slot": "17",
        "type": "t_uint256"
      },
      {
        "astId": 8727,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "lastBuyBack",
        "offset": 0,
        "slot": "18",
        "type": "t_uint256"
      },
      {
        "astId": 8730,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "buyBackPeriod",
        "offset": 0,
        "slot": "19",
        "type": "t_uint256"
      },
      {
        "astId": 8733,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "exchangeRouter",
        "offset": 0,
        "slot": "20",
        "type": "t_address"
      },
      {
        "astId": 8736,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "WAVAX",
        "offset": 0,
        "slot": "21",
        "type": "t_address"
      },
      {
        "astId": 8740,
        "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
        "label": "numberOfQueries",
        "offset": 0,
        "slot": "22",
        "type": "t_mapping(t_uint256,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_struct(blockHeader)10783_storage)dyn_storage": {
        "base": "t_struct(blockHeader)10783_storage",
        "encoding": "dynamic_array",
        "label": "struct IBitcoinRelay.blockHeader[]",
        "numberOfBytes": "32"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_bytes32,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_array(t_struct(blockHeader)10783_storage)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IBitcoinRelay.blockHeader[])",
        "numberOfBytes": "32",
        "value": "t_array(t_struct(blockHeader)10783_storage)dyn_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(blockHeader)10783_storage": {
        "encoding": "inplace",
        "label": "struct IBitcoinRelay.blockHeader",
        "members": [
          {
            "astId": 10778,
            "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
            "label": "selfHash",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 10780,
            "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
            "label": "parentHash",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          },
          {
            "astId": 10782,
            "contract": "contracts/relay/BitcoinRelay.sol:BitcoinRelay",
            "label": "merkleRoot",
            "offset": 0,
            "slot": "2",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}