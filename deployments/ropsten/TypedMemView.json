{
  "address": "0xa7e24f80E66bb09819D813e9c4b1B176e22C2d44",
  "abi": [
    {
      "inputs": [],
      "name": "NULL",
      "outputs": [
        {
          "internalType": "bytes29",
          "name": "",
          "type": "bytes29"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        },
        {
          "internalType": "uint40",
          "name": "_expected",
          "type": "uint40"
        }
      ],
      "name": "assertType",
      "outputs": [
        {
          "internalType": "bytes29",
          "name": "",
          "type": "bytes29"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "assertValid",
      "outputs": [
        {
          "internalType": "bytes29",
          "name": "",
          "type": "bytes29"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_type",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_loc",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_len",
          "type": "uint256"
        }
      ],
      "name": "build",
      "outputs": [
        {
          "internalType": "bytes29",
          "name": "newView",
          "type": "bytes29"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "_b",
          "type": "uint8"
        }
      ],
      "name": "byteHex",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "encoded",
          "type": "uint16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        },
        {
          "internalType": "uint40",
          "name": "_newType",
          "type": "uint40"
        }
      ],
      "name": "castTo",
      "outputs": [
        {
          "internalType": "bytes29",
          "name": "newView",
          "type": "bytes29"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "clone",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "ret",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_b",
          "type": "uint256"
        }
      ],
      "name": "encodeHex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "first",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "second",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "end",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "left",
          "type": "bytes29"
        },
        {
          "internalType": "bytes29",
          "name": "right",
          "type": "bytes29"
        }
      ],
      "name": "equal",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "footprint",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "hash160",
      "outputs": [
        {
          "internalType": "bytes20",
          "name": "digest",
          "type": "bytes20"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "hash256",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "digest",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        },
        {
          "internalType": "uint256",
          "name": "_index",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "_bytes",
          "type": "uint8"
        }
      ],
      "name": "index",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "result",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        },
        {
          "internalType": "uint256",
          "name": "_index",
          "type": "uint256"
        }
      ],
      "name": "indexAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_loc",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_len",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_index",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_slice",
          "type": "uint256"
        }
      ],
      "name": "indexErrOverrun",
      "outputs": [
        {
          "internalType": "string",
          "name": "err",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        },
        {
          "internalType": "uint256",
          "name": "_index",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "_bytes",
          "type": "uint8"
        }
      ],
      "name": "indexLEUint",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "result",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        },
        {
          "internalType": "uint256",
          "name": "_index",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "_bytes",
          "type": "uint8"
        }
      ],
      "name": "indexUint",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "result",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "isNull",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        },
        {
          "internalType": "uint40",
          "name": "_expected",
          "type": "uint40"
        }
      ],
      "name": "isType",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "isValid",
      "outputs": [
        {
          "internalType": "bool",
          "name": "ret",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29[]",
          "name": "memViews",
          "type": "bytes29[]"
        }
      ],
      "name": "join",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "ret",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29[]",
          "name": "memViews",
          "type": "bytes29[]"
        }
      ],
      "name": "joinKeccak",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29[]",
          "name": "memViews",
          "type": "bytes29[]"
        }
      ],
      "name": "joinSha2",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "keccak",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "digest",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "len",
      "outputs": [
        {
          "internalType": "uint96",
          "name": "_len",
          "type": "uint96"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "loc",
      "outputs": [
        {
          "internalType": "uint96",
          "name": "_loc",
          "type": "uint96"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "_b",
          "type": "uint8"
        }
      ],
      "name": "nibbleHex",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "char",
          "type": "uint8"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "left",
          "type": "bytes29"
        },
        {
          "internalType": "bytes29",
          "name": "right",
          "type": "bytes29"
        }
      ],
      "name": "notEqual",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "notNull",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "nullView",
      "outputs": [
        {
          "internalType": "bytes29",
          "name": "",
          "type": "bytes29"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        },
        {
          "internalType": "uint256",
          "name": "_len",
          "type": "uint256"
        },
        {
          "internalType": "uint40",
          "name": "newType",
          "type": "uint40"
        }
      ],
      "name": "postfix",
      "outputs": [
        {
          "internalType": "bytes29",
          "name": "",
          "type": "bytes29"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        },
        {
          "internalType": "uint256",
          "name": "_len",
          "type": "uint256"
        },
        {
          "internalType": "uint40",
          "name": "newType",
          "type": "uint40"
        }
      ],
      "name": "prefix",
      "outputs": [
        {
          "internalType": "bytes29",
          "name": "",
          "type": "bytes29"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "arr",
          "type": "bytes"
        },
        {
          "internalType": "uint40",
          "name": "newType",
          "type": "uint40"
        }
      ],
      "name": "ref",
      "outputs": [
        {
          "internalType": "bytes29",
          "name": "",
          "type": "bytes29"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_b",
          "type": "uint256"
        }
      ],
      "name": "reverseUint256",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "v",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "left",
          "type": "bytes29"
        },
        {
          "internalType": "bytes29",
          "name": "right",
          "type": "bytes29"
        }
      ],
      "name": "sameType",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "sha2",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "digest",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        },
        {
          "internalType": "uint256",
          "name": "_index",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_len",
          "type": "uint256"
        },
        {
          "internalType": "uint40",
          "name": "newType",
          "type": "uint40"
        }
      ],
      "name": "slice",
      "outputs": [
        {
          "internalType": "bytes29",
          "name": "",
          "type": "bytes29"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "typeOf",
      "outputs": [
        {
          "internalType": "uint40",
          "name": "_type",
          "type": "uint40"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "left",
          "type": "bytes29"
        },
        {
          "internalType": "bytes29",
          "name": "right",
          "type": "bytes29"
        }
      ],
      "name": "untypedEqual",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "left",
          "type": "bytes29"
        },
        {
          "internalType": "bytes29",
          "name": "right",
          "type": "bytes29"
        }
      ],
      "name": "untypedNotEqual",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes29",
          "name": "memView",
          "type": "bytes29"
        }
      ],
      "name": "words",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x381e2808bf0ca210f96959b2136d86c1df1abd5ea3428d7150647f58d3c451c1",
  "receipt": {
    "to": null,
    "from": "0x5364E3557572bd5D5903C0e9C21BE359F2Eac1dA",
    "contractAddress": "0xa7e24f80E66bb09819D813e9c4b1B176e22C2d44",
    "transactionIndex": 0,
    "gasUsed": "1586528",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x9b1f5fa3f82157c63fcc765629940a95e3bdb23b90f8d3bd85ed82812165bbe3",
    "transactionHash": "0x381e2808bf0ca210f96959b2136d86c1df1abd5ea3428d7150647f58d3c451c1",
    "logs": [],
    "blockNumber": 12801730,
    "cumulativeGasUsed": "1586528",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "9bccde1a4f7e4627724163f00e6fb00c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.2+commit.661d1103\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"NULL\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"},{\"internalType\":\"uint40\",\"name\":\"_expected\",\"type\":\"uint40\"}],\"name\":\"assertType\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"assertValid\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_loc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"}],\"name\":\"build\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"newView\",\"type\":\"bytes29\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_b\",\"type\":\"uint8\"}],\"name\":\"byteHex\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"encoded\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"},{\"internalType\":\"uint40\",\"name\":\"_newType\",\"type\":\"uint40\"}],\"name\":\"castTo\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"newView\",\"type\":\"bytes29\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"clone\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"ret\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_b\",\"type\":\"uint256\"}],\"name\":\"encodeHex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"first\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"second\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"end\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"left\",\"type\":\"bytes29\"},{\"internalType\":\"bytes29\",\"name\":\"right\",\"type\":\"bytes29\"}],\"name\":\"equal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"footprint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"hash160\",\"outputs\":[{\"internalType\":\"bytes20\",\"name\":\"digest\",\"type\":\"bytes20\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"hash256\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_bytes\",\"type\":\"uint8\"}],\"name\":\"index\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"indexAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slice\",\"type\":\"uint256\"}],\"name\":\"indexErrOverrun\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"err\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_bytes\",\"type\":\"uint8\"}],\"name\":\"indexLEUint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_bytes\",\"type\":\"uint8\"}],\"name\":\"indexUint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"isNull\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"},{\"internalType\":\"uint40\",\"name\":\"_expected\",\"type\":\"uint40\"}],\"name\":\"isType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"isValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ret\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29[]\",\"name\":\"memViews\",\"type\":\"bytes29[]\"}],\"name\":\"join\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"ret\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29[]\",\"name\":\"memViews\",\"type\":\"bytes29[]\"}],\"name\":\"joinKeccak\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29[]\",\"name\":\"memViews\",\"type\":\"bytes29[]\"}],\"name\":\"joinSha2\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"keccak\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"len\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"_len\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"loc\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"_loc\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_b\",\"type\":\"uint8\"}],\"name\":\"nibbleHex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"char\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"left\",\"type\":\"bytes29\"},{\"internalType\":\"bytes29\",\"name\":\"right\",\"type\":\"bytes29\"}],\"name\":\"notEqual\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"notNull\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nullView\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"},{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"newType\",\"type\":\"uint40\"}],\"name\":\"postfix\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"},{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"newType\",\"type\":\"uint40\"}],\"name\":\"prefix\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"arr\",\"type\":\"bytes\"},{\"internalType\":\"uint40\",\"name\":\"newType\",\"type\":\"uint40\"}],\"name\":\"ref\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_b\",\"type\":\"uint256\"}],\"name\":\"reverseUint256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"left\",\"type\":\"bytes29\"},{\"internalType\":\"bytes29\",\"name\":\"right\",\"type\":\"bytes29\"}],\"name\":\"sameType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"sha2\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"newType\",\"type\":\"uint40\"}],\"name\":\"slice\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"typeOf\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"_type\",\"type\":\"uint40\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"left\",\"type\":\"bytes29\"},{\"internalType\":\"bytes29\",\"name\":\"right\",\"type\":\"bytes29\"}],\"name\":\"untypedEqual\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"left\",\"type\":\"bytes29\"},{\"internalType\":\"bytes29\",\"name\":\"right\",\"type\":\"bytes29\"}],\"name\":\"untypedNotEqual\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"memView\",\"type\":\"bytes29\"}],\"name\":\"words\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"assertType(bytes29,uint40)\":{\"details\":\"Returns the view for easy chaining.\",\"params\":{\"_expected\":\"The expected type\",\"memView\":\"The view\"},\"returns\":{\"_0\":\"bytes29 - The view with validated type\"}},\"assertValid(bytes29)\":{\"details\":\"Returns the view for easy chaining.\",\"params\":{\"memView\":\"The view\"},\"returns\":{\"_0\":\"bytes29 - The validated view\"}},\"build(uint256,uint256,uint256)\":{\"details\":\"Instantiate a new memory view. This should generally not be called                  directly. Prefer `ref` wherever possible.\",\"params\":{\"_len\":\"The length\",\"_loc\":\"The memory address\",\"_type\":\"The type\"},\"returns\":{\"newView\":\"- The new view with the specified type, location and length\"}},\"byteHex(uint8)\":{\"params\":{\"_b\":\"The byte\"},\"returns\":{\"encoded\":\"- The hex-encoded byte\"}},\"castTo(bytes29,uint40)\":{\"params\":{\"_newType\":\"The new type\",\"memView\":\"The view\"},\"returns\":{\"newView\":\"- The new view with the specified type\"}},\"clone(bytes29)\":{\"details\":\"Shortcuts if the pointers are identical, otherwise compares type and digest.\",\"params\":{\"memView\":\"The view\"},\"returns\":{\"ret\":\"- The view pointing to the new memory\"}},\"encodeHex(uint256)\":{\"params\":{\"_b\":\"The 32 bytes as uint256\"},\"returns\":{\"first\":\"- The top 16 bytes\",\"second\":\"- The bottom 16 bytes\"}},\"end(bytes29)\":{\"params\":{\"memView\":\"The view\"},\"returns\":{\"_0\":\"uint256 - The endpoint of `memView`\"}},\"equal(bytes29,bytes29)\":{\"details\":\"Shortcuts if the pointers are identical, otherwise compares type and digest.\",\"params\":{\"left\":\"The first view\",\"right\":\"The second view\"},\"returns\":{\"_0\":\"bool - True if the types are the same\"}},\"footprint(bytes29)\":{\"params\":{\"memView\":\"The view\"},\"returns\":{\"_0\":\"uint256 - The in-memory footprint of a fresh copy of the view.\"}},\"hash160(bytes29)\":{\"params\":{\"memView\":\"The pre-image\"},\"returns\":{\"digest\":\"- the Digest\"}},\"hash256(bytes29)\":{\"params\":{\"memView\":\"A view of the preimage\"},\"returns\":{\"digest\":\"- the Digest\"}},\"index(bytes29,uint256,uint8)\":{\"details\":\"Returns a bytes32 with only the `_bytes` highest bytes set.                  This can be immediately cast to a smaller fixed-length byte array.                  To automatically cast to an integer, use `indexUint`.\",\"params\":{\"_bytes\":\"The bytes\",\"_index\":\"The index\",\"memView\":\"The view\"},\"returns\":{\"result\":\"- The 32 byte result\"}},\"indexAddress(bytes29,uint256)\":{\"params\":{\"_index\":\"The index\",\"memView\":\"The view\"},\"returns\":{\"_0\":\"address - The address\"}},\"indexErrOverrun(uint256,uint256,uint256,uint256)\":{\"params\":{\"_index\":\"The index\",\"_len\":\"The length\",\"_loc\":\"The memory address\",\"_slice\":\"The slice where the overrun occurred\"},\"returns\":{\"err\":\"- The err\"}},\"indexLEUint(bytes29,uint256,uint8)\":{\"params\":{\"_bytes\":\"The bytes\",\"_index\":\"The index\",\"memView\":\"The view\"},\"returns\":{\"result\":\"- The unsigned integer\"}},\"indexUint(bytes29,uint256,uint8)\":{\"details\":\"Requires that the view have >= `_bytes` bytes following that index.\",\"params\":{\"_bytes\":\"The bytes\",\"_index\":\"The index\",\"memView\":\"The view\"},\"returns\":{\"result\":\"- The unsigned integer\"}},\"isNull(bytes29)\":{\"returns\":{\"_0\":\"bool - True if the view is null\"}},\"isType(bytes29,uint40)\":{\"params\":{\"_expected\":\"The expected type\",\"memView\":\"The view\"},\"returns\":{\"_0\":\"bool - True if the memview is of the expected type\"}},\"isValid(bytes29)\":{\"details\":\"We perform this check by examining solidity's unallocated memory                  pointer and ensuring that the view's upper bound is less than that.\",\"params\":{\"memView\":\"The view\"},\"returns\":{\"ret\":\"- True if the view is valid\"}},\"join(bytes29[])\":{\"params\":{\"memViews\":\"The views\"},\"returns\":{\"ret\":\"- The new byte array\"}},\"joinKeccak(bytes29[])\":{\"params\":{\"memViews\":\"The views\"},\"returns\":{\"_0\":\"bytes32 - The keccak256 digest\"}},\"joinSha2(bytes29[])\":{\"params\":{\"memViews\":\"The views\"},\"returns\":{\"_0\":\"bytes32 - The sha256 digest\"}},\"keccak(bytes29)\":{\"params\":{\"memView\":\"The view\"},\"returns\":{\"digest\":\"- The keccak256 hash of the underlying memory\"}},\"len(bytes29)\":{\"params\":{\"memView\":\"The view\"},\"returns\":{\"_len\":\"- The length of the view\"}},\"loc(bytes29)\":{\"params\":{\"memView\":\"The view\"},\"returns\":{\"_loc\":\"- The memory address\"}},\"nibbleHex(uint8)\":{\"params\":{\"_b\":\"The byte\"},\"returns\":{\"char\":\"- The encoded hex character\"}},\"notEqual(bytes29,bytes29)\":{\"details\":\"Shortcuts if the pointers are identical, otherwise compares type and digest.\",\"params\":{\"left\":\"The first view\",\"right\":\"The second view\"},\"returns\":{\"_0\":\"bool - True if the types are not the same\"}},\"notNull(bytes29)\":{\"returns\":{\"_0\":\"bool - True if the view is not null\"}},\"nullView()\":{\"returns\":{\"_0\":\"bytes29 - The null view\"}},\"postfix(bytes29,uint256,uint40)\":{\"params\":{\"_len\":\"The length\",\"memView\":\"The view\",\"newType\":\"The new type\"},\"returns\":{\"_0\":\"bytes29 - The new view\"}},\"prefix(bytes29,uint256,uint40)\":{\"params\":{\"_len\":\"The length\",\"memView\":\"The view\",\"newType\":\"The new type\"},\"returns\":{\"_0\":\"bytes29 - The new view\"}},\"ref(bytes,uint40)\":{\"details\":\"Note that due to Solidity memory representation, it is not possible to                  implement a deref, as the `bytes` type stores its len in memory.\",\"params\":{\"arr\":\"The byte array\",\"newType\":\"The type\"},\"returns\":{\"_0\":\"bytes29 - The memory view\"}},\"reverseUint256(uint256)\":{\"details\":\"https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\",\"params\":{\"_b\":\"The unsigned integer to reverse\"},\"returns\":{\"v\":\"- The reversed value\"}},\"sameType(bytes29,bytes29)\":{\"params\":{\"left\":\"The first view\",\"right\":\"The second view\"},\"returns\":{\"_0\":\"bool - True if the 5-byte type flag is equal\"}},\"sha2(bytes29)\":{\"details\":\"We explicitly deallocate memory afterwards.\",\"params\":{\"memView\":\"The view\"},\"returns\":{\"digest\":\"- The sha2 hash of the underlying memory\"}},\"slice(bytes29,uint256,uint256,uint40)\":{\"params\":{\"_index\":\"The start index\",\"_len\":\"The length\",\"memView\":\"The view\",\"newType\":\"The new type\"},\"returns\":{\"_0\":\"bytes29 - The new view\"}},\"typeOf(bytes29)\":{\"params\":{\"memView\":\"The memory view\"},\"returns\":{\"_type\":\"- The type associated with the view\"}},\"untypedEqual(bytes29,bytes29)\":{\"params\":{\"left\":\"The first view\",\"right\":\"The second view\"},\"returns\":{\"_0\":\"bool - True if the underlying memory is equal\"}},\"untypedNotEqual(bytes29,bytes29)\":{\"params\":{\"left\":\"The first view\",\"right\":\"The second view\"},\"returns\":{\"_0\":\"bool - False if the underlying memory is equal\"}},\"words(bytes29)\":{\"params\":{\"memView\":\"The view\"},\"returns\":{\"_0\":\"uint256 - The number of memory words\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"assertType(bytes29,uint40)\":{\"notice\":\"Require that a typed memory view has a specific type.\"},\"assertValid(bytes29)\":{\"notice\":\"Require that a typed memory view be valid.\"},\"build(uint256,uint256,uint256)\":{\"notice\":\"Instantiate a new memory view. This should generally not be called                  directly. Prefer `ref` wherever possible.\"},\"byteHex(uint8)\":{\"notice\":\"Returns a uint16 containing the hex-encoded byte.              `the first 8 bits of encoded is the nibbleHex of top 4 bits of _b`              `the second 8 bits of encoded is the nibbleHex of lower 4 bits of _b`\"},\"castTo(bytes29,uint40)\":{\"notice\":\"Return an identical view with a different type.\"},\"clone(bytes29)\":{\"notice\":\"Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to                  the new memory\"},\"encodeHex(uint256)\":{\"notice\":\"Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.              `second` contains the encoded lower 16 bytes.\"},\"end(bytes29)\":{\"notice\":\"Returns the endpoint of `memView`.\"},\"equal(bytes29,bytes29)\":{\"notice\":\"Compares type equality.\"},\"footprint(bytes29)\":{\"notice\":\"The in-memory footprint of a fresh copy of the view.\"},\"hash160(bytes29)\":{\"notice\":\"Implements bitcoin's hash160 (rmd160(sha2()))\"},\"hash256(bytes29)\":{\"notice\":\"Implements bitcoin's hash256 (double sha2)\"},\"index(bytes29,uint256,uint8)\":{\"notice\":\"Load up to 32 bytes from the view onto the stack.\"},\"indexAddress(bytes29,uint256)\":{\"notice\":\"Parse an address from the view at `_index`. Requires that the view have >= 20 bytes                  following that index.\"},\"indexErrOverrun(uint256,uint256,uint256,uint256)\":{\"notice\":\"Construct an error message for an indexing overrun.\"},\"indexLEUint(bytes29,uint256,uint8)\":{\"notice\":\"Parse an unsigned integer from LE bytes.\"},\"indexUint(bytes29,uint256,uint8)\":{\"notice\":\"Parse an unsigned integer from the view at `_index`.\"},\"isNull(bytes29)\":{\"notice\":\"Check if the view is null.\"},\"isType(bytes29,uint40)\":{\"notice\":\"Return true if the memview is of the expected type. Otherwise false.\"},\"isValid(bytes29)\":{\"notice\":\"Check if the view is of a valid type and points to a valid location                  in memory.\"},\"join(bytes29[])\":{\"notice\":\"copies all views, joins them into a new bytearray.\"},\"joinKeccak(bytes29[])\":{\"notice\":\"Produce the keccak256 digest of the concatenated contents of multiple views.\"},\"joinSha2(bytes29[])\":{\"notice\":\"Produce the sha256 digest of the concatenated contents of multiple views.\"},\"keccak(bytes29)\":{\"notice\":\"Return the keccak256 hash of the underlying memory\"},\"len(bytes29)\":{\"notice\":\"The number of bytes of the view.\"},\"loc(bytes29)\":{\"notice\":\"Return the memory address of the underlying bytes.\"},\"nibbleHex(uint8)\":{\"notice\":\"Returns the encoded hex character that represents the lower 4 bits of the argument.\"},\"notEqual(bytes29,bytes29)\":{\"notice\":\"Compares type inequality.\"},\"notNull(bytes29)\":{\"notice\":\"Check if the view is not null.\"},\"nullView()\":{\"notice\":\"Return the null view.\"},\"postfix(bytes29,uint256,uint40)\":{\"notice\":\"Shortcut to `slice`. Gets a view representing the last `_len` byte.\"},\"prefix(bytes29,uint256,uint40)\":{\"notice\":\"Shortcut to `slice`. Gets a view representing the first `_len` bytes.\"},\"ref(bytes,uint40)\":{\"notice\":\"Instantiate a memory view from a byte array.\"},\"reverseUint256(uint256)\":{\"notice\":\"Changes the endianness of a uint256.\"},\"sameType(bytes29,bytes29)\":{\"notice\":\"Optimized type comparison. Checks that the 5-byte type flag is equal.\"},\"sha2(bytes29)\":{\"notice\":\"Return the sha2 digest of the underlying memory.\"},\"slice(bytes29,uint256,uint256,uint40)\":{\"notice\":\"Safe slicing without memory modification.\"},\"typeOf(bytes29)\":{\"notice\":\"Return the associated type information.\"},\"untypedEqual(bytes29,bytes29)\":{\"notice\":\"Return true if the underlying memory is equal. Else false.\"},\"untypedNotEqual(bytes29,bytes29)\":{\"notice\":\"Return false if the underlying memory is equal. Else true.\"},\"words(bytes29)\":{\"notice\":\"The number of memory words this memory view occupies, rounded up.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/TypedMemView.sol\":\"TypedMemView\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/libraries/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n    \\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b; //TODO: edit it\\n    }\\n}\",\"keccak256\":\"0x0e9e1f6ce97bc6b4de34121b05b78ef753eb8399f1087e8daf8cb5ac0e33954c\",\"license\":\"MIT\"},\"contracts/libraries/TypedMemView.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary TypedMemView {\\n    using SafeMath for uint256;\\n\\n    // Why does this exist?\\n    // the solidity `bytes memory` type has a few weaknesses.\\n    // 1. You can't index ranges effectively\\n    // 2. You can't slice without copying\\n    // 3. The underlying data may represent any type\\n    // 4. Solidity never deallocates memory, and memory costs grow\\n    //    superlinearly\\n\\n    // By using a memory view instead of a `bytes memory` we get the following\\n    // advantages:\\n    // 1. Slices are done on the stack, by manipulating the pointer\\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\\n    // 3. We can insert type info into the pointer, and typecheck at runtime\\n\\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\\n    // algorithms.\\n\\n    // Why bytes29?\\n    // We want to avoid confusion between views, digests, and other common\\n    // types so we chose a large and uncommonly used odd number of bytes\\n    //\\n    // Note that while bytes are left-aligned in a word, integers and addresses\\n    // are right-aligned. This means when working in assembly we have to\\n    // account for the 3 unused bytes on the righthand side\\n    //\\n    // First 5 bytes are a type flag.\\n    // - ff_ffff_fffe is reserved for unknown type.\\n    // - ff_ffff_ffff is reserved for invalid types/errors.\\n    // next 12 are memory address\\n    // next 12 are len\\n    // bottom 3 bytes are empty\\n\\n    // Assumptions:\\n    // - non-modification of memory.\\n    // - No Solidity updates\\n    // - - wrt free mem point\\n    // - - wrt bytes representation in memory\\n    // - - wrt memory addressing in general\\n\\n    // Usage:\\n    // - create type constants\\n    // - use `assertType` for runtime type assertions\\n    // - - unfortunately we can't do this at compile time yet :(\\n    // - recommended: implement modifiers that perform type checking\\n    // - - e.g.\\n    // - - `uint40 constant MY_TYPE = 3;`\\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\\n    // - instantiate a typed view from a bytearray using `ref`\\n    // - use `index` to inspect the contents of the view\\n    // - use `slice` to create smaller views into the same memory\\n    // - - `slice` can increase the offset\\n    // - - `slice can decrease the length`\\n    // - - must specify the output type of `slice`\\n    // - - `slice` will return a null view if you try to overrun\\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\\n    // - use `equal` for typed comparisons.\\n\\n\\n    // The null view\\n    bytes29 public constant NULL = hex\\\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\\";\\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\\n    uint8 constant TWELVE_BYTES = 96;\\n\\n    /**\\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\\n     * @param _b    The byte\\n     * @return      char - The encoded hex character\\n     */\\n    function nibbleHex(uint8 _b) public pure returns (uint8 char) {\\n        // This can probably be done more efficiently, but it's only in error\\n        // paths, so we don't really care :)\\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\\n        if (_nibble == 0xf0) {return 0x30;} // 0\\n        if (_nibble == 0xf1) {return 0x31;} // 1\\n        if (_nibble == 0xf2) {return 0x32;} // 2\\n        if (_nibble == 0xf3) {return 0x33;} // 3\\n        if (_nibble == 0xf4) {return 0x34;} // 4\\n        if (_nibble == 0xf5) {return 0x35;} // 5\\n        if (_nibble == 0xf6) {return 0x36;} // 6\\n        if (_nibble == 0xf7) {return 0x37;} // 7\\n        if (_nibble == 0xf8) {return 0x38;} // 8\\n        if (_nibble == 0xf9) {return 0x39;} // 9\\n        if (_nibble == 0xfa) {return 0x61;} // a\\n        if (_nibble == 0xfb) {return 0x62;} // b\\n        if (_nibble == 0xfc) {return 0x63;} // c\\n        if (_nibble == 0xfd) {return 0x64;} // d\\n        if (_nibble == 0xfe) {return 0x65;} // e\\n        if (_nibble == 0xff) {return 0x66;} // f\\n    }\\n\\n    /**\\n     * @notice      Returns a uint16 containing the hex-encoded byte.\\n     *              `the first 8 bits of encoded is the nibbleHex of top 4 bits of _b`\\n     *              `the second 8 bits of encoded is the nibbleHex of lower 4 bits of _b`\\n     * @param _b    The byte\\n     * @return      encoded - The hex-encoded byte\\n     */\\n    function byteHex(uint8 _b) public pure returns (uint16 encoded) {\\n        encoded |= nibbleHex(_b >> 4); // top 4 bits\\n        encoded <<= 8;\\n        encoded |= nibbleHex(_b); // lower 4 bits\\n    }\\n\\n    /**\\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\\n     *              `second` contains the encoded lower 16 bytes.\\n     *\\n     * @param _b    The 32 bytes as uint256\\n     * @return      first - The top 16 bytes\\n     * @return      second - The bottom 16 bytes\\n     */\\n    function encodeHex(uint256 _b) public pure returns (uint256 first, uint256 second) {\\n        for (uint8 i = 31; i > 15; i -= 1) {\\n            uint8 _byte = uint8(_b >> (i * 8));\\n            first |= byteHex(_byte);\\n            if (i != 16) {\\n                first <<= 16;\\n            }\\n        }\\n\\n        // abusing underflow here =_=\\n        for (uint8 i = 15; i < 255 ; i -= 1) {\\n            uint8 _byte = uint8(_b >> (i * 8));\\n            second |= byteHex(_byte);\\n            if (i != 0) {\\n                second <<= 16;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice          Changes the endianness of a uint256.\\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\\n     * @param _b        The unsigned integer to reverse\\n     * @return          v - The reversed value\\n     */\\n    function reverseUint256(uint256 _b) public pure returns (uint256 v) {\\n        v = _b;\\n\\n        // swap bytes\\n        v = ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\\n        ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n        // swap 2-byte long pairs\\n        v = ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\\n        ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n        // swap 4-byte long pairs\\n        v = ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\\n        ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n        // swap 8-byte long pairs\\n        v = ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\\n        ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n        // swap 16-byte long pairs\\n        v = (v >> 128) | (v << 128);\\n    }\\n\\n    /**\\n     * @notice      Create a mask with the highest `_len` bits set.\\n     * @param _len  The length\\n     * @return      mask - The mask\\n     */\\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\\n        // ugly. redo without assembly?\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            mask := sar(\\n            sub(_len, 1),\\n            0x8000000000000000000000000000000000000000000000000000000000000000\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @notice      Return the null view.\\n     * @return      bytes29 - The null view\\n     */\\n    function nullView() public pure returns (bytes29) {\\n        return NULL;\\n    }\\n\\n    /**\\n     * @notice      Check if the view is null.\\n     * @return      bool - True if the view is null\\n     */\\n    function isNull(bytes29 memView) public pure returns (bool) {\\n        return memView == NULL;\\n    }\\n\\n    /**\\n     * @notice      Check if the view is not null.\\n     * @return      bool - True if the view is not null\\n     */\\n    function notNull(bytes29 memView) public pure returns (bool) {\\n        return !isNull(memView);\\n    }\\n\\n    /**\\n     * @notice          Check if the view is of a valid type and points to a valid location\\n     *                  in memory.\\n     * @dev             We perform this check by examining solidity's unallocated memory\\n     *                  pointer and ensuring that the view's upper bound is less than that.\\n     * @param memView   The view\\n     * @return          ret - True if the view is valid\\n     */\\n    function isValid(bytes29 memView) public pure returns (bool ret) {\\n        if (typeOf(memView) == 0xffffffffff) {return false;}\\n        uint256 _end = end(memView);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            ret := not(gt(_end, mload(0x40)))\\n        }\\n    }\\n\\n    /**\\n     * @notice          Require that a typed memory view be valid.\\n     * @dev             Returns the view for easy chaining.\\n     * @param memView   The view\\n     * @return          bytes29 - The validated view\\n     */\\n    function assertValid(bytes29 memView) public pure returns (bytes29) {\\n        require(isValid(memView), \\\"Validity assertion failed\\\");\\n        return memView;\\n    }\\n\\n    /**\\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\\n     * @param memView   The view\\n     * @param _expected The expected type\\n     * @return          bool - True if the memview is of the expected type\\n     */\\n    function isType(bytes29 memView, uint40 _expected) public pure returns (bool) {\\n        return typeOf(memView) == _expected;\\n    }\\n\\n    /**\\n     * @notice          Require that a typed memory view has a specific type.\\n     * @dev             Returns the view for easy chaining.\\n     * @param memView   The view\\n     * @param _expected The expected type\\n     * @return          bytes29 - The view with validated type\\n     */\\n    function assertType(bytes29 memView, uint40 _expected) public pure returns (bytes29) {\\n        if (!isType(memView, _expected)) {\\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\\n            (, uint256 e) = encodeHex(uint256(_expected));\\n            string memory err = string(\\n                abi.encodePacked(\\n                    \\\"Type assertion failed. Got 0x\\\",\\n                    uint80(g),\\n                    \\\". Expected 0x\\\",\\n                    uint80(e)\\n                )\\n            );\\n            revert(err);\\n        }\\n        return memView;\\n    }\\n\\n    /**\\n     * @notice          Return an identical view with a different type.\\n     * @param memView   The view\\n     * @param _newType  The new type\\n     * @return          newView - The new view with the specified type\\n     */\\n    function castTo(bytes29 memView, uint40 _newType) public pure returns (bytes29 newView) {\\n        // then | in the new type\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n        // shift off the top 5 bytes\\n            newView := or(newView, shr(40, shl(40, memView)))\\n            newView := or(newView, shl(216, _newType))\\n        }\\n    }\\n\\n    /**\\n     * @notice          Unsafe raw pointer construction. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @dev             Unsafe raw pointer construction. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @param _type     The type\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @return          newView - The new view with the specified type, location and length\\n     */\\n    function unsafeBuildUnchecked(uint256 _type, uint256 _loc, uint256 _len) private pure returns (bytes29 newView) {\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            newView := shl(96, or(newView, _type)) // insert type\\n            newView := shl(96, or(newView, _loc))  // insert loc\\n            newView := shl(24, or(newView, _len))  // empty bottom 3 bytes\\n        }\\n    }\\n\\n    /**\\n     * @notice          Instantiate a new memory view. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @dev             Instantiate a new memory view. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @param _type     The type\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @return          newView - The new view with the specified type, location and length\\n     */\\n    function build(uint256 _type, uint256 _loc, uint256 _len) public pure returns (bytes29 newView) {\\n        uint256 _end = _loc.add(_len);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            if gt(_end, mload(0x40)) {\\n                _end := 0\\n            }\\n        }\\n        if (_end == 0) {\\n            return NULL;\\n        }\\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Instantiate a memory view from a byte array.\\n     * @dev             Note that due to Solidity memory representation, it is not possible to\\n     *                  implement a deref, as the `bytes` type stores its len in memory.\\n     * @param arr       The byte array\\n     * @param newType   The type\\n     * @return          bytes29 - The memory view\\n     */\\n    function ref(bytes memory arr, uint40 newType) public pure returns (bytes29) {\\n        uint256 _len = arr.length;\\n\\n        uint256 _loc;\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            _loc := add(arr, 0x20)  // our view is of the data, not the struct\\n        }\\n\\n        return build(newType, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Return the associated type information.\\n     * @param memView   The memory view\\n     * @return          _type - The type associated with the view\\n     */\\n    function typeOf(bytes29 memView) public pure returns (uint40 _type) {\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n        // 216 == 256 - 40\\n            _type := shr(216, memView) // shift out lower 24 bytes\\n        }\\n    }\\n\\n    /**\\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the 5-byte type flag is equal\\n     */\\n    function sameType(bytes29 left, bytes29 right) public pure returns (bool) {\\n        // XOR the inputs to check their difference\\n        return (left ^ right) >> (2 * TWELVE_BYTES) == 0;\\n    }\\n\\n    /**\\n     * @notice          Return the memory address of the underlying bytes.\\n     * @param memView   The view\\n     * @return          _loc - The memory address\\n     */\\n    function loc(bytes29 memView) public pure returns (uint96 _loc) {\\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n        // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\\n            _loc := and(shr(120, memView), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          The number of memory words this memory view occupies, rounded up.\\n     * @param memView   The view\\n     * @return          uint256 - The number of memory words\\n     */\\n    function words(bytes29 memView) public pure returns (uint256) {\\n        return uint256(len(memView)).add(32) / 32;\\n    }\\n\\n    /**\\n     * @notice          The in-memory footprint of a fresh copy of the view.\\n     * @param memView   The view\\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\\n     */\\n    function footprint(bytes29 memView) public pure returns (uint256) {\\n        return words(memView) * 32;\\n    }\\n\\n    /**\\n     * @notice          The number of bytes of the view.\\n     * @param memView   The view\\n     * @return          _len - The length of the view\\n     */\\n    function len(bytes29 memView) public pure returns (uint96 _len) {\\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            _len := and(shr(24, memView), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Returns the endpoint of `memView`.\\n     * @param memView   The view\\n     * @return          uint256 - The endpoint of `memView`\\n     */\\n    function end(bytes29 memView) public pure returns (uint256) {\\n        return loc(memView) + len(memView);\\n    }\\n\\n    /**\\n     * @notice          Safe slicing without memory modification.\\n     * @param memView   The view\\n     * @param _index    The start index\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function slice(bytes29 memView, uint256 _index, uint256 _len, uint40 newType) public pure returns (bytes29) {\\n        uint256 _loc = loc(memView);\\n\\n        // Ensure it doesn't overrun the view\\n        if (_loc.add(_index).add(_len) > end(memView)) {\\n            return NULL;\\n        }\\n\\n        _loc = _loc.add(_index);\\n        return build(newType, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\\n     * @param memView   The view\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function prefix(bytes29 memView, uint256 _len, uint40 newType) public pure returns (bytes29) {\\n        return slice(memView, 0, _len, newType);\\n    }\\n\\n    /**\\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\\n     * @param memView   The view\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function postfix(bytes29 memView, uint256 _len, uint40 newType) public pure returns (bytes29) {\\n        return slice(memView, uint256(len(memView)).sub(_len), _len, newType);\\n    }\\n\\n    /**\\n     * @notice          Construct an error message for an indexing overrun.\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @param _index    The index\\n     * @param _slice    The slice where the overrun occurred\\n     * @return          err - The err\\n     */\\n    function indexErrOverrun(\\n        uint256 _loc,\\n        uint256 _len,\\n        uint256 _index,\\n        uint256 _slice\\n    ) public pure returns (string memory err) {\\n        (, uint256 a) = encodeHex(_loc);\\n        (, uint256 b) = encodeHex(_len);\\n        (, uint256 c) = encodeHex(_index);\\n        (, uint256 d) = encodeHex(_slice);\\n        err = string(\\n            abi.encodePacked(\\n                \\\"TypedMemView/index - Overran the view. Slice is at 0x\\\",\\n                uint48(a),\\n                \\\" with length 0x\\\",\\n                uint48(b),\\n                \\\". Attempted to index at offset 0x\\\",\\n                uint48(c),\\n                \\\" with length 0x\\\",\\n                uint48(d),\\n                \\\".\\\"\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice          Load up to 32 bytes from the view onto the stack.\\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\\n     *                  This can be immediately cast to a smaller fixed-length byte array.\\n     *                  To automatically cast to an integer, use `indexUint`.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The 32 byte result\\n     */\\n    function index(bytes29 memView, uint256 _index, uint8 _bytes) public pure returns (bytes32 result) {\\n        if (_bytes == 0) {return bytes32(0);}\\n        if (_index.add(_bytes) > len(memView)) {\\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\\n        }\\n        require(_bytes <= 32, \\\"TypedMemView/index - Attempted to index more than 32 bytes\\\");\\n\\n        // FIXME: why the following lines need `unchecked`\\n    unchecked {\\n        uint8 bitLength = _bytes * 8;\\n        uint256 _loc = loc(memView);\\n        uint256 _mask = leftMask(bitLength);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            result := and(mload(add(_loc, _index)), _mask)\\n        }\\n    }\\n\\n    }\\n\\n    /**\\n     * @notice          Parse an unsigned integer from the view at `_index`.\\n     * @dev             Requires that the view have >= `_bytes` bytes following that index.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The unsigned integer\\n     */\\n    function indexUint(bytes29 memView, uint256 _index, uint8 _bytes) public pure returns (uint256 result) {\\n        return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\\n    }\\n\\n    /**\\n     * @notice          Parse an unsigned integer from LE bytes.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The unsigned integer\\n     */\\n    function indexLEUint(bytes29 memView, uint256 _index, uint8 _bytes) public pure returns (uint256 result) {\\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\\n    }\\n\\n    /**\\n     * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\\n     *                  following that index.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @return          address - The address\\n     */\\n    function indexAddress(bytes29 memView, uint256 _index) public pure returns (address) {\\n        return address(uint160(indexUint(memView, _index, 20)));\\n    }\\n\\n    /**\\n     * @notice          Return the keccak256 hash of the underlying memory\\n     * @param memView   The view\\n     * @return          digest - The keccak256 hash of the underlying memory\\n     */\\n    function keccak(bytes29 memView) public pure returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            digest := keccak256(_loc, _len)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Return the sha2 digest of the underlying memory.\\n     * @dev             We explicitly deallocate memory afterwards.\\n     * @param memView   The view\\n     * @return          digest - The sha2 hash of the underlying memory\\n     */\\n    function sha2(bytes29 memView) public view returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\\n     * @param memView   The pre-image\\n     * @return          digest - the Digest\\n     */\\n    function hash160(bytes29 memView) public view returns (bytes20 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\\n        }\\n    }\\n\\n    /**\\n     * @notice          Implements bitcoin's hash256 (double sha2)\\n     * @param memView   A view of the preimage\\n     * @return          digest - the Digest\\n     */\\n    function hash256(bytes29 memView) public view returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Return true if the underlying memory is equal. Else false.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the underlying memory is equal\\n     */\\n    function untypedEqual(bytes29 left, bytes29 right) public pure returns (bool) {\\n        return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\\n    }\\n\\n    /**\\n     * @notice          Return false if the underlying memory is equal. Else true.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - False if the underlying memory is equal\\n     */\\n    function untypedNotEqual(bytes29 left, bytes29 right) public pure returns (bool) {\\n        return !untypedEqual(left, right);\\n    }\\n\\n    /**\\n     * @notice          Compares type equality.\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the types are the same\\n     */\\n    function equal(bytes29 left, bytes29 right) public pure returns (bool) {\\n        return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\\n    }\\n\\n    /**\\n     * @notice          Compares type inequality.\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the types are not the same\\n     */\\n    function notEqual(bytes29 left, bytes29 right) public pure returns (bool) {\\n        return !equal(left, right);\\n    }\\n\\n    /**\\n     * @notice          Copy the view to a location, return an unsafe memory reference\\n     * @dev             Super Dangerous direct memory access.\\n     *\\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\\n     *                  As such it MUST be consumed IMMEDIATELY.\\n     *                  This function is private to prevent unsafe usage by callers.\\n     * @param memView   The view\\n     * @param _newLoc   The new location\\n     * @return          written - the unsafe memory reference\\n     */\\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\\n        require(notNull(memView), \\\"TypedMemView/copyTo - Null pointer deref\\\");\\n        require(isValid(memView), \\\"TypedMemView/copyTo - Invalid pointer deref\\\");\\n        uint256 _len = len(memView);\\n        uint256 _oldLoc = loc(memView);\\n\\n        uint256 ptr;\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40)\\n        // revert if we're writing in occupied memory\\n            if gt(ptr, _newLoc) {\\n                revert(0x60, 0x20) // empty revert message\\n            }\\n\\n        // use the identity precompile to copy\\n        // guaranteed not to fail, so pop the success\\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\\n        }\\n\\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\\n    }\\n\\n    /**\\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\\n     *                  the new memory\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param memView   The view\\n     * @return          ret - The view pointing to the new memory\\n     */\\n    function clone(bytes29 memView) public view returns (bytes memory ret) {\\n        uint256 ptr;\\n        uint256 _len = len(memView);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n            ret := ptr\\n        }\\n        unsafeCopyTo(memView, ptr + 0x20);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\\n            mstore(ptr, _len) // write len of new array (in bytes)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\\n     * @dev             Super Dangerous direct memory access.\\n     *\\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\\n     *                  As such it MUST be consumed IMMEDIATELY.\\n     *                  This function is private to prevent unsafe usage by callers.\\n     * @param memViews  The views\\n     * @return          unsafeView - The conjoined view pointing to the new memory\\n     */\\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n        // revert if we're writing in occupied memory\\n            if gt(ptr, _location) {\\n                revert(0x60, 0x20) // empty revert message\\n            }\\n        }\\n\\n        uint256 _offset = 0;\\n        for (uint256 i = 0; i < memViews.length; i ++) {\\n            bytes29 memView = memViews[i];\\n            unsafeCopyTo(memView, _location + _offset);\\n            _offset += len(memView);\\n        }\\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\\n    }\\n\\n    /**\\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\\n     * @param memViews  The views\\n     * @return          bytes32 - The keccak256 digest\\n     */\\n    function joinKeccak(bytes29[] memory memViews) public view returns (bytes32) {\\n        uint256 ptr;\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n        return keccak(unsafeJoin(memViews, ptr));\\n    }\\n\\n    /**\\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\\n     * @param memViews  The views\\n     * @return          bytes32 - The sha256 digest\\n     */\\n    function joinSha2(bytes29[] memory memViews) public view returns (bytes32) {\\n        uint256 ptr;\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n        return sha2(unsafeJoin(memViews, ptr));\\n    }\\n\\n    /**\\n     * @notice          copies all views, joins them into a new bytearray.\\n     * @param memViews  The views\\n     * @return          ret - The new byte array\\n     */\\n    function join(bytes29[] memory memViews) public view returns (bytes memory ret) {\\n        uint256 ptr;\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n\\n        bytes29 _newView = unsafeJoin(memViews, ptr + 0x20);\\n        uint256 _written = len(_newView);\\n        uint256 _footprint = footprint(_newView);\\n\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n        // store the legnth\\n            mstore(ptr, _written)\\n        // new pointer is old + 0x20 + the footprint of the body\\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\\n            ret := ptr\\n        }\\n    }\\n}\",\"keccak256\":\"0x2a8fbc963c1d8e124fcfd48685672d36433b36afd4c76a1fea5e6260c1dea4b5\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x611bbf61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106102685760003560e01c806372cfe90b11610150578063a60a7282116100cd578063c197cfef11610091578063c197cfef14610759578063c90bb5531461076c578063d18266c91461077f578063da98f02b14610792578063f26be3fc146107a5578063f6e8b9d5146107b057610268565b8063a60a7282146106f3578063afc9fe5814610706578063b367971d14610720578063bac4b38d14610733578063bead12041461074657610268565b80639cb855cb116101145780639cb855cb146106755780639f07152514610692578063a0f20eb1146106a5578063a13c2243146106b8578063a1ce10e6146106cb57610268565b806372cfe90b146105ce578063744fa02b146105e1578063758a15c814610606578063829170301461061957806383d06a941461064457610268565b80633acd9d3e116101e95780635145c996116101ad5780635145c9961461053b5780635938773e1461054e5780635aacd0ba1461056957806365acccba1461059e57806369f994a6146105a85780636e7ece2e146105bb57610268565b80633acd9d3e146103a757806340bec88f146103ba578063493832e214610502578063497c8365146105155780634afc8c941461052857610268565b80631fdbc48c116102305780631fdbc48c1461031757806323509a1d14610338578063287ef85a1461034b5780632c2e8d7d1461036e57806338c17a3f1461039457610268565b8063018319a11461026d57806308d5a7271461029a5780630b9e1db6146102ba57806315d823f2146102e45780631ab11e8a146102f7575b600080fd5b61028061027b36600461174f565b6107c3565b60405162ffffff1990911681526020015b60405180910390f35b6102806102a8366004611876565b60d81b6001600160d81b039091161790565b6102ce6102c836600461174f565b60d81c90565b60405164ffffffffff9091168152602001610291565b6102806102f2366004611958565b610827565b61030a610305366004611983565b61086e565b6040516102919190611a19565b61032a61032536600461174f565b610998565b604051908152602001610291565b61032a61034636600461174f565b6109fa565b61035e610359366004611769565b610a43565b6040519015158152602001610291565b61038161037c3660046119b4565b610a59565b60405161ffff9091168152602001610291565b61032a6103a2366004611844565b610a89565b61035e6103b5366004611769565b610be2565b61032a6103c8366004611940565b600881811c7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff167fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff009290911b9190911617601081811c7dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff167fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff00009290911b9190911617602081811c7bffffffff00000000ffffffff00000000ffffffff00000000ffffffff167fffffffff00000000ffffffff00000000ffffffff00000000ffffffff000000009290911b9190911617604081811c77ffffffffffffffff0000000000000000ffffffffffffffff1677ffffffffffffffff0000000000000000ffffffffffffffff199290911b9190911617608081811c91901b1790565b61035e610510366004611769565b610c3a565b61035e61052336600461174f565b610c6a565b61032a6105363660046116a1565b610ca8565b61032a61054936600461174f565b610cbb565b61035e61055c36600461174f565b62ffffff19908116141590565b61058661057736600461174f565b60781c6001600160601b031690565b6040516001600160601b039091168152602001610291565b62ffffff19610280565b6102806105b636600461189f565b610cf0565b6102806105c93660046117c4565b610d14565b61032a6105dc36600461174f565b610d8f565b6105f46105ef3660046119b4565b610dd0565b60405160ff9091168152602001610291565b610280610614366004611809565b610f3c565b61062c61062736600461179b565b610f6f565b6040516001600160a01b039091168152602001610291565b61065761065236600461174f565b610f7d565b6040516bffffffffffffffffffffffff199091168152602001610291565b61058661068336600461174f565b60181c6001600160601b031690565b61032a6106a036600461174f565b610fe2565b61035e6106b3366004611769565b610ff8565b61030a6106c63660046116a1565b611083565b6106de6106d9366004611940565b6110df565b60408051928352602083019190915201610291565b610280610701366004611876565b61119f565b61035e61071436600461174f565b62ffffff199081161490565b61035e61072e366004611769565b611278565b61030a61074136600461174f565b611284565b610280610754366004611809565b6112d4565b61032a610767366004611844565b6112e3565b61032a61077a3660046116a1565b6112f3565b61035e61078d366004611876565b611306565b61032a6107a0366004611844565b611329565b61028062ffffff1981565b61032a6107be36600461174f565b611359565b60006107ce82610c6a565b61081f5760405162461bcd60e51b815260206004820152601960248201527f56616c696469747920617373657274696f6e206661696c65640000000000000060448201526064015b60405180910390fd5b50805b919050565b60008061083484846113b0565b9050604051811115610844575060005b806108565762ffffff19915050610867565b5050606083811b8317901b811760181b5b9392505050565b6060600061087b866110df565b9150506000610889866110df565b9150506000610897866110df565b91505060006108a5866110df565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e20746865602082015274040ecd2caee5c40a6d8d2c6ca40d2e640c2e84060f605b1b818301526001600160d01b031960d098891b811660558301526e040eed2e8d040d8cadccee8d04060f608b1b605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f666673657420306070830152600f60fb1b609083015295881b861660918201526097810196909652951b90921660a68401525050601760f91b60ac8201528151808203608d01815260ad90910190915295945050505050565b6000806109ae8360781c6001600160601b031690565b6001600160601b0316905060006109ce8460181c6001600160601b031690565b6001600160601b03169050604051602081838560025afa5060208160208360025afa5051949350505050565b600080610a108360781c6001600160601b031690565b6001600160601b031690506000610a308460181c6001600160601b031690565b6001600160601b03169091209392505050565b6000610a4f8383610ff8565b1590505b92915050565b6000610a6b60048360ff16901c610dd0565b60ff161760081b62ffff0016610a8082610dd0565b60ff1617919050565b600060ff8216610a9b57506000610867565b610aae8460181c6001600160601b031690565b6001600160601b0316610ac48460ff85166113b0565b1115610b2857610b0f610ae08560781c6001600160601b031690565b6001600160601b0316610afc8660181c6001600160601b031690565b6001600160601b0316858560ff1661086e565b60405162461bcd60e51b81526004016108169190611a19565b60208260ff161115610ba25760405162461bcd60e51b815260206004820152603a60248201527f54797065644d656d566965772f696e646578202d20417474656d70746564207460448201527f6f20696e646578206d6f7265207468616e2033322062797465730000000000006064820152608401610816565b600882026000610bbb8660781c6001600160601b031690565b6001600160601b031690506000600160ff1b60001984011d91909501511695945050505050565b600062ffffff1983811690831614806108675750610c008260d81c90565b64ffffffffff16610c118460d81c90565b64ffffffffff161480156108675750610c29826109fa565b610c32846109fa565b149392505050565b6000610c4860606002611adf565b60ff1682841862ffffff1916901c62ffffff1916600060181b14905092915050565b6000610c768260d81c90565b64ffffffffff1664ffffffffff1415610c9157506000610822565b6000610c9c83610d8f565b60405110199392505050565b6040516000906108676107be8483611405565b60006020610ce66020610cd78560181c6001600160601b031690565b6001600160601b0316906113b0565b610a539190611aa0565b815160009060208401610d0b64ffffffffff85168284610827565b95945050505050565b600080610d2a8660781c6001600160601b031690565b6001600160601b03169050610d3e86610d8f565b610d5285610d4c84896113b0565b906113b0565b1115610d655762ffffff19915050610d87565b610d6f81866113b0565b9050610d838364ffffffffff168286610827565b9150505b949350505050565b6000610da48260181c6001600160601b031690565b610db78360781c6001600160601b031690565b610dc19190611a75565b6001600160601b031692915050565b600060f08083179060ff82161415610dec576030915050610822565b8060ff1660f11415610e02576031915050610822565b8060ff1660f21415610e18576032915050610822565b8060ff1660f31415610e2e576033915050610822565b8060ff1660f41415610e44576034915050610822565b8060ff1660f51415610e5a576035915050610822565b8060ff1660f61415610e70576036915050610822565b8060ff1660f71415610e86576037915050610822565b8060ff1660f81415610e9c576038915050610822565b8060ff1660f91415610eb2576039915050610822565b8060ff1660fa1415610ec8576061915050610822565b8060ff1660fb1415610ede576062915050610822565b8060ff1660fc1415610ef4576063915050610822565b8060ff1660fd1415610f0a576064915050610822565b8060ff1660fe1415610f20576065915050610822565b8060ff1660ff1415610f36576066915050610822565b50919050565b6000610d8784610f6885610f598860181c6001600160601b031690565b6001600160601b0316906114af565b8585610d14565b600061086783836014611329565b600080610f938360781c6001600160601b031690565b6001600160601b031690506000610fb38460181c6001600160601b031690565b6001600160601b03169050604051602081838560025afa5060208160208360035afa50600c0151949350505050565b6000610fed82610cbb565b610a53906020611ac0565b600061100d8260781c6001600160601b031690565b6001600160601b03166110298460781c6001600160601b031690565b6001600160601b0316148015611074575061104d8260181c6001600160601b031690565b6001600160601b03166110698460181c6001600160601b031690565b6001600160601b0316145b806108675750610c29826109fa565b604051606090600061109f8461109a846020611a5d565b611405565b905060006110b68260181c6001600160601b031690565b6001600160601b0316905060006110cc83610fe2565b9184525082016020016040525092915050565b600080601f5b600f8160ff16111561113d5760006110fe826008611adf565b60ff1685901c905061110f81610a59565b61ffff16841793508160ff1660101461112a57601084901b93505b50611136600182611b1f565b90506110e5565b50600f5b60ff8160ff16101561119957600061115a826008611adf565b60ff1685901c905061116b81610a59565b61ffff16831792508160ff1660001461118657601083901b92505b50611192600182611b1f565b9050611141565b50915091565b60006111ab8383611306565b6112715760006111ca6111be8560d81c90565b64ffffffffff166110df565b91505060006111df8464ffffffffff166110df565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201526001600160b01b031960b086811b8216603d8401526c05c408af0e0cac6e8cac84060f609b1b604784015283901b16605482015290925060009150605e0160405160208183030381529060405290508060405162461bcd60e51b81526004016108169190611a19565b5090919050565b6000610a4f8383610be2565b606060008061129c8460181c6001600160601b031690565b60405193508392506001600160601b031690506112c3846112be846020611a5d565b611505565b508181016020016040529052919050565b6000610d878460008585610d14565b6000610d876103c8858585610a89565b6040516000906108676103468483611405565b60008164ffffffffff1661131a8460d81c90565b64ffffffffff16149392505050565b6000611336826020611b1f565b611341906008611adf565b60ff1661134f858585610a89565b901c949350505050565b60008061136f8360781c6001600160601b031690565b6001600160601b03169050600061138f8460181c6001600160601b031690565b6001600160601b03169050604051602081838560025afa5051949350505050565b6000826113bd8382611a5d565b9150811015610a535760405162461bcd60e51b815260206004820152601460248201527364732d6d6174682d6164642d6f766572666c6f7760601b6044820152606401610816565b6000604051828111156114185760206060fd5b506000805b845181101561149f57600085828151811061144857634e487b7160e01b600052603260045260246000fd5b602002602001015190506114628184876112be9190611a5d565b506114768160181c6001600160601b031690565b611489906001600160601b031684611a5d565b925050808061149790611b42565b91505061141d565b50606083901b811760181b610d87565b6000826114bc8382611b08565b9150811115610a535760405162461bcd60e51b815260206004820152601560248201527464732d6d6174682d7375622d756e646572666c6f7760581b6044820152606401610816565b600062ffffff19808416141561156e5760405162461bcd60e51b815260206004820152602860248201527f54797065644d656d566965772f636f7079546f202d204e756c6c20706f696e7460448201526732b9103232b932b360c11b6064820152608401610816565b61157783610c6a565b6115d75760405162461bcd60e51b815260206004820152602b60248201527f54797065644d656d566965772f636f7079546f202d20496e76616c696420706f60448201526a34b73a32b9103232b932b360a91b6064820152608401610816565b60006115ec8460181c6001600160601b031690565b6001600160601b03169050600061160c8560781c6001600160601b031690565b6001600160601b03169050600060405190508481111561162c5760206060fd5b8285848460045afa5061165d6116428760d81c90565b64ffffffffff60601b606091821b168717901b841760181b90565b9695505050505050565b803562ffffff198116811461082257600080fd5b803564ffffffffff8116811461082257600080fd5b803560ff8116811461082257600080fd5b600060208083850312156116b3578182fd5b823567ffffffffffffffff808211156116ca578384fd5b818501915085601f8301126116dd578384fd5b8135818111156116ef576116ef611b73565b83810291506116ff848301611a2c565b8181528481019084860184860187018a1015611719578788fd5b8795505b838610156117425761172e81611667565b83526001959095019491860191860161171d565b5098975050505050505050565b600060208284031215611760578081fd5b61086782611667565b6000806040838503121561177b578081fd5b61178483611667565b915061179260208401611667565b90509250929050565b600080604083850312156117ad578182fd5b6117b683611667565b946020939093013593505050565b600080600080608085870312156117d9578182fd5b6117e285611667565b935060208501359250604085013591506117fe6060860161167b565b905092959194509250565b60008060006060848603121561181d578283fd5b61182684611667565b92506020840135915061183b6040850161167b565b90509250925092565b600080600060608486031215611858578283fd5b61186184611667565b92506020840135915061183b60408501611690565b60008060408385031215611888578182fd5b61189183611667565b91506117926020840161167b565b600080604083850312156118b1578182fd5b823567ffffffffffffffff808211156118c8578384fd5b818501915085601f8301126118db578384fd5b81356020828211156118ef576118ef611b73565b611901601f8301601f19168201611a2c565b92508183528781838601011115611916578586fd5b81818501828501378581838501015282955061193381880161167b565b9450505050509250929050565b600060208284031215611951578081fd5b5035919050565b60008060006060848603121561196c578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215611998578384fd5b5050823594602084013594506040840135936060013592509050565b6000602082840312156119c5578081fd5b61086782611690565b60008151808452815b818110156119f3576020818501810151868301820152016119d7565b81811115611a045782602083870101525b50601f01601f19169290920160200192915050565b60006020825261086760208301846119ce565b604051601f8201601f1916810167ffffffffffffffff81118282101715611a5557611a55611b73565b604052919050565b60008219821115611a7057611a70611b5d565b500190565b60006001600160601b03808316818516808303821115611a9757611a97611b5d565b01949350505050565b600082611abb57634e487b7160e01b81526012600452602481fd5b500490565b6000816000190483118215151615611ada57611ada611b5d565b500290565b600060ff821660ff84168160ff0481118215151615611b0057611b00611b5d565b029392505050565b600082821015611b1a57611b1a611b5d565b500390565b600060ff821660ff841680821015611b3957611b39611b5d565b90039392505050565b6000600019821415611b5657611b56611b5d565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fdfea2646970667358221220a4af0397e34738933b1d9f376a68d8faf766b3eae4c09cc3757e61135cb8982464736f6c63430008020033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106102685760003560e01c806372cfe90b11610150578063a60a7282116100cd578063c197cfef11610091578063c197cfef14610759578063c90bb5531461076c578063d18266c91461077f578063da98f02b14610792578063f26be3fc146107a5578063f6e8b9d5146107b057610268565b8063a60a7282146106f3578063afc9fe5814610706578063b367971d14610720578063bac4b38d14610733578063bead12041461074657610268565b80639cb855cb116101145780639cb855cb146106755780639f07152514610692578063a0f20eb1146106a5578063a13c2243146106b8578063a1ce10e6146106cb57610268565b806372cfe90b146105ce578063744fa02b146105e1578063758a15c814610606578063829170301461061957806383d06a941461064457610268565b80633acd9d3e116101e95780635145c996116101ad5780635145c9961461053b5780635938773e1461054e5780635aacd0ba1461056957806365acccba1461059e57806369f994a6146105a85780636e7ece2e146105bb57610268565b80633acd9d3e146103a757806340bec88f146103ba578063493832e214610502578063497c8365146105155780634afc8c941461052857610268565b80631fdbc48c116102305780631fdbc48c1461031757806323509a1d14610338578063287ef85a1461034b5780632c2e8d7d1461036e57806338c17a3f1461039457610268565b8063018319a11461026d57806308d5a7271461029a5780630b9e1db6146102ba57806315d823f2146102e45780631ab11e8a146102f7575b600080fd5b61028061027b36600461174f565b6107c3565b60405162ffffff1990911681526020015b60405180910390f35b6102806102a8366004611876565b60d81b6001600160d81b039091161790565b6102ce6102c836600461174f565b60d81c90565b60405164ffffffffff9091168152602001610291565b6102806102f2366004611958565b610827565b61030a610305366004611983565b61086e565b6040516102919190611a19565b61032a61032536600461174f565b610998565b604051908152602001610291565b61032a61034636600461174f565b6109fa565b61035e610359366004611769565b610a43565b6040519015158152602001610291565b61038161037c3660046119b4565b610a59565b60405161ffff9091168152602001610291565b61032a6103a2366004611844565b610a89565b61035e6103b5366004611769565b610be2565b61032a6103c8366004611940565b600881811c7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff167fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff009290911b9190911617601081811c7dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff167fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff00009290911b9190911617602081811c7bffffffff00000000ffffffff00000000ffffffff00000000ffffffff167fffffffff00000000ffffffff00000000ffffffff00000000ffffffff000000009290911b9190911617604081811c77ffffffffffffffff0000000000000000ffffffffffffffff1677ffffffffffffffff0000000000000000ffffffffffffffff199290911b9190911617608081811c91901b1790565b61035e610510366004611769565b610c3a565b61035e61052336600461174f565b610c6a565b61032a6105363660046116a1565b610ca8565b61032a61054936600461174f565b610cbb565b61035e61055c36600461174f565b62ffffff19908116141590565b61058661057736600461174f565b60781c6001600160601b031690565b6040516001600160601b039091168152602001610291565b62ffffff19610280565b6102806105b636600461189f565b610cf0565b6102806105c93660046117c4565b610d14565b61032a6105dc36600461174f565b610d8f565b6105f46105ef3660046119b4565b610dd0565b60405160ff9091168152602001610291565b610280610614366004611809565b610f3c565b61062c61062736600461179b565b610f6f565b6040516001600160a01b039091168152602001610291565b61065761065236600461174f565b610f7d565b6040516bffffffffffffffffffffffff199091168152602001610291565b61058661068336600461174f565b60181c6001600160601b031690565b61032a6106a036600461174f565b610fe2565b61035e6106b3366004611769565b610ff8565b61030a6106c63660046116a1565b611083565b6106de6106d9366004611940565b6110df565b60408051928352602083019190915201610291565b610280610701366004611876565b61119f565b61035e61071436600461174f565b62ffffff199081161490565b61035e61072e366004611769565b611278565b61030a61074136600461174f565b611284565b610280610754366004611809565b6112d4565b61032a610767366004611844565b6112e3565b61032a61077a3660046116a1565b6112f3565b61035e61078d366004611876565b611306565b61032a6107a0366004611844565b611329565b61028062ffffff1981565b61032a6107be36600461174f565b611359565b60006107ce82610c6a565b61081f5760405162461bcd60e51b815260206004820152601960248201527f56616c696469747920617373657274696f6e206661696c65640000000000000060448201526064015b60405180910390fd5b50805b919050565b60008061083484846113b0565b9050604051811115610844575060005b806108565762ffffff19915050610867565b5050606083811b8317901b811760181b5b9392505050565b6060600061087b866110df565b9150506000610889866110df565b9150506000610897866110df565b91505060006108a5866110df565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e20746865602082015274040ecd2caee5c40a6d8d2c6ca40d2e640c2e84060f605b1b818301526001600160d01b031960d098891b811660558301526e040eed2e8d040d8cadccee8d04060f608b1b605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f666673657420306070830152600f60fb1b609083015295881b861660918201526097810196909652951b90921660a68401525050601760f91b60ac8201528151808203608d01815260ad90910190915295945050505050565b6000806109ae8360781c6001600160601b031690565b6001600160601b0316905060006109ce8460181c6001600160601b031690565b6001600160601b03169050604051602081838560025afa5060208160208360025afa5051949350505050565b600080610a108360781c6001600160601b031690565b6001600160601b031690506000610a308460181c6001600160601b031690565b6001600160601b03169091209392505050565b6000610a4f8383610ff8565b1590505b92915050565b6000610a6b60048360ff16901c610dd0565b60ff161760081b62ffff0016610a8082610dd0565b60ff1617919050565b600060ff8216610a9b57506000610867565b610aae8460181c6001600160601b031690565b6001600160601b0316610ac48460ff85166113b0565b1115610b2857610b0f610ae08560781c6001600160601b031690565b6001600160601b0316610afc8660181c6001600160601b031690565b6001600160601b0316858560ff1661086e565b60405162461bcd60e51b81526004016108169190611a19565b60208260ff161115610ba25760405162461bcd60e51b815260206004820152603a60248201527f54797065644d656d566965772f696e646578202d20417474656d70746564207460448201527f6f20696e646578206d6f7265207468616e2033322062797465730000000000006064820152608401610816565b600882026000610bbb8660781c6001600160601b031690565b6001600160601b031690506000600160ff1b60001984011d91909501511695945050505050565b600062ffffff1983811690831614806108675750610c008260d81c90565b64ffffffffff16610c118460d81c90565b64ffffffffff161480156108675750610c29826109fa565b610c32846109fa565b149392505050565b6000610c4860606002611adf565b60ff1682841862ffffff1916901c62ffffff1916600060181b14905092915050565b6000610c768260d81c90565b64ffffffffff1664ffffffffff1415610c9157506000610822565b6000610c9c83610d8f565b60405110199392505050565b6040516000906108676107be8483611405565b60006020610ce66020610cd78560181c6001600160601b031690565b6001600160601b0316906113b0565b610a539190611aa0565b815160009060208401610d0b64ffffffffff85168284610827565b95945050505050565b600080610d2a8660781c6001600160601b031690565b6001600160601b03169050610d3e86610d8f565b610d5285610d4c84896113b0565b906113b0565b1115610d655762ffffff19915050610d87565b610d6f81866113b0565b9050610d838364ffffffffff168286610827565b9150505b949350505050565b6000610da48260181c6001600160601b031690565b610db78360781c6001600160601b031690565b610dc19190611a75565b6001600160601b031692915050565b600060f08083179060ff82161415610dec576030915050610822565b8060ff1660f11415610e02576031915050610822565b8060ff1660f21415610e18576032915050610822565b8060ff1660f31415610e2e576033915050610822565b8060ff1660f41415610e44576034915050610822565b8060ff1660f51415610e5a576035915050610822565b8060ff1660f61415610e70576036915050610822565b8060ff1660f71415610e86576037915050610822565b8060ff1660f81415610e9c576038915050610822565b8060ff1660f91415610eb2576039915050610822565b8060ff1660fa1415610ec8576061915050610822565b8060ff1660fb1415610ede576062915050610822565b8060ff1660fc1415610ef4576063915050610822565b8060ff1660fd1415610f0a576064915050610822565b8060ff1660fe1415610f20576065915050610822565b8060ff1660ff1415610f36576066915050610822565b50919050565b6000610d8784610f6885610f598860181c6001600160601b031690565b6001600160601b0316906114af565b8585610d14565b600061086783836014611329565b600080610f938360781c6001600160601b031690565b6001600160601b031690506000610fb38460181c6001600160601b031690565b6001600160601b03169050604051602081838560025afa5060208160208360035afa50600c0151949350505050565b6000610fed82610cbb565b610a53906020611ac0565b600061100d8260781c6001600160601b031690565b6001600160601b03166110298460781c6001600160601b031690565b6001600160601b0316148015611074575061104d8260181c6001600160601b031690565b6001600160601b03166110698460181c6001600160601b031690565b6001600160601b0316145b806108675750610c29826109fa565b604051606090600061109f8461109a846020611a5d565b611405565b905060006110b68260181c6001600160601b031690565b6001600160601b0316905060006110cc83610fe2565b9184525082016020016040525092915050565b600080601f5b600f8160ff16111561113d5760006110fe826008611adf565b60ff1685901c905061110f81610a59565b61ffff16841793508160ff1660101461112a57601084901b93505b50611136600182611b1f565b90506110e5565b50600f5b60ff8160ff16101561119957600061115a826008611adf565b60ff1685901c905061116b81610a59565b61ffff16831792508160ff1660001461118657601083901b92505b50611192600182611b1f565b9050611141565b50915091565b60006111ab8383611306565b6112715760006111ca6111be8560d81c90565b64ffffffffff166110df565b91505060006111df8464ffffffffff166110df565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201526001600160b01b031960b086811b8216603d8401526c05c408af0e0cac6e8cac84060f609b1b604784015283901b16605482015290925060009150605e0160405160208183030381529060405290508060405162461bcd60e51b81526004016108169190611a19565b5090919050565b6000610a4f8383610be2565b606060008061129c8460181c6001600160601b031690565b60405193508392506001600160601b031690506112c3846112be846020611a5d565b611505565b508181016020016040529052919050565b6000610d878460008585610d14565b6000610d876103c8858585610a89565b6040516000906108676103468483611405565b60008164ffffffffff1661131a8460d81c90565b64ffffffffff16149392505050565b6000611336826020611b1f565b611341906008611adf565b60ff1661134f858585610a89565b901c949350505050565b60008061136f8360781c6001600160601b031690565b6001600160601b03169050600061138f8460181c6001600160601b031690565b6001600160601b03169050604051602081838560025afa5051949350505050565b6000826113bd8382611a5d565b9150811015610a535760405162461bcd60e51b815260206004820152601460248201527364732d6d6174682d6164642d6f766572666c6f7760601b6044820152606401610816565b6000604051828111156114185760206060fd5b506000805b845181101561149f57600085828151811061144857634e487b7160e01b600052603260045260246000fd5b602002602001015190506114628184876112be9190611a5d565b506114768160181c6001600160601b031690565b611489906001600160601b031684611a5d565b925050808061149790611b42565b91505061141d565b50606083901b811760181b610d87565b6000826114bc8382611b08565b9150811115610a535760405162461bcd60e51b815260206004820152601560248201527464732d6d6174682d7375622d756e646572666c6f7760581b6044820152606401610816565b600062ffffff19808416141561156e5760405162461bcd60e51b815260206004820152602860248201527f54797065644d656d566965772f636f7079546f202d204e756c6c20706f696e7460448201526732b9103232b932b360c11b6064820152608401610816565b61157783610c6a565b6115d75760405162461bcd60e51b815260206004820152602b60248201527f54797065644d656d566965772f636f7079546f202d20496e76616c696420706f60448201526a34b73a32b9103232b932b360a91b6064820152608401610816565b60006115ec8460181c6001600160601b031690565b6001600160601b03169050600061160c8560781c6001600160601b031690565b6001600160601b03169050600060405190508481111561162c5760206060fd5b8285848460045afa5061165d6116428760d81c90565b64ffffffffff60601b606091821b168717901b841760181b90565b9695505050505050565b803562ffffff198116811461082257600080fd5b803564ffffffffff8116811461082257600080fd5b803560ff8116811461082257600080fd5b600060208083850312156116b3578182fd5b823567ffffffffffffffff808211156116ca578384fd5b818501915085601f8301126116dd578384fd5b8135818111156116ef576116ef611b73565b83810291506116ff848301611a2c565b8181528481019084860184860187018a1015611719578788fd5b8795505b838610156117425761172e81611667565b83526001959095019491860191860161171d565b5098975050505050505050565b600060208284031215611760578081fd5b61086782611667565b6000806040838503121561177b578081fd5b61178483611667565b915061179260208401611667565b90509250929050565b600080604083850312156117ad578182fd5b6117b683611667565b946020939093013593505050565b600080600080608085870312156117d9578182fd5b6117e285611667565b935060208501359250604085013591506117fe6060860161167b565b905092959194509250565b60008060006060848603121561181d578283fd5b61182684611667565b92506020840135915061183b6040850161167b565b90509250925092565b600080600060608486031215611858578283fd5b61186184611667565b92506020840135915061183b60408501611690565b60008060408385031215611888578182fd5b61189183611667565b91506117926020840161167b565b600080604083850312156118b1578182fd5b823567ffffffffffffffff808211156118c8578384fd5b818501915085601f8301126118db578384fd5b81356020828211156118ef576118ef611b73565b611901601f8301601f19168201611a2c565b92508183528781838601011115611916578586fd5b81818501828501378581838501015282955061193381880161167b565b9450505050509250929050565b600060208284031215611951578081fd5b5035919050565b60008060006060848603121561196c578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215611998578384fd5b5050823594602084013594506040840135936060013592509050565b6000602082840312156119c5578081fd5b61086782611690565b60008151808452815b818110156119f3576020818501810151868301820152016119d7565b81811115611a045782602083870101525b50601f01601f19169290920160200192915050565b60006020825261086760208301846119ce565b604051601f8201601f1916810167ffffffffffffffff81118282101715611a5557611a55611b73565b604052919050565b60008219821115611a7057611a70611b5d565b500190565b60006001600160601b03808316818516808303821115611a9757611a97611b5d565b01949350505050565b600082611abb57634e487b7160e01b81526012600452602481fd5b500490565b6000816000190483118215151615611ada57611ada611b5d565b500290565b600060ff821660ff84168160ff0481118215151615611b0057611b00611b5d565b029392505050565b600082821015611b1a57611b1a611b5d565b500390565b600060ff821660ff841680821015611b3957611b39611b5d565b90039392505050565b6000600019821415611b5657611b56611b5d565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fdfea2646970667358221220a4af0397e34738933b1d9f376a68d8faf766b3eae4c09cc3757e61135cb8982464736f6c63430008020033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "assertType(bytes29,uint40)": {
        "details": "Returns the view for easy chaining.",
        "params": {
          "_expected": "The expected type",
          "memView": "The view"
        },
        "returns": {
          "_0": "bytes29 - The view with validated type"
        }
      },
      "assertValid(bytes29)": {
        "details": "Returns the view for easy chaining.",
        "params": {
          "memView": "The view"
        },
        "returns": {
          "_0": "bytes29 - The validated view"
        }
      },
      "build(uint256,uint256,uint256)": {
        "details": "Instantiate a new memory view. This should generally not be called                  directly. Prefer `ref` wherever possible.",
        "params": {
          "_len": "The length",
          "_loc": "The memory address",
          "_type": "The type"
        },
        "returns": {
          "newView": "- The new view with the specified type, location and length"
        }
      },
      "byteHex(uint8)": {
        "params": {
          "_b": "The byte"
        },
        "returns": {
          "encoded": "- The hex-encoded byte"
        }
      },
      "castTo(bytes29,uint40)": {
        "params": {
          "_newType": "The new type",
          "memView": "The view"
        },
        "returns": {
          "newView": "- The new view with the specified type"
        }
      },
      "clone(bytes29)": {
        "details": "Shortcuts if the pointers are identical, otherwise compares type and digest.",
        "params": {
          "memView": "The view"
        },
        "returns": {
          "ret": "- The view pointing to the new memory"
        }
      },
      "encodeHex(uint256)": {
        "params": {
          "_b": "The 32 bytes as uint256"
        },
        "returns": {
          "first": "- The top 16 bytes",
          "second": "- The bottom 16 bytes"
        }
      },
      "end(bytes29)": {
        "params": {
          "memView": "The view"
        },
        "returns": {
          "_0": "uint256 - The endpoint of `memView`"
        }
      },
      "equal(bytes29,bytes29)": {
        "details": "Shortcuts if the pointers are identical, otherwise compares type and digest.",
        "params": {
          "left": "The first view",
          "right": "The second view"
        },
        "returns": {
          "_0": "bool - True if the types are the same"
        }
      },
      "footprint(bytes29)": {
        "params": {
          "memView": "The view"
        },
        "returns": {
          "_0": "uint256 - The in-memory footprint of a fresh copy of the view."
        }
      },
      "hash160(bytes29)": {
        "params": {
          "memView": "The pre-image"
        },
        "returns": {
          "digest": "- the Digest"
        }
      },
      "hash256(bytes29)": {
        "params": {
          "memView": "A view of the preimage"
        },
        "returns": {
          "digest": "- the Digest"
        }
      },
      "index(bytes29,uint256,uint8)": {
        "details": "Returns a bytes32 with only the `_bytes` highest bytes set.                  This can be immediately cast to a smaller fixed-length byte array.                  To automatically cast to an integer, use `indexUint`.",
        "params": {
          "_bytes": "The bytes",
          "_index": "The index",
          "memView": "The view"
        },
        "returns": {
          "result": "- The 32 byte result"
        }
      },
      "indexAddress(bytes29,uint256)": {
        "params": {
          "_index": "The index",
          "memView": "The view"
        },
        "returns": {
          "_0": "address - The address"
        }
      },
      "indexErrOverrun(uint256,uint256,uint256,uint256)": {
        "params": {
          "_index": "The index",
          "_len": "The length",
          "_loc": "The memory address",
          "_slice": "The slice where the overrun occurred"
        },
        "returns": {
          "err": "- The err"
        }
      },
      "indexLEUint(bytes29,uint256,uint8)": {
        "params": {
          "_bytes": "The bytes",
          "_index": "The index",
          "memView": "The view"
        },
        "returns": {
          "result": "- The unsigned integer"
        }
      },
      "indexUint(bytes29,uint256,uint8)": {
        "details": "Requires that the view have >= `_bytes` bytes following that index.",
        "params": {
          "_bytes": "The bytes",
          "_index": "The index",
          "memView": "The view"
        },
        "returns": {
          "result": "- The unsigned integer"
        }
      },
      "isNull(bytes29)": {
        "returns": {
          "_0": "bool - True if the view is null"
        }
      },
      "isType(bytes29,uint40)": {
        "params": {
          "_expected": "The expected type",
          "memView": "The view"
        },
        "returns": {
          "_0": "bool - True if the memview is of the expected type"
        }
      },
      "isValid(bytes29)": {
        "details": "We perform this check by examining solidity's unallocated memory                  pointer and ensuring that the view's upper bound is less than that.",
        "params": {
          "memView": "The view"
        },
        "returns": {
          "ret": "- True if the view is valid"
        }
      },
      "join(bytes29[])": {
        "params": {
          "memViews": "The views"
        },
        "returns": {
          "ret": "- The new byte array"
        }
      },
      "joinKeccak(bytes29[])": {
        "params": {
          "memViews": "The views"
        },
        "returns": {
          "_0": "bytes32 - The keccak256 digest"
        }
      },
      "joinSha2(bytes29[])": {
        "params": {
          "memViews": "The views"
        },
        "returns": {
          "_0": "bytes32 - The sha256 digest"
        }
      },
      "keccak(bytes29)": {
        "params": {
          "memView": "The view"
        },
        "returns": {
          "digest": "- The keccak256 hash of the underlying memory"
        }
      },
      "len(bytes29)": {
        "params": {
          "memView": "The view"
        },
        "returns": {
          "_len": "- The length of the view"
        }
      },
      "loc(bytes29)": {
        "params": {
          "memView": "The view"
        },
        "returns": {
          "_loc": "- The memory address"
        }
      },
      "nibbleHex(uint8)": {
        "params": {
          "_b": "The byte"
        },
        "returns": {
          "char": "- The encoded hex character"
        }
      },
      "notEqual(bytes29,bytes29)": {
        "details": "Shortcuts if the pointers are identical, otherwise compares type and digest.",
        "params": {
          "left": "The first view",
          "right": "The second view"
        },
        "returns": {
          "_0": "bool - True if the types are not the same"
        }
      },
      "notNull(bytes29)": {
        "returns": {
          "_0": "bool - True if the view is not null"
        }
      },
      "nullView()": {
        "returns": {
          "_0": "bytes29 - The null view"
        }
      },
      "postfix(bytes29,uint256,uint40)": {
        "params": {
          "_len": "The length",
          "memView": "The view",
          "newType": "The new type"
        },
        "returns": {
          "_0": "bytes29 - The new view"
        }
      },
      "prefix(bytes29,uint256,uint40)": {
        "params": {
          "_len": "The length",
          "memView": "The view",
          "newType": "The new type"
        },
        "returns": {
          "_0": "bytes29 - The new view"
        }
      },
      "ref(bytes,uint40)": {
        "details": "Note that due to Solidity memory representation, it is not possible to                  implement a deref, as the `bytes` type stores its len in memory.",
        "params": {
          "arr": "The byte array",
          "newType": "The type"
        },
        "returns": {
          "_0": "bytes29 - The memory view"
        }
      },
      "reverseUint256(uint256)": {
        "details": "https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel",
        "params": {
          "_b": "The unsigned integer to reverse"
        },
        "returns": {
          "v": "- The reversed value"
        }
      },
      "sameType(bytes29,bytes29)": {
        "params": {
          "left": "The first view",
          "right": "The second view"
        },
        "returns": {
          "_0": "bool - True if the 5-byte type flag is equal"
        }
      },
      "sha2(bytes29)": {
        "details": "We explicitly deallocate memory afterwards.",
        "params": {
          "memView": "The view"
        },
        "returns": {
          "digest": "- The sha2 hash of the underlying memory"
        }
      },
      "slice(bytes29,uint256,uint256,uint40)": {
        "params": {
          "_index": "The start index",
          "_len": "The length",
          "memView": "The view",
          "newType": "The new type"
        },
        "returns": {
          "_0": "bytes29 - The new view"
        }
      },
      "typeOf(bytes29)": {
        "params": {
          "memView": "The memory view"
        },
        "returns": {
          "_type": "- The type associated with the view"
        }
      },
      "untypedEqual(bytes29,bytes29)": {
        "params": {
          "left": "The first view",
          "right": "The second view"
        },
        "returns": {
          "_0": "bool - True if the underlying memory is equal"
        }
      },
      "untypedNotEqual(bytes29,bytes29)": {
        "params": {
          "left": "The first view",
          "right": "The second view"
        },
        "returns": {
          "_0": "bool - False if the underlying memory is equal"
        }
      },
      "words(bytes29)": {
        "params": {
          "memView": "The view"
        },
        "returns": {
          "_0": "uint256 - The number of memory words"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "assertType(bytes29,uint40)": {
        "notice": "Require that a typed memory view has a specific type."
      },
      "assertValid(bytes29)": {
        "notice": "Require that a typed memory view be valid."
      },
      "build(uint256,uint256,uint256)": {
        "notice": "Instantiate a new memory view. This should generally not be called                  directly. Prefer `ref` wherever possible."
      },
      "byteHex(uint8)": {
        "notice": "Returns a uint16 containing the hex-encoded byte.              `the first 8 bits of encoded is the nibbleHex of top 4 bits of _b`              `the second 8 bits of encoded is the nibbleHex of lower 4 bits of _b`"
      },
      "castTo(bytes29,uint40)": {
        "notice": "Return an identical view with a different type."
      },
      "clone(bytes29)": {
        "notice": "Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to                  the new memory"
      },
      "encodeHex(uint256)": {
        "notice": "Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.              `second` contains the encoded lower 16 bytes."
      },
      "end(bytes29)": {
        "notice": "Returns the endpoint of `memView`."
      },
      "equal(bytes29,bytes29)": {
        "notice": "Compares type equality."
      },
      "footprint(bytes29)": {
        "notice": "The in-memory footprint of a fresh copy of the view."
      },
      "hash160(bytes29)": {
        "notice": "Implements bitcoin's hash160 (rmd160(sha2()))"
      },
      "hash256(bytes29)": {
        "notice": "Implements bitcoin's hash256 (double sha2)"
      },
      "index(bytes29,uint256,uint8)": {
        "notice": "Load up to 32 bytes from the view onto the stack."
      },
      "indexAddress(bytes29,uint256)": {
        "notice": "Parse an address from the view at `_index`. Requires that the view have >= 20 bytes                  following that index."
      },
      "indexErrOverrun(uint256,uint256,uint256,uint256)": {
        "notice": "Construct an error message for an indexing overrun."
      },
      "indexLEUint(bytes29,uint256,uint8)": {
        "notice": "Parse an unsigned integer from LE bytes."
      },
      "indexUint(bytes29,uint256,uint8)": {
        "notice": "Parse an unsigned integer from the view at `_index`."
      },
      "isNull(bytes29)": {
        "notice": "Check if the view is null."
      },
      "isType(bytes29,uint40)": {
        "notice": "Return true if the memview is of the expected type. Otherwise false."
      },
      "isValid(bytes29)": {
        "notice": "Check if the view is of a valid type and points to a valid location                  in memory."
      },
      "join(bytes29[])": {
        "notice": "copies all views, joins them into a new bytearray."
      },
      "joinKeccak(bytes29[])": {
        "notice": "Produce the keccak256 digest of the concatenated contents of multiple views."
      },
      "joinSha2(bytes29[])": {
        "notice": "Produce the sha256 digest of the concatenated contents of multiple views."
      },
      "keccak(bytes29)": {
        "notice": "Return the keccak256 hash of the underlying memory"
      },
      "len(bytes29)": {
        "notice": "The number of bytes of the view."
      },
      "loc(bytes29)": {
        "notice": "Return the memory address of the underlying bytes."
      },
      "nibbleHex(uint8)": {
        "notice": "Returns the encoded hex character that represents the lower 4 bits of the argument."
      },
      "notEqual(bytes29,bytes29)": {
        "notice": "Compares type inequality."
      },
      "notNull(bytes29)": {
        "notice": "Check if the view is not null."
      },
      "nullView()": {
        "notice": "Return the null view."
      },
      "postfix(bytes29,uint256,uint40)": {
        "notice": "Shortcut to `slice`. Gets a view representing the last `_len` byte."
      },
      "prefix(bytes29,uint256,uint40)": {
        "notice": "Shortcut to `slice`. Gets a view representing the first `_len` bytes."
      },
      "ref(bytes,uint40)": {
        "notice": "Instantiate a memory view from a byte array."
      },
      "reverseUint256(uint256)": {
        "notice": "Changes the endianness of a uint256."
      },
      "sameType(bytes29,bytes29)": {
        "notice": "Optimized type comparison. Checks that the 5-byte type flag is equal."
      },
      "sha2(bytes29)": {
        "notice": "Return the sha2 digest of the underlying memory."
      },
      "slice(bytes29,uint256,uint256,uint40)": {
        "notice": "Safe slicing without memory modification."
      },
      "typeOf(bytes29)": {
        "notice": "Return the associated type information."
      },
      "untypedEqual(bytes29,bytes29)": {
        "notice": "Return true if the underlying memory is equal. Else false."
      },
      "untypedNotEqual(bytes29,bytes29)": {
        "notice": "Return false if the underlying memory is equal. Else true."
      },
      "words(bytes29)": {
        "notice": "The number of memory words this memory view occupies, rounded up."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}