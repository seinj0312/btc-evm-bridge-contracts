{
  "address": "0x393ACCdd5D933D2b8DD87e81675740a84c3dc9B8",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_exchangeRouter",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_bitcoinTeleporter",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_ccTransferRouter",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "inputToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "outputToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "inputAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "outputAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "speed",
          "type": "uint256"
        }
      ],
      "name": "CCExchange",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "WAVAX",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "bitcoinTeleporter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "version",
          "type": "bytes4"
        },
        {
          "internalType": "bytes",
          "name": "vin",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "vout",
          "type": "bytes"
        },
        {
          "internalType": "bytes4",
          "name": "locktime",
          "type": "bytes4"
        },
        {
          "internalType": "uint256",
          "name": "blockNumber",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "intermediateNodes",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "payWithTDT",
          "type": "bool"
        }
      ],
      "name": "ccExchange",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ccTransferRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        }
      ],
      "name": "changeOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "exchangeRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountOutMin",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "path",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "instantCCExchangeWithPermit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "instantRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "liquidityPoolFactory",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_bitcoinTeleporter",
          "type": "address"
        }
      ],
      "name": "setBitcoinTeleporter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_ccTransferRouter",
          "type": "address"
        }
      ],
      "name": "setCCTransferRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_exchangeRouter",
          "type": "address"
        }
      ],
      "name": "setExchangeRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_instantRouter",
          "type": "address"
        }
      ],
      "name": "setInstantRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_wrappedBitcoin",
          "type": "address"
        }
      ],
      "name": "setWrappedBitcoin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "wrappedBitcoin",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xf011492c58346fc74c7b9d72205b14add6c160c45fe733524b2e97293be9f572",
  "receipt": {
    "to": null,
    "from": "0x5364E3557572bd5D5903C0e9C21BE359F2Eac1dA",
    "contractAddress": "0x393ACCdd5D933D2b8DD87e81675740a84c3dc9B8",
    "transactionIndex": 1,
    "gasUsed": "2974932",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x62bf6006546f4f6dcca67eda4781d50bdc1ebf054aa267152832280793e60f57",
    "transactionHash": "0xf011492c58346fc74c7b9d72205b14add6c160c45fe733524b2e97293be9f572",
    "logs": [],
    "blockNumber": 12331326,
    "cumulativeGasUsed": "2995932",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x668D83b86A4A599c144B1124455C9bb6b7653fDF",
    "0xD57a0FF38FE9b8803904D0F79f44792bd79524C6",
    "0x4a34FE2aFD275d95C8971c54e8E4deFFD9A85912"
  ],
  "numDeployments": 1,
  "solcInputHash": "b766d894e7507eaf09e41e8de1c94935",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exchangeRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bitcoinTeleporter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ccTransferRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"speed\",\"type\":\"uint256\"}],\"name\":\"CCExchange\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WAVAX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bitcoinTeleporter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"version\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"vin\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"vout\",\"type\":\"bytes\"},{\"internalType\":\"bytes4\",\"name\":\"locktime\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"intermediateNodes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"payWithTDT\",\"type\":\"bool\"}],\"name\":\"ccExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ccTransferRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"instantCCExchangeWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"instantRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityPoolFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bitcoinTeleporter\",\"type\":\"address\"}],\"name\":\"setBitcoinTeleporter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ccTransferRouter\",\"type\":\"address\"}],\"name\":\"setCCTransferRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exchangeRouter\",\"type\":\"address\"}],\"name\":\"setExchangeRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_instantRouter\",\"type\":\"address\"}],\"name\":\"setInstantRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wrappedBitcoin\",\"type\":\"address\"}],\"name\":\"setWrappedBitcoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedBitcoin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/routers/CCExchangeRouter.sol\":\"CCExchangeRouter\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/erc20/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\ninterface IERC20 {\\n    // events\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    // read-only functions\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    // state-changing functions\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xbfce47b32957e65d24a0a087221880a77cde7bd13f0bb3af913cb9b0877ddad5\"},\"contracts/erc20/interfaces/IWrappedToken.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity ^0.7.6;\\n\\nimport './IERC20.sol';\\n\\ninterface IWrappedToken is IERC20 {\\n  // events\\n  event Mint(address indexed to, uint value);\\n  event Burn(address indexed to, uint value);\\n  // read-only functions\\n  function CCTransferRouter() external view returns(address);\\n  // state-changing functions\\n  function mint(address receiver, uint amount) external returns(bool);\\n  function burn(uint256 amount) external;\\n  function mintTestToken() external;\\n\\n}\",\"keccak256\":\"0x6b71fe630cb15f15e9acb388070c5d0a67b630dddb9ab18731388403a3846675\"},\"contracts/libraries/BitcoinTxParser.sol\":{\"content\":\"pragma solidity 0.7.6;\\n\\nimport \\\"./TypedMemView.sol\\\";\\nimport \\\"./ViewBTC.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n// a library for parsing bitcoin transactions\\n\\nlibrary BitcoinTxParser {\\n\\n    using TypedMemView for bytes;\\n    using TypedMemView for bytes29;\\n    using ViewBTC for bytes29;\\n\\n    function parseAmountForP2SH (bytes memory vout, address desiredRecipient) internal returns(uint64, bytes memory) {\\n        bytes29 voutView = vout.ref(0).tryAsVout();\\n        bytes29 output;\\n        uint64 bitcoinAmount;\\n        bytes29 scriptPubkey;\\n        bytes29 _arbitraryData;\\n        address bitcoinRecipient;\\n        bytes memory arbitraryData;\\n        uint numberOfOutputs = uint256(ViewBTC.indexCompactInt(voutView, 0));\\n        for(uint index = 0; index < numberOfOutputs; index++){\\n            output = ViewBTC.indexVout(voutView, index);\\n            scriptPubkey = ViewBTC.scriptPubkey(output);\\n            _arbitraryData = ViewBTC.opReturnPayload(scriptPubkey);\\n            // check whether the output is an arbitarary data or not\\n            if(_arbitraryData == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\\n                // output is not an arbitrary data\\n                // indexAddress starts with 3, because the first 2 bytes are opcode.\\n                bitcoinRecipient = scriptPubkey.indexAddress(3);\\n                if (bitcoinRecipient == desiredRecipient) {\\n                    bitcoinAmount = ViewBTC.value(output); // number of btc that user locked\\n                }\\n            } else {\\n                // output is an arbitrary data\\n                arbitraryData = _arbitraryData.clone(); // bytes29.clone() returns the whole bytes array\\n            }\\n        }\\n        // console.log(value);\\n        // console.logBytes(requestData);\\n        return (bitcoinAmount, arbitraryData);\\n    }\\n\\n        function parseAmountForP2PK (\\n            bytes memory vout,\\n            address desiredRecipient\\n        ) internal returns(uint64, bytes memory) {\\n        bytes29 voutView = vout.ref(0).tryAsVout();\\n        bytes29 output;\\n        uint64 bitcoinAmount;\\n        bytes29 scriptPubkey;\\n        bytes29 _arbitraryData;\\n        address bitcoinRecipient;\\n        bytes memory arbitraryData;\\n        uint numberOfOutputs = uint256(ViewBTC.indexCompactInt(voutView, 0));\\n        for (uint index = 0; index < numberOfOutputs; index++) {\\n            output = ViewBTC.indexVout(voutView, index);\\n            scriptPubkey = ViewBTC.scriptPubkey(output);\\n            _arbitraryData = ViewBTC.opReturnPayload(scriptPubkey);\\n            // check whether the output is an arbitarary data or not\\n            if(_arbitraryData == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\\n                // output is not an arbitrary data\\n                if (scriptPubkey.len() == 26) {\\n                    bitcoinRecipient = scriptPubkey.indexAddress(4);\\n                }\\n                if (scriptPubkey.len() == 23) {\\n                    bitcoinRecipient = scriptPubkey.indexAddress(3);\\n                }\\n                if (bitcoinRecipient == desiredRecipient) {\\n                    bitcoinAmount = ViewBTC.value(output); // number of btc that user locked\\n                }\\n            } else {\\n                // output is an arbitrary data\\n                arbitraryData = _arbitraryData.clone(); // bytes29.clone() returns the whole bytes array\\n            }\\n        }\\n        // console.log(value);\\n        // console.logBytes(requestData);\\n        return (bitcoinAmount, arbitraryData);\\n    }\\n    \\n    function parseRecipientAddress(bytes memory arbitraryData) internal returns (address parsedValue){\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 0, 19);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 20))\\n        }\\n        // console.log(\\\"parseRecipientAddress\\\", parsedValue);\\n    }\\n\\n    function parseTeleporterFee(bytes memory arbitraryData) internal returns (uint64 parsedValue){\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 20, 27);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 8))\\n        }\\n        // console.log(\\\"parseTeleporterFee\\\", parsedValue);\\n    }\\n\\n    function parseIsExchange(bytes memory arbitraryData) internal returns (bool parsedValue){\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 28, 28);\\n        bytes1 zero = 0x00;\\n        if (slicedBytes[0] == zero) {\\n            parsedValue = false;\\n        } else {\\n            parsedValue = true;\\n        }\\n        // console.log(\\\"parseIsExchange\\\", parsedValue);\\n    }\\n\\n    function parseSpeed(bytes memory arbitraryData) internal returns (uint8 parsedValue){\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 29, 29);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 1))\\n        }\\n        // console.log(\\\"parseSpeed\\\", parsedValue);\\n    }\\n\\n    function parseExchangeToken(bytes memory arbitraryData) internal returns (address parsedValue){\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 30, 49);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 20))\\n        }\\n        // console.log(\\\"parseExchangeToken\\\", parsedValue);\\n    }\\n\\n    function parseExchangeAmount(bytes memory arbitraryData) internal returns (uint128 parsedValue){\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 50, 65);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 16))\\n        }\\n        // console.log(\\\"parseExchangeAmount\\\", parsedValue);\\n    }\\n\\n    function parseDeadline(bytes memory arbitraryData) internal returns (uint64 parsedValue){\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 66, 73);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 8))\\n        }\\n        // console.log(\\\"parseDeadline\\\", parsedValue);\\n    }\\n\\n    function parseIsFixedToken(bytes memory arbitraryData) internal returns (bool parsedValue) {\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 74, 74);\\n        bytes1 zero = 0x00;\\n        if (slicedBytes[0] == zero) {\\n            parsedValue = false;\\n        } else {\\n            parsedValue = true;\\n        }\\n        // console.log(\\\"parseIsFixedToken\\\", parsedValue);\\n    }\\n\\n    function sliceBytes(bytes memory data, uint start, uint end) internal returns (bytes memory result) {\\n        byte temp;\\n        for (uint i = start; i < end + 1; i++) {\\n            temp = data[i];\\n            result = abi.encodePacked(result, temp);\\n        }\\n    }\\n\\n    // TODO: add exchange path to arbitrary data (for now, user only gives us the exchnage token address)\\n    // function parsePath(bytes memory arbitraryData)\\n    //     internal\\n    //     returns (address[] memory)\\n    // {\\n    //     uint256 sizeofPath;\\n    //     assembly {\\n    //         sizeofPath := mload(add(arbitraryData, 356)) // bias = 4*32 + 4\\n    //     } // found the postion using testing\\n    //     address temp;\\n    //     uint256 index;\\n    //     index = 356 + 32;\\n\\n    //     for (uint256 i = 0; i < sizeofPath; i++) {\\n    //         assembly {\\n    //             temp := mload(add(arbitraryData, index))\\n    //         }\\n    //         parsedPath.push(temp);\\n    //         index = index + 32;\\n    //     }\\n    //     return parsedPath;\\n    // }\\n\\n}\\n\",\"keccak256\":\"0x6053440b5f729a61008c0a084fcfde7c1cfe839eb1c8363dd732c1d0203af6f7\"},\"contracts/libraries/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n    \\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b; //TODO: edit it\\n    }\\n}\\n\",\"keccak256\":\"0x8d7c458d27f34a0512d902ee3b662022a586ce1c27a79a0c260c676fd55c454d\"},\"contracts/libraries/TeleportDAOLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\nimport '../pools/interfaces/ILiquidityPool.sol';\\nimport '../pools/interfaces/ILiquidityPoolFactory.sol';\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary TeleportDAOLibrary {\\n    using SafeMath for uint;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'TeleportDAOLibrary: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'TeleportDAOLibrary: ZERO_ADDRESS');\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    // function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n    //     (address token0, address token1) = sortTokens(tokenA, tokenB);\\n    //     pair = address(uint(keccak256(abi.encodePacked(\\n    //             hex'ff',\\n    //             factory,\\n    //             keccak256(abi.encodePacked(token0, token1)),\\n    //             hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\\n    //         ))));\\n    // }\\n    \\n    //Instead of TeleportDAOLibrary\\n    function pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {\\n        // (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = ILiquidityPoolFactory(factory).getLiquidityPool(tokenA, tokenB);\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    // function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\n    //     (address token0,) = sortTokens(tokenA, tokenB);\\n    //     (uint reserve0, uint reserve1,) = ITeleportDAOPair(pairFor(factory, tokenA, tokenB)).getReserves();\\n    //     (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    // }\\n    \\n    //Instead of TeleportDAOLibrary\\n    function getReserves(address factory, address tokenA, address tokenB) internal returns (uint reserveA, uint reserveB) {\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        (uint reserve0, uint reserve1,) = ILiquidityPool(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA > 0, 'TeleportDAOLibrary: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'TeleportDAOLibrary: INSUFFICIENT_LIQUIDITY');\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\n        require(amountIn > 0, 'TeleportDAOLibrary: INSUFFICIENT_INPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'TeleportDAOLibrary: INSUFFICIENT_LIQUIDITY');\\n        uint amountInWithFee = amountIn.mul(997);\\n        uint numerator = amountInWithFee.mul(reserveOut);\\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\\n        require(amountOut > 0, 'TeleportDAOLibrary: INSUFFICIENT_OUTPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'TeleportDAOLibrary: INSUFFICIENT_LIQUIDITY');\\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\\n        uint denominator = reserveOut.sub(amountOut).mul(997);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    // function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\\n    //     require(path.length >= 2, 'TeleportDAOLibrary: INVALID_PATH');\\n    //     amounts = new uint[](path.length);\\n    //     amounts[0] = amountIn;\\n    //     for (uint i; i < path.length - 1; i++) {\\n    //         (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n    //         amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n    //     }\\n    // }\\n    \\n    //Instead of TeleportDAOLibrary\\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'TeleportDAOLibrary: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint i; i < path.length - 1; i++) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    // function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\\n    //     require(path.length >= 2, 'TeleportDAOLibrary: INVALID_PATH');\\n    //     amounts = new uint[](path.length);\\n    //     amounts[amounts.length - 1] = amountOut;\\n    //     for (uint i = path.length - 1; i > 0; i--) {\\n    //         (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n    //         amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n    //     }\\n    // }\\n    \\n    //Instead of TeleportDAOLibrary\\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'TeleportDAOLibrary: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint i = path.length - 1; i > 0; i--) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x03a5272548efe0c985e326d3b480dd2a2c780d2b021b48ebbaa74eeca8b462bd\"},\"contracts/libraries/TypedMemView.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.7.6;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary TypedMemView {\\n    using SafeMath for uint256;\\n\\n    // Why does this exist?\\n    // the solidity `bytes memory` type has a few weaknesses.\\n    // 1. You can't index ranges effectively\\n    // 2. You can't slice without copying\\n    // 3. The underlying data may represent any type\\n    // 4. Solidity never deallocates memory, and memory costs grow\\n    //    superlinearly\\n\\n    // By using a memory view instead of a `bytes memory` we get the following\\n    // advantages:\\n    // 1. Slices are done on the stack, by manipulating the pointer\\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\\n    // 3. We can insert type info into the pointer, and typecheck at runtime\\n\\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\\n    // algorithms.\\n\\n    // Why bytes29?\\n    // We want to avoid confusion between views, digests, and other common\\n    // types so we chose a large and uncommonly used odd number of bytes\\n    //\\n    // Note that while bytes are left-aligned in a word, integers and addresses\\n    // are right-aligned. This means when working in assembly we have to\\n    // account for the 3 unused bytes on the righthand side\\n    //\\n    // First 5 bytes are a type flag.\\n    // - ff_ffff_fffe is reserved for unknown type.\\n    // - ff_ffff_ffff is reserved for invalid types/errors.\\n    // next 12 are memory address\\n    // next 12 are len\\n    // bottom 3 bytes are empty\\n\\n    // Assumptions:\\n    // - non-modification of memory.\\n    // - No Solidity updates\\n    // - - wrt free mem point\\n    // - - wrt bytes representation in memory\\n    // - - wrt memory addressing in general\\n\\n    // Usage:\\n    // - create type constants\\n    // - use `assertType` for runtime type assertions\\n    // - - unfortunately we can't do this at compile time yet :(\\n    // - recommended: implement modifiers that perform type checking\\n    // - - e.g.\\n    // - - `uint40 constant MY_TYPE = 3;`\\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\\n    // - instantiate a typed view from a bytearray using `ref`\\n    // - use `index` to inspect the contents of the view\\n    // - use `slice` to create smaller views into the same memory\\n    // - - `slice` can increase the offset\\n    // - - `slice can decrease the length`\\n    // - - must specify the output type of `slice`\\n    // - - `slice` will return a null view if you try to overrun\\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\\n    // - use `equal` for typed comparisons.\\n\\n\\n    // The null view\\n    bytes29 public constant NULL = hex\\\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\\";\\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\\n    uint8 constant TWELVE_BYTES = 96;\\n\\n    /**\\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\\n     * @param _b    The byte\\n     * @return      char - The encoded hex character\\n     */\\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\\n        // This can probably be done more efficiently, but it's only in error\\n        // paths, so we don't really care :)\\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\\n        if (_nibble == 0xf0) {return 0x30;} // 0\\n        if (_nibble == 0xf1) {return 0x31;} // 1\\n        if (_nibble == 0xf2) {return 0x32;} // 2\\n        if (_nibble == 0xf3) {return 0x33;} // 3\\n        if (_nibble == 0xf4) {return 0x34;} // 4\\n        if (_nibble == 0xf5) {return 0x35;} // 5\\n        if (_nibble == 0xf6) {return 0x36;} // 6\\n        if (_nibble == 0xf7) {return 0x37;} // 7\\n        if (_nibble == 0xf8) {return 0x38;} // 8\\n        if (_nibble == 0xf9) {return 0x39;} // 9\\n        if (_nibble == 0xfa) {return 0x61;} // a\\n        if (_nibble == 0xfb) {return 0x62;} // b\\n        if (_nibble == 0xfc) {return 0x63;} // c\\n        if (_nibble == 0xfd) {return 0x64;} // d\\n        if (_nibble == 0xfe) {return 0x65;} // e\\n        if (_nibble == 0xff) {return 0x66;} // f\\n    }\\n\\n    /**\\n     * @notice      Returns a uint16 containing the hex-encoded byte.\\n     * @param _b    The byte\\n     * @return      encoded - The hex-encoded byte\\n     */\\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\\n        encoded |= nibbleHex(_b >> 4); // top 4 bits\\n        encoded <<= 8;\\n        encoded |= nibbleHex(_b); // lower 4 bits\\n    }\\n\\n    /**\\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\\n     *              `second` contains the encoded lower 16 bytes.\\n     *\\n     * @param _b    The 32 bytes as uint256\\n     * @return      first - The top 16 bytes\\n     * @return      second - The bottom 16 bytes\\n     */\\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\\n        for (uint8 i = 31; i > 15; i -= 1) {\\n            uint8 _byte = uint8(_b >> (i * 8));\\n            first |= byteHex(_byte);\\n            if (i != 16) {\\n                first <<= 16;\\n            }\\n        }\\n\\n        // abusing underflow here =_=\\n        for (uint8 i = 15; i < 255 ; i -= 1) {\\n            uint8 _byte = uint8(_b >> (i * 8));\\n            second |= byteHex(_byte);\\n            if (i != 0) {\\n                second <<= 16;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice          Changes the endianness of a uint256.\\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\\n     * @param _b        The unsigned integer to reverse\\n     * @return          v - The reversed value\\n     */\\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\\n        v = _b;\\n\\n        // swap bytes\\n        v = ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n        // swap 2-byte long pairs\\n        v = ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n        // swap 4-byte long pairs\\n        v = ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n        // swap 8-byte long pairs\\n        v = ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n        // swap 16-byte long pairs\\n        v = (v >> 128) | (v << 128);\\n    }\\n\\n    /**\\n     * @notice      Create a mask with the highest `_len` bits set.\\n     * @param _len  The length\\n     * @return      mask - The mask\\n     */\\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\\n        // ugly. redo without assembly?\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            mask := sar(\\n                sub(_len, 1),\\n                0x8000000000000000000000000000000000000000000000000000000000000000\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @notice      Return the null view.\\n     * @return      bytes29 - The null view\\n     */\\n    function nullView() internal pure returns (bytes29) {\\n        return NULL;\\n    }\\n\\n    /**\\n     * @notice      Check if the view is null.\\n     * @return      bool - True if the view is null\\n     */\\n    function isNull(bytes29 memView) internal pure returns (bool) {\\n        return memView == NULL;\\n    }\\n\\n    /**\\n     * @notice      Check if the view is not null.\\n     * @return      bool - True if the view is not null\\n     */\\n    function notNull(bytes29 memView) internal pure returns (bool) {\\n        return !isNull(memView);\\n    }\\n\\n    /**\\n     * @notice          Check if the view is of a valid type and points to a valid location\\n     *                  in memory.\\n     * @dev             We perform this check by examining solidity's unallocated memory\\n     *                  pointer and ensuring that the view's upper bound is less than that.\\n     * @param memView   The view\\n     * @return          ret - True if the view is valid\\n     */\\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\\n        if (typeOf(memView) == 0xffffffffff) {return false;}\\n        uint256 _end = end(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ret := not(gt(_end, mload(0x40)))\\n        }\\n    }\\n\\n    /**\\n     * @notice          Require that a typed memory view be valid.\\n     * @dev             Returns the view for easy chaining.\\n     * @param memView   The view\\n     * @return          bytes29 - The validated view\\n     */\\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\\n        require(isValid(memView), \\\"Validity assertion failed\\\");\\n        return memView;\\n    }\\n\\n    /**\\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\\n     * @param memView   The view\\n     * @param _expected The expected type\\n     * @return          bool - True if the memview is of the expected type\\n     */\\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\\n        return typeOf(memView) == _expected;\\n    }\\n\\n    /**\\n     * @notice          Require that a typed memory view has a specific type.\\n     * @dev             Returns the view for easy chaining.\\n     * @param memView   The view\\n     * @param _expected The expected type\\n     * @return          bytes29 - The view with validated type\\n     */\\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\\n        if (!isType(memView, _expected)) {\\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\\n            (, uint256 e) = encodeHex(uint256(_expected));\\n            string memory err = string(\\n                abi.encodePacked(\\n                    \\\"Type assertion failed. Got 0x\\\",\\n                    uint80(g),\\n                    \\\". Expected 0x\\\",\\n                    uint80(e)\\n                )\\n            );\\n            revert(err);\\n        }\\n        return memView;\\n    }\\n\\n    /**\\n     * @notice          Return an identical view with a different type.\\n     * @param memView   The view\\n     * @param _newType  The new type\\n     * @return          newView - The new view with the specified type\\n     */\\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\\n        // then | in the new type\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // shift off the top 5 bytes\\n            newView := or(newView, shr(40, shl(40, memView)))\\n            newView := or(newView, shl(216, _newType))\\n        }\\n    }\\n\\n    /**\\n     * @notice          Unsafe raw pointer construction. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @dev             Unsafe raw pointer construction. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @param _type     The type\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @return          newView - The new view with the specified type, location and length\\n     */\\n    function unsafeBuildUnchecked(uint256 _type, uint256 _loc, uint256 _len) private pure returns (bytes29 newView) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            newView := shl(96, or(newView, _type)) // insert type\\n            newView := shl(96, or(newView, _loc))  // insert loc\\n            newView := shl(24, or(newView, _len))  // empty bottom 3 bytes\\n        }\\n    }\\n\\n    /**\\n     * @notice          Instantiate a new memory view. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @dev             Instantiate a new memory view. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @param _type     The type\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @return          newView - The new view with the specified type, location and length\\n     */\\n    function build(uint256 _type, uint256 _loc, uint256 _len) internal pure returns (bytes29 newView) {\\n        uint256 _end = _loc.add(_len);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            if gt(_end, mload(0x40)) {\\n                _end := 0\\n            }\\n        }\\n        if (_end == 0) {\\n            return NULL;\\n        }\\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Instantiate a memory view from a byte array.\\n     * @dev             Note that due to Solidity memory representation, it is not possible to\\n     *                  implement a deref, as the `bytes` type stores its len in memory.\\n     * @param arr       The byte array\\n     * @param newType   The type\\n     * @return          bytes29 - The memory view\\n     */\\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\\n        uint256 _len = arr.length;\\n\\n        uint256 _loc;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            _loc := add(arr, 0x20)  // our view is of the data, not the struct\\n        }\\n\\n        return build(newType, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Return the associated type information.\\n     * @param memView   The memory view\\n     * @return          _type - The type associated with the view\\n     */\\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // 216 == 256 - 40\\n            _type := shr(216, memView) // shift out lower 24 bytes\\n        }\\n    }\\n\\n    /**\\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the 5-byte type flag is equal\\n     */\\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return (left ^ right) >> (2 * TWELVE_BYTES) == 0;\\n    }\\n\\n    /**\\n     * @notice          Return the memory address of the underlying bytes.\\n     * @param memView   The view\\n     * @return          _loc - The memory address\\n     */\\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\\n            _loc := and(shr(120, memView), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          The number of memory words this memory view occupies, rounded up.\\n     * @param memView   The view\\n     * @return          uint256 - The number of memory words\\n     */\\n    function words(bytes29 memView) internal pure returns (uint256) {\\n        return uint256(len(memView)).add(32) / 32;\\n    }\\n\\n    /**\\n     * @notice          The in-memory footprint of a fresh copy of the view.\\n     * @param memView   The view\\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\\n     */\\n    function footprint(bytes29 memView) internal pure returns (uint256) {\\n        return words(memView) * 32;\\n    }\\n\\n    /**\\n     * @notice          The number of bytes of the view.\\n     * @param memView   The view\\n     * @return          _len - The length of the view\\n     */\\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            _len := and(shr(24, memView), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Returns the endpoint of `memView`.\\n     * @param memView   The view\\n     * @return          uint256 - The endpoint of `memView`\\n     */\\n    function end(bytes29 memView) internal pure returns (uint256) {\\n        return loc(memView) + len(memView);\\n    }\\n\\n    /**\\n     * @notice          Safe slicing without memory modification.\\n     * @param memView   The view\\n     * @param _index    The start index\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function slice(bytes29 memView, uint256 _index, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        uint256 _loc = loc(memView);\\n\\n        // Ensure it doesn't overrun the view\\n        if (_loc.add(_index).add(_len) > end(memView)) {\\n            return NULL;\\n        }\\n\\n        _loc = _loc.add(_index);\\n        return build(newType, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\\n     * @param memView   The view\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function prefix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        return slice(memView, 0, _len, newType);\\n    }\\n\\n    /**\\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\\n     * @param memView   The view\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function postfix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        return slice(memView, uint256(len(memView)).sub(_len), _len, newType);\\n    }\\n\\n    /**\\n     * @notice          Construct an error message for an indexing overrun.\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @param _index    The index\\n     * @param _slice    The slice where the overrun occurred\\n     * @return          err - The err\\n     */\\n    function indexErrOverrun(\\n        uint256 _loc,\\n        uint256 _len,\\n        uint256 _index,\\n        uint256 _slice\\n    ) internal pure returns (string memory err) {\\n        (, uint256 a) = encodeHex(_loc);\\n        (, uint256 b) = encodeHex(_len);\\n        (, uint256 c) = encodeHex(_index);\\n        (, uint256 d) = encodeHex(_slice);\\n        err = string(\\n            abi.encodePacked(\\n                \\\"TypedMemView/index - Overran the view. Slice is at 0x\\\",\\n                uint48(a),\\n                \\\" with length 0x\\\",\\n                uint48(b),\\n                \\\". Attempted to index at offset 0x\\\",\\n                uint48(c),\\n                \\\" with length 0x\\\",\\n                uint48(d),\\n                \\\".\\\"\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice          Load up to 32 bytes from the view onto the stack.\\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\\n     *                  This can be immediately cast to a smaller fixed-length byte array.\\n     *                  To automatically cast to an integer, use `indexUint`.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The 32 byte result\\n     */\\n    function index(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (bytes32 result) {\\n        if (_bytes == 0) {return bytes32(0);}\\n        if (_index.add(_bytes) > len(memView)) {\\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\\n        }\\n        require(_bytes <= 32, \\\"TypedMemView/index - Attempted to index more than 32 bytes\\\");\\n\\n        uint8 bitLength = _bytes * 8;\\n        uint256 _loc = loc(memView);\\n        uint256 _mask = leftMask(bitLength);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            result := and(mload(add(_loc, _index)), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Parse an unsigned integer from the view at `_index`.\\n     * @dev             Requires that the view have >= `_bytes` bytes following that index.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The unsigned integer\\n     */\\n    function indexUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {\\n        return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\\n    }\\n\\n    /**\\n     * @notice          Parse an unsigned integer from LE bytes.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The unsigned integer\\n     */\\n    function indexLEUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {\\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\\n    }\\n\\n    /**\\n     * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\\n     *                  following that index.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @return          address - The address\\n     */\\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\\n        return address(uint160(indexUint(memView, _index, 20)));\\n    }\\n\\n    /**\\n     * @notice          Return the keccak256 hash of the underlying memory\\n     * @param memView   The view\\n     * @return          digest - The keccak256 hash of the underlying memory\\n     */\\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            digest := keccak256(_loc, _len)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Return the sha2 digest of the underlying memory.\\n     * @dev             We explicitly deallocate memory afterwards.\\n     * @param memView   The view\\n     * @return          digest - The sha2 hash of the underlying memory\\n     */\\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\\n     * @param memView   The pre-image\\n     * @return          digest - the Digest\\n     */\\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\\n        }\\n    }\\n\\n    /**\\n     * @notice          Implements bitcoin's hash256 (double sha2)\\n     * @param memView   A view of the preimage\\n     * @return          digest - the Digest\\n     */\\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Return true if the underlying memory is equal. Else false.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the underlying memory is equal\\n     */\\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\\n    }\\n\\n    /**\\n     * @notice          Return false if the underlying memory is equal. Else true.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - False if the underlying memory is equal\\n     */\\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return !untypedEqual(left, right);\\n    }\\n\\n    /**\\n     * @notice          Compares type equality.\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the types are the same\\n     */\\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\\n    }\\n\\n    /**\\n     * @notice          Compares type inequality.\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the types are not the same\\n     */\\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return !equal(left, right);\\n    }\\n\\n    /**\\n     * @notice          Copy the view to a location, return an unsafe memory reference\\n     * @dev             Super Dangerous direct memory access.\\n     *\\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\\n     *                  As such it MUST be consumed IMMEDIATELY.\\n     *                  This function is private to prevent unsafe usage by callers.\\n     * @param memView   The view\\n     * @param _newLoc   The new location\\n     * @return          written - the unsafe memory reference\\n     */\\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\\n        require(notNull(memView), \\\"TypedMemView/copyTo - Null pointer deref\\\");\\n        require(isValid(memView), \\\"TypedMemView/copyTo - Invalid pointer deref\\\");\\n        uint256 _len = len(memView);\\n        uint256 _oldLoc = loc(memView);\\n\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40)\\n            // revert if we're writing in occupied memory\\n            if gt(ptr, _newLoc) {\\n                revert(0x60, 0x20) // empty revert message\\n            }\\n\\n            // use the identity precompile to copy\\n            // guaranteed not to fail, so pop the success\\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\\n        }\\n\\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\\n    }\\n\\n    /**\\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\\n     *                  the new memory\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param memView   The view\\n     * @return          ret - The view pointing to the new memory\\n     */\\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\\n        uint256 ptr;\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n            ret := ptr\\n        }\\n        unsafeCopyTo(memView, ptr + 0x20);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\\n            mstore(ptr, _len) // write len of new array (in bytes)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\\n     * @dev             Super Dangerous direct memory access.\\n     *\\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\\n     *                  As such it MUST be consumed IMMEDIATELY.\\n     *                  This function is private to prevent unsafe usage by callers.\\n     * @param memViews  The views\\n     * @return          unsafeView - The conjoined view pointing to the new memory\\n     */\\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            // revert if we're writing in occupied memory\\n            if gt(ptr, _location) {\\n                revert(0x60, 0x20) // empty revert message\\n            }\\n        }\\n\\n        uint256 _offset = 0;\\n        for (uint256 i = 0; i < memViews.length; i ++) {\\n            bytes29 memView = memViews[i];\\n            unsafeCopyTo(memView, _location + _offset);\\n            _offset += len(memView);\\n        }\\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\\n    }\\n\\n    /**\\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\\n     * @param memViews  The views\\n     * @return          bytes32 - The keccak256 digest\\n     */\\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n        return keccak(unsafeJoin(memViews, ptr));\\n    }\\n\\n    /**\\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\\n     * @param memViews  The views\\n     * @return          bytes32 - The sha256 digest\\n     */\\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n        return sha2(unsafeJoin(memViews, ptr));\\n    }\\n\\n    /**\\n     * @notice          copies all views, joins them into a new bytearray.\\n     * @param memViews  The views\\n     * @return          ret - The new byte array\\n     */\\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n\\n        bytes29 _newView = unsafeJoin(memViews, ptr + 0x20);\\n        uint256 _written = len(_newView);\\n        uint256 _footprint = footprint(_newView);\\n\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // store the legnth\\n            mstore(ptr, _written)\\n            // new pointer is old + 0x20 + the footprint of the body\\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\\n            ret := ptr\\n        }\\n    }\\n}\",\"keccak256\":\"0x00cbfbbcbe4334fe3f66659074dc2785d689c249ebf259a60b65e2e52cde1a73\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/libraries/ViewBTC.sol\":{\"content\":\"pragma solidity 0.7.6;\\n\\n/** @title BitcoinSPV */\\n/** @author Summa (https://summa.one) */\\n\\nimport \\\"./TypedMemView.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary ViewBTC {\\n    using TypedMemView for bytes29;\\n    using SafeMath for uint256;\\n\\n    // The target at minimum Difficulty. Also the target of the genesis block\\n    uint256 public constant DIFF1_TARGET = 0xffff0000000000000000000000000000000000000000000000000000;\\n\\n    uint256 public constant RETARGET_PERIOD = 2 * 7 * 24 * 60 * 60;  // 2 weeks in seconds\\n    uint256 public constant RETARGET_PERIOD_BLOCKS = 2016;  // 2 weeks in blocks\\n\\n    enum BTCTypes {\\n        Unknown,            // 0x0\\n        CompactInt,         // 0x1\\n        ScriptSig,          // 0x2 - with length prefix\\n        Outpoint,           // 0x3\\n        TxIn,               // 0x4\\n        IntermediateTxIns,  // 0x5 - used in vin parsing\\n        Vin,                // 0x6\\n        ScriptPubkey,       // 0x7 - with length prefix\\n        PKH,                // 0x8 - the 20-byte payload digest\\n        WPKH,               // 0x9 - the 20-byte payload digest\\n        WSH,                // 0xa - the 32-byte payload digest\\n        SH,                 // 0xb - the 20-byte payload digest\\n        OpReturnPayload,    // 0xc\\n        TxOut,              // 0xd\\n        IntermediateTxOuts, // 0xe - used in vout parsing\\n        Vout,               // 0xf\\n        Header,             // 0x10\\n        HeaderArray,        // 0x11\\n        MerkleNode,         // 0x12\\n        MerkleStep,         // 0x13\\n        MerkleArray         // 0x14\\n    }\\n\\n    // TODO: any way to bubble up more info?\\n    // @notice             requires `memView` to be of a specified type\\n    // @param memView      a 29-byte view with a 5-byte type\\n    // @param t            the expected type (e.g. BTCTypes.Outpoint, BTCTypes.TxIn, etc)\\n    // @return             passes if it is the correct type, errors if not\\n    modifier typeAssert(bytes29 memView, BTCTypes t) {\\n        memView.assertType(uint40(t));\\n        _;\\n    }\\n\\n    // Revert with an error message re: non-minimal VarInts\\n    function revertNonMinimal(bytes29 ref) private pure returns (string memory) {\\n        (, uint256 g) = TypedMemView.encodeHex(ref.indexUint(0, uint8(ref.len())));\\n        string memory err = string(\\n            abi.encodePacked(\\n                \\\"Non-minimal var int. Got 0x\\\",\\n                uint144(g)\\n            )\\n        );\\n        revert(err);\\n    }\\n\\n    // @notice             reads a compact int from the view at the specified index\\n    // @param memView      a 29-byte view with a 5-byte type\\n    // @param _index       the index\\n    // @return             the compact int at the specified index\\n    function indexCompactInt(bytes29 memView, uint256 _index) internal pure returns (uint64 number) {\\n        uint256 flag = memView.indexUint(_index, 1);\\n        if (flag <= 0xfc) {\\n            return uint64(flag);\\n        } else if (flag == 0xfd) {\\n            number = uint64(memView.indexLEUint(_index + 1, 2));\\n            if (compactIntLength(number) != 3) {revertNonMinimal(memView.slice(_index, 3, 0));}\\n        } else if (flag == 0xfe) {\\n            number = uint64(memView.indexLEUint(_index + 1, 4));\\n            if (compactIntLength(number) != 5) {revertNonMinimal(memView.slice(_index, 5, 0));}\\n        } else if (flag == 0xff) {\\n            number = uint64(memView.indexLEUint(_index + 1, 8));\\n            if (compactIntLength(number) != 9) {revertNonMinimal(memView.slice(_index, 9, 0));}\\n        }\\n    }\\n\\n    // @notice         gives the total length (in bytes) of a CompactInt-encoded number\\n    // @param number   the number as uint64\\n    // @return         the compact integer as uint8\\n    function compactIntLength(uint64 number) internal pure returns (uint8) {\\n        if (number <= 0xfc) {\\n            return 1;\\n        } else if (number <= 0xffff) {\\n            return 3;\\n        } else if (number <= 0xffffffff) {\\n            return 5;\\n        } else {\\n            return 9;\\n        }\\n    }\\n\\n    // @notice             extracts the LE txid from an outpoint\\n    // @param _outpoint    the outpoint\\n    // @return             the LE txid\\n    function txidLE(bytes29 _outpoint) internal pure typeAssert(_outpoint, BTCTypes.Outpoint) returns (bytes32) {\\n        return _outpoint.index(0, 32);\\n    }\\n\\n    // @notice             extracts the index as an integer from the outpoint\\n    // @param _outpoint    the outpoint\\n    // @return             the index\\n    function outpointIdx(bytes29 _outpoint) internal pure typeAssert(_outpoint, BTCTypes.Outpoint) returns (uint32) {\\n        return uint32(_outpoint.indexLEUint(32, 4));\\n    }\\n\\n    // @notice          extracts the outpoint from an input\\n    // @param _input    the input\\n    // @return          the outpoint as a typed memory\\n    function outpoint(bytes29 _input) internal pure typeAssert(_input, BTCTypes.TxIn) returns (bytes29) {\\n        return _input.slice(0, 36, uint40(BTCTypes.Outpoint));\\n    }\\n\\n    // @notice           extracts the script sig from an input\\n    // @param _input     the input\\n    // @return           the script sig as a typed memory\\n    function scriptSig(bytes29 _input) internal pure typeAssert(_input, BTCTypes.TxIn) returns (bytes29) {\\n        uint64 scriptLength = indexCompactInt(_input, 36);\\n        return _input.slice(36, compactIntLength(scriptLength) + scriptLength, uint40(BTCTypes.ScriptSig));\\n    }\\n\\n    // @notice         extracts the sequence from an input\\n    // @param _input   the input\\n    // @return         the sequence\\n    function sequence(bytes29 _input) internal pure typeAssert(_input, BTCTypes.TxIn) returns (uint32) {\\n        uint64 scriptLength = indexCompactInt(_input, 36);\\n        uint256 scriptEnd = 36 + compactIntLength(scriptLength) + scriptLength;\\n        return uint32(_input.indexLEUint(scriptEnd, 4));\\n    }\\n\\n    // @notice         determines the length of the first input in an array of inputs\\n    // @param _inputs  the vin without its length prefix\\n    // @return         the input length\\n    function inputLength(bytes29 _inputs) internal pure typeAssert(_inputs, BTCTypes.IntermediateTxIns) returns (uint256) {\\n        uint64 scriptLength = indexCompactInt(_inputs, 36);\\n        return uint256(compactIntLength(scriptLength)) + uint256(scriptLength) + 36 + 4;\\n    }\\n\\n    // @notice         extracts the input at a specified index\\n    // @param _vin     the vin\\n    // @param _index   the index of the desired input\\n    // @return         the desired input\\n    function indexVin(bytes29 _vin, uint256 _index) internal pure typeAssert(_vin, BTCTypes.Vin) returns (bytes29) {\\n        uint256 _nIns = uint256(indexCompactInt(_vin, 0));\\n        uint256 _viewLen = _vin.len();\\n        require(_index < _nIns, \\\"Vin read overrun\\\");\\n\\n        uint256 _offset = uint256(compactIntLength(uint64(_nIns)));\\n        bytes29 _remaining;\\n        for (uint256 _i = 0; _i < _index; _i += 1) {\\n            _remaining = _vin.postfix(_viewLen.sub(_offset), uint40(BTCTypes.IntermediateTxIns));\\n            _offset += inputLength(_remaining);\\n        }\\n\\n        _remaining = _vin.postfix(_viewLen.sub(_offset), uint40(BTCTypes.IntermediateTxIns));\\n        uint256 _len = inputLength(_remaining);\\n        return _vin.slice(_offset, _len, uint40(BTCTypes.TxIn));\\n    }\\n\\n    // @notice         extracts the raw LE bytes of the output value\\n    // @param _output  the output\\n    // @return         the raw LE bytes of the output value\\n    function valueBytes(bytes29 _output) internal pure typeAssert(_output, BTCTypes.TxOut) returns (bytes8) {\\n        return bytes8(_output.index(0, 8));\\n    }\\n\\n    // @notice         extracts the value from an output\\n    // @param _output  the output\\n    // @return         the value\\n    // function value(bytes29 _output) internal pure typeAssert(_output, BTCTypes.TxOut) returns (uint64) {\\n    //     return uint64(_output.indexLEUint(0, 8));\\n    // }\\n    function value(bytes29 _output) internal pure returns (uint64) {\\n        return uint64(_output.indexLEUint(0, 8));\\n    }\\n\\n    // @notice             extracts the scriptPubkey from an output\\n    // @param _output      the output\\n    // @return             the scriptPubkey\\n    function scriptPubkey(bytes29 _output) internal typeAssert(_output, BTCTypes.TxOut) returns (bytes29) {\\n        uint64 scriptLength = indexCompactInt(_output, 8);\\n        return _output.slice(8, compactIntLength(scriptLength) + scriptLength, uint40(BTCTypes.ScriptPubkey));\\n    }\\n\\n    function scriptPubkeyBytes(bytes29 _output) internal typeAssert(_output, BTCTypes.TxOut) returns (bytes32) {\\n        uint64 scriptLength = indexCompactInt(_output, 8);\\n        bytes29 scriptPubkeyView = _output.slice(8, compactIntLength(scriptLength) + scriptLength, uint40(BTCTypes.ScriptPubkey));\\n        return scriptPubkeyView.index(compactIntLength(scriptLength), uint8(scriptLength));\\n    }\\n\\n    // @notice             determines the length of the first output in an array of outputs\\n    // @param _outputs     the vout without its length prefix\\n    // @return             the output length\\n    function outputLength(bytes29 _outputs) internal pure typeAssert(_outputs, BTCTypes.IntermediateTxOuts) returns (uint256) {\\n        uint64 scriptLength = indexCompactInt(_outputs, 8);\\n        return uint256(compactIntLength(scriptLength)) + uint256(scriptLength) + 8;\\n    }\\n\\n    // @notice         extracts the output at a specified index\\n    // @param _vout    the vout\\n    // @param _index   the index of the desired output\\n    // @return         the desired output\\n    // function indexVout(bytes29 _vout, uint256 _index) internal pure typeAssert(_vout, BTCTypes.Vout) returns (bytes29) {\\n    //     uint256 _nOuts = uint256(indexCompactInt(_vout, 0));\\n    //     uint256 _viewLen = _vout.len();\\n    //     require(_index < _nOuts, \\\"Vout read overrun\\\");\\n\\n    //     uint256 _offset = uint256(compactIntLength(uint64(_nOuts)));\\n    //     bytes29 _remaining;\\n    //     for (uint256 _i = 0; _i < _index; _i += 1) {\\n    //         _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n    //         _offset += outputLength(_remaining);\\n    //     }\\n\\n    //     _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n    //     uint256 _len = outputLength(_remaining);\\n    //     return _vout.slice(_offset, _len, uint40(BTCTypes.TxOut));\\n    // }\\n    function indexVout(bytes29 _vout, uint256 _index) internal pure returns (bytes29) {\\n        uint256 _nOuts = uint256(indexCompactInt(_vout, 0));\\n        uint256 _viewLen = _vout.len();\\n        require(_index < _nOuts, \\\"Vout read overrun\\\");\\n\\n        uint256 _offset = uint256(compactIntLength(uint64(_nOuts)));\\n        bytes29 _remaining;\\n        for (uint256 _i = 0; _i < _index; _i += 1) {\\n            _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n            _offset += outputLength(_remaining);\\n        }\\n\\n        _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n        uint256 _len = outputLength(_remaining);\\n        return _vout.slice(_offset, _len, uint40(BTCTypes.TxOut));\\n    }\\n\\n    // @notice         extracts the Op Return Payload\\n    // @param _spk     the scriptPubkey\\n    // @return         the Op Return Payload (or null if not a valid Op Return output)\\n    function opReturnPayload(bytes29 _spk) internal pure typeAssert(_spk, BTCTypes.ScriptPubkey) returns (bytes29) {\\n        uint64 _bodyLength = indexCompactInt(_spk, 0);\\n        uint64 _payloadLen = uint64(_spk.indexUint(2, 1));\\n        if (_bodyLength > 77 || _bodyLength < 4 || _spk.indexUint(1, 1) != 0x6a || _spk.indexUint(2, 1) != _bodyLength - 2) {\\n            return TypedMemView.nullView();\\n        }\\n        return _spk.slice(3, _payloadLen, uint40(BTCTypes.OpReturnPayload));\\n    }\\n\\n    // @notice         extracts the payload from a scriptPubkey\\n    // @param _spk     the scriptPubkey\\n    // @return         the payload (or null if not a valid PKH, SH, WPKH, or WSH output)\\n    function payload(bytes29 _spk) internal pure typeAssert(_spk, BTCTypes.ScriptPubkey) returns (bytes29) {\\n        uint256 _spkLength = _spk.len();\\n        uint256 _bodyLength = indexCompactInt(_spk, 0);\\n        if (_bodyLength > 0x22 || _bodyLength < 0x16 || _bodyLength + 1 != _spkLength) {\\n            return TypedMemView.nullView();\\n        }\\n\\n        // Legacy\\n        if (_bodyLength == 0x19 && _spk.indexUint(0, 4) == 0x1976a914 && _spk.indexUint(_spkLength - 2, 2) == 0x88ac) {\\n            return _spk.slice(4, 20, uint40(BTCTypes.PKH));\\n        } else if (_bodyLength == 0x17 && _spk.indexUint(0, 3) == 0x17a914 && _spk.indexUint(_spkLength - 1, 1) == 0x87) {\\n            return _spk.slice(3, 20, uint40(BTCTypes.SH));\\n        }\\n\\n        // Witness v0\\n        if (_spk.indexUint(1, 1) == 0) {\\n            uint256 _payloadLen = _spk.indexUint(2, 1);\\n            if (_bodyLength != 0x22 && _bodyLength != 0x16 || _payloadLen != _bodyLength - 2) {\\n                return TypedMemView.nullView();\\n            }\\n            uint40 newType = uint40(_payloadLen == 0x20 ? BTCTypes.WSH : BTCTypes.WPKH);\\n            return _spk.slice(3, _payloadLen, newType);\\n        }\\n\\n        return TypedMemView.nullView();\\n    }\\n\\n    // @notice     (loosely) verifies an spk and converts to a typed memory\\n    // @dev        will return null in error cases. Will not check for disabled opcodes.\\n    // @param _spk the spk\\n    // @return     the typed spk (or null if error)\\n    function tryAsSPK(bytes29 _spk) internal pure typeAssert(_spk, BTCTypes.Unknown) returns (bytes29) {\\n        if (_spk.len() == 0) {\\n            return TypedMemView.nullView();\\n        }\\n        uint64 _len = indexCompactInt(_spk, 0);\\n        if (_spk.len() == compactIntLength(_len) + _len) {\\n            return _spk.castTo(uint40(BTCTypes.ScriptPubkey));\\n        } else {\\n            return TypedMemView.nullView();\\n        }\\n    }\\n\\n    // @notice     verifies the vin and converts to a typed memory\\n    // @dev        will return null in error cases\\n    // @param _vin the vin\\n    // @return     the typed vin (or null if error)\\n    function tryAsVin(bytes29 _vin) internal pure typeAssert(_vin, BTCTypes.Unknown) returns (bytes29) {\\n        if (_vin.len() == 0) {\\n            return TypedMemView.nullView();\\n        }\\n        uint64 _nIns = indexCompactInt(_vin, 0);\\n        uint256 _viewLen = _vin.len();\\n        if (_nIns == 0) {\\n            return TypedMemView.nullView();\\n        }\\n\\n        uint256 _offset = uint256(compactIntLength(_nIns));\\n        for (uint256 i = 0; i < _nIns; i++) {\\n            if (_offset >= _viewLen) {\\n                // We've reached the end, but are still trying to read more\\n                return TypedMemView.nullView();\\n            }\\n            bytes29 _remaining = _vin.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxIns));\\n            _offset += inputLength(_remaining);\\n        }\\n        if (_offset != _viewLen) {\\n            return TypedMemView.nullView();\\n        }\\n        return _vin.castTo(uint40(BTCTypes.Vin));\\n    }\\n\\n    // @notice         verifies the vout and converts to a typed memory\\n    // @dev            will return null in error cases\\n    // @param _vout    the vout\\n    // @return         the typed vout (or null if error)\\n    function tryAsVout(bytes29 _vout) internal pure typeAssert(_vout, BTCTypes.Unknown) returns (bytes29) {\\n        if (_vout.len() == 0) {\\n            return TypedMemView.nullView();\\n        }\\n        uint64 _nOuts = indexCompactInt(_vout, 0);\\n        uint256 _viewLen = _vout.len();\\n        if (_nOuts == 0) {\\n            return TypedMemView.nullView();\\n        }\\n\\n        uint256 _offset = uint256(compactIntLength(_nOuts));\\n        for (uint256 i = 0; i < _nOuts; i++) {\\n            if (_offset >= _viewLen) {\\n                // We've reached the end, but are still trying to read more\\n                return TypedMemView.nullView();\\n            }\\n            bytes29 _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n            _offset += outputLength(_remaining);\\n        }\\n        if (_offset != _viewLen) {\\n            return TypedMemView.nullView();\\n        }\\n        return _vout.castTo(uint40(BTCTypes.Vout));\\n    }\\n\\n    // @notice         verifies the header and converts to a typed memory\\n    // @dev            will return null in error cases\\n    // @param _header  the header\\n    // @return         the typed header (or null if error)\\n    function tryAsHeader(bytes29 _header) internal pure typeAssert(_header, BTCTypes.Unknown) returns (bytes29) {\\n        if (_header.len() != 80) {\\n            return TypedMemView.nullView();\\n        }\\n        return _header.castTo(uint40(BTCTypes.Header));\\n    }\\n\\n\\n    // @notice         Index a header array.\\n    // @dev            Errors on overruns\\n    // @param _arr     The header array\\n    // @param index    The 0-indexed location of the header to get\\n    // @return         the typed header at `index`\\n    function indexHeaderArray(bytes29 _arr, uint256 index) internal pure typeAssert(_arr, BTCTypes.HeaderArray) returns (bytes29) {\\n        uint256 _start = index.mul(80);\\n        return _arr.slice(_start, 80, uint40(BTCTypes.Header));\\n    }\\n\\n\\n    // @notice     verifies the header array and converts to a typed memory\\n    // @dev        will return null in error cases\\n    // @param _arr the header array\\n    // @return     the typed header array (or null if error)\\n    function tryAsHeaderArray(bytes29 _arr) internal pure typeAssert(_arr, BTCTypes.Unknown) returns (bytes29) {\\n        if (_arr.len() % 80 != 0) {\\n            return TypedMemView.nullView();\\n        }\\n        return _arr.castTo(uint40(BTCTypes.HeaderArray));\\n    }\\n\\n    // @notice     verifies the merkle array and converts to a typed memory\\n    // @dev        will return null in error cases\\n    // @param _arr the merkle array\\n    // @return     the typed merkle array (or null if error)\\n    function tryAsMerkleArray(bytes29 _arr) internal pure typeAssert(_arr, BTCTypes.Unknown) returns (bytes29) {\\n        if (_arr.len() % 32 != 0) {\\n            return TypedMemView.nullView();\\n        }\\n        return _arr.castTo(uint40(BTCTypes.MerkleArray));\\n    }\\n\\n    // @notice         extracts the merkle root from the header\\n    // @param _header  the header\\n    // @return         the merkle root\\n    // function merkleRoot(bytes29 _header) internal pure typeAssert(_header, BTCTypes.Header) returns (bytes32) {\\n    //     return _header.index(36, 32);\\n    // }\\n\\n    function merkleRoot(bytes29 _header) internal pure returns (bytes32) {\\n        return _header.index(36, 32);\\n    }\\n\\n    // @notice         extracts the target from the header\\n    // @param _header  the header\\n    // @return         the target\\n    function target(bytes29  _header) internal pure typeAssert(_header, BTCTypes.Header) returns (uint256) {\\n        uint256 _mantissa = _header.indexLEUint(72, 3);\\n        uint256 _exponent = _header.indexUint(75, 1).sub(3);\\n        return _mantissa.mul(256 ** _exponent);\\n    }\\n\\n    // @notice         calculates the difficulty from a target\\n    // @param _target  the target\\n    // @return         the difficulty\\n    function toDiff(uint256  _target) internal pure returns (uint256) {\\n        return DIFF1_TARGET.div(_target);\\n    }\\n\\n    // @notice         extracts the difficulty from the header\\n    // @param _header  the header\\n    // @return         the difficulty\\n    function diff(bytes29  _header) internal pure typeAssert(_header, BTCTypes.Header) returns (uint256) {\\n        return toDiff(target(_header));\\n    }\\n\\n    // @notice         extracts the timestamp from the header\\n    // @param _header  the header\\n    // @return         the timestamp\\n    function time(bytes29  _header) internal pure typeAssert(_header, BTCTypes.Header) returns (uint32) {\\n        return uint32(_header.indexLEUint(68, 4));\\n    }\\n\\n    // @notice         extracts the parent hash from the header\\n    // @param _header  the header\\n    // @return         the parent hash\\n    function parent(bytes29 _header) internal pure typeAssert(_header, BTCTypes.Header) returns (bytes32) {\\n        return _header.index(4, 32);\\n    }\\n\\n    // @notice         calculates the Proof of Work hash of the header\\n    // @param _header  the header\\n    // @return         the Proof of Work hash\\n    function workHash(bytes29 _header) internal view typeAssert(_header, BTCTypes.Header) returns (bytes32) {\\n        return _header.hash256();\\n    }\\n\\n    // @notice         calculates the Proof of Work hash of the header, and converts to an integer\\n    // @param _header  the header\\n    // @return         the Proof of Work hash as an integer\\n    function work(bytes29 _header) internal view typeAssert(_header, BTCTypes.Header) returns (uint256) {\\n        return TypedMemView.reverseUint256(uint256(workHash(_header)));\\n    }\\n\\n    // @notice          Concatenates and hashes two inputs for merkle proving\\n    // @dev             Not recommended to call directly.\\n    // @param _a        The first hash\\n    // @param _b        The second hash\\n    // @return          The double-sha256 of the concatenated hashes\\n    function _merkleStep(bytes32 _a, bytes32 _b) internal view returns (bytes32 digest) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            mstore(ptr, _a)\\n            mstore(add(ptr, 0x20), _b)\\n            pop(staticcall(gas(), 2, ptr, 0x40, ptr, 0x20)) // sha2 #1\\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    // @notice         verifies a merkle proof\\n    // @param _leaf    the leaf\\n    // @param _proof   the merkle proof\\n    // @param _root    the merkle root\\n    // @param _index   the index\\n    // @return         true if valid, false if otherwise\\n    // function checkMerkle(\\n    //     bytes32 _leaf,\\n    //     bytes29 _proof,\\n    //     bytes32 _root,\\n    //     uint256 _index\\n    // ) internal view typeAssert(_proof, BTCTypes.MerkleArray) returns (bool) {\\n    //     uint256 nodes = _proof.len() / 32;\\n    //     if (nodes == 0) {\\n    //         return _leaf == _root;\\n    //     }\\n\\n    //     uint256 _idx = _index;\\n    //     bytes32 _current = _leaf;\\n\\n    //     for (uint i = 0; i < nodes; i++) {\\n    //         bytes32 _next = _proof.index(i * 32, 32);\\n    //         if (_idx % 2 == 1) {\\n    //             _current = _merkleStep(_next, _current);\\n    //         } else {\\n    //             _current = _merkleStep(_current, _next);\\n    //         }\\n    //         _idx >>= 1;\\n    //     }\\n\\n    //     return _current == _root;\\n    // }\\n    function checkMerkle(\\n        bytes32 _leaf, // _leaf is LE\\n        bytes29 _proof, // _proof nodes are LE\\n        bytes32 _root, // _root is BE (same as the merkle root that is stored in the block header)\\n        uint256 _index\\n    ) internal returns (bool) {\\n        uint256 nodes = _proof.len() / 32;\\n        if (nodes == 0) {\\n            return _leaf == _root;\\n        }\\n\\n        uint256 _idx = _index;\\n        bytes32 _current = _leaf;\\n\\n        for (uint i = 0; i < nodes; i++) {\\n            bytes32 _next = _proof.index(i * 32, 32);\\n            if (_idx % 2 == 1) {\\n                _current = _merkleStep(_next, _current);\\n            } else {\\n                _current = _merkleStep(_current, _next);\\n            }\\n            _idx >>= 1;\\n        }\\n\\n        return revertBytes32(_current) == _root;\\n    }\\n\\n    function revertBytes32 (bytes32 input) internal returns(bytes32) {\\n        bytes memory temp;\\n        bytes32 result;\\n        for (uint i = 0; i < 32; i++) {\\n            temp = abi.encodePacked(temp, input[31-i]);\\n        }\\n        assembly {\\n            result := mload(add(temp, 32))\\n        }\\n        return result;\\n    }\\n    // @notice                 performs the bitcoin difficulty retarget\\n    // @dev                    implements the Bitcoin algorithm precisely\\n    // @param _previousTarget  the target of the previous period\\n    // @param _firstTimestamp  the timestamp of the first block in the difficulty period\\n    // @param _secondTimestamp the timestamp of the last block in the difficulty period\\n    // @return                 the new period's target threshold\\n    function retargetAlgorithm(\\n        uint256 _previousTarget,\\n        uint256 _firstTimestamp,\\n        uint256 _secondTimestamp\\n    ) internal pure returns (uint256) {\\n        uint256 _elapsedTime = _secondTimestamp.sub(_firstTimestamp);\\n\\n        // Normalize ratio to factor of 4 if very long or very short\\n        if (_elapsedTime < RETARGET_PERIOD.div(4)) {\\n            _elapsedTime = RETARGET_PERIOD.div(4);\\n        }\\n        if (_elapsedTime > RETARGET_PERIOD.mul(4)) {\\n            _elapsedTime = RETARGET_PERIOD.mul(4);\\n        }\\n\\n        /*\\n            NB: high targets e.g. ffff0020 can cause overflows here\\n                so we divide it by 256**2, then multiply by 256**2 later\\n                we know the target is evenly divisible by 256**2, so this isn't an issue\\n        */\\n        uint256 _adjusted = _previousTarget.div(65536).mul(_elapsedTime);\\n        return _adjusted.div(RETARGET_PERIOD).mul(65536);\\n    }\\n}\",\"keccak256\":\"0x8e0dd74955a8b68e55672cd2b42c4eceb5dc363f7d3a9f0ef08dfd89fc9dad1c\"},\"contracts/pools/interfaces/IFastPool.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity ^0.7.6;\\n\\nimport '../../erc20/interfaces/IERC20.sol';\\n\\ninterface IFastPool is IERC20 {\\n  // events\\n  event AddLiquidity(address user, uint wrappedBitcoinAmount); \\n  event RemoveLiquidity(address user, uint256 wrappedBitcoinAmount);\\n  event FastTransfer(address user, uint256 requestedAmount, uint256 transferredAmount, uint blockNumber);\\n\\n  // read-only functions\\n  function owner() external view returns (address);\\n  function wrappedBitcoin() external view returns (address); // gives back the wrapped bitcoin address\\n  function fastRouter() external view returns (address);\\n  function fastFee() external view returns (uint);\\n  function fastLimit() external view returns (uint);\\n  function fastConfirmationParameter() external view returns(uint);\\n  function totalRequestedAmount(uint blockNumber) external view returns(uint);\\n  function totalWrappedBitcoin() external view returns(uint);\\n\\n  // state-changing functions\\n  function changeOwner(address _owner) external;\\n  function setFastRouter(address _fastRouter) external;\\n  function setFastLimit(uint _fastLimit) external;\\n  function setFastFee(uint _fastFee) external;\\n  function setFastConfirmationParameter (uint _fastConfirmationParameter) external;\\n  function addLiquidity(address user, uint wrappedBitcoinAmount) external returns (uint);\\n  function removeLiquidity(address user, uint fastPoolTokenAmount) external returns (uint);\\n  function fastTransfer(address user, uint amount, uint blockNumber) external returns(bool);\\n}\",\"keccak256\":\"0x215efef21f04db1979779766f5046217cb060f64df0e8ead3e27ad920ff8c4a1\"},\"contracts/pools/interfaces/ILiquidityPool.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\nimport '../../erc20/interfaces/IERC20.sol';\\n\\ninterface ILiquidityPool is IERC20 {\\n    // events\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n    // read-only functions\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n    // state-changing functions\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n    // function initialize(address, address) external;\\n}\\n\",\"keccak256\":\"0x38d1961bb850ffcc3bccd3de2803e231b1b3fd5bbea9b85875dd005afc600181\"},\"contracts/pools/interfaces/ILiquidityPoolFactory.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\ninterface ILiquidityPoolFactory {\\n    // events\\n    event LiquidityPoolCreated(address indexed token0, address indexed token1, address pair, uint liquidityPoolsLength);\\n\\n    // read-only functions\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function getLiquidityPool(address tokenA, address tokenB) external view returns (address pair);\\n    function allLiquidityPools(uint number) external view returns (address pair);\\n    function allLiquidityPoolsLength() external view returns (uint);\\n\\n    // state-changing functions\\n    function createLiquidityPool(address tokenA, address tokenB) external returns (address pair);\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\",\"keccak256\":\"0x11e8a406afd3e558ca821261ed8ab8745c595f948353cf71af72b85f8f880d6e\"},\"contracts/routers/CCExchangeRouter.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\nimport \\\"./interfaces/ICCExchangeRouter.sol\\\";\\nimport \\\"./interfaces/IExchangeRouter.sol\\\";\\nimport \\\"./interfaces/ICCTransferRouter.sol\\\";\\nimport \\\"./interfaces/IInstantRouter.sol\\\";\\nimport \\\"../pools/interfaces/IFastPool.sol\\\";\\nimport \\\"../erc20/interfaces/IWrappedToken.sol\\\";\\nimport \\\"../teleporter/interfaces/IBitcoinTeleporter.sol\\\";\\nimport \\\"../libraries/BitcoinTxParser.sol\\\";\\nimport \\\"../libraries/TeleportDAOLibrary.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract CCExchangeRouter is ICCExchangeRouter {\\n    \\n    using SafeMath for uint;\\n    address ZERO_ADDRESS = 0x0000000000000000000000000000000000000000;\\n    mapping(uint => request) private requests;\\n    uint private lastRequest;\\n    address[] private parsedPath;\\n    address public override liquidityPoolFactory;\\n    address public override WAVAX;\\n    address public override exchangeRouter;\\n    address public override wrappedBitcoin;\\n    address public bitcoinTeleporter;\\n    address public ccTransferRouter;\\n    address public instantRouter;\\n    address public override owner;\\n    \\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    constructor (address _exchangeRouter, address _bitcoinTeleporter, address _ccTransferRouter) {\\n        exchangeRouter = _exchangeRouter;\\n        liquidityPoolFactory = IExchangeRouter(exchangeRouter).liquidityPoolFactory();\\n        WAVAX = IExchangeRouter(exchangeRouter).WAVAX();\\n        lastRequest = 0;    \\n        bitcoinTeleporter = _bitcoinTeleporter;\\n        ccTransferRouter = _ccTransferRouter;\\n        owner = msg.sender;\\n    }\\n\\n    function changeOwner(address _owner) external override onlyOwner {\\n        owner = _owner;\\n    }\\n\\n    function setBitcoinTeleporter (address _bitcoinTeleporter) external override onlyOwner {\\n        bitcoinTeleporter = _bitcoinTeleporter;\\n    } \\n\\n    function setWrappedBitcoin (address _wrappedBitcoin) external override onlyOwner {\\n        wrappedBitcoin = _wrappedBitcoin;\\n    } \\n\\n    function setCCTransferRouter (address _ccTransferRouter) external override onlyOwner {\\n        ccTransferRouter = _ccTransferRouter;\\n    }\\n\\n    function setInstantRouter (address _instantRouter) external override onlyOwner {\\n        instantRouter = _instantRouter;\\n    } \\n\\n    function setExchangeRouter (address _exchangeRouter) external override onlyOwner {\\n        exchangeRouter = _exchangeRouter;\\n        liquidityPoolFactory = IExchangeRouter(exchangeRouter).liquidityPoolFactory();\\n        WAVAX = IExchangeRouter(exchangeRouter).WAVAX();\\n    } \\n    // for executing \\\"normal\\\" and \\\"fast\\\" cross-chain exchange requests \\n    function ccExchange(\\n        bytes4 version,\\n        bytes memory vin,\\n        bytes calldata vout,\\n        bytes4 locktime,\\n        uint256 blockNumber,\\n        bytes calldata intermediateNodes,\\n        uint index,\\n        bool payWithTDT\\n    ) external override {\\n        uint256 currentRequest = lastRequest;\\n        require(\\n            parseBitcoinTransaction(vout),\\n            \\\"Transaction data is not correct\\\"\\n        );\\n        if (requests[currentRequest].deadline >= (block.number + 1)) { // deadline has not passed yet\\n            // mint wrapped token for cc exchange router\\n            mintWrappedBitcoin(\\n                version,\\n                vin,\\n                vout,\\n                locktime,\\n                blockNumber,\\n                intermediateNodes,\\n                index,\\n                payWithTDT\\n            );\\n            // pay teleporter fee\\n            IWrappedToken(wrappedBitcoin).transfer(\\n                requests[currentRequest].teleporterAddress,\\n                requests[currentRequest].teleporterFee\\n            );\\n\\n            if (requests[currentRequest].isFixedToken == false && requests[currentRequest].exchangeToken != WAVAX) {\\n                // give allowance to exchangeRouter to transferFrom CCExchangeRouter\\n                IWrappedToken(wrappedBitcoin).approve(\\n                    exchangeRouter,\\n                    requests[currentRequest].remainedInputAmount\\n                );\\n                uint[] memory amounts;\\n                bool result;\\n                (amounts, result) = swapExactTokensForTokens(\\n                    requests[currentRequest].remainedInputAmount,\\n                    requests[currentRequest].exchangeAmount,\\n                    requests[currentRequest].path,\\n                    requests[currentRequest].exchangeRecipientAddress,\\n                    requests[currentRequest].deadline\\n                );\\n                if (result) {\\n                    emit CCExchange(\\n                        requests[currentRequest].exchangeRecipientAddress,\\n                        requests[currentRequest].path[0],\\n                        requests[currentRequest].path[requests[currentRequest].path.length-1],\\n                        requests[currentRequest].remainedInputAmount,\\n                        amounts[amounts.length-1],\\n                        requests[currentRequest].speed\\n                    );\\n                } else {\\n                    paybackToUser(\\n                        version, \\n                        vin, \\n                        vout, \\n                        locktime, \\n                        blockNumber, \\n                        intermediateNodes, \\n                        index, \\n                        payWithTDT, \\n                        currentRequest\\n                    );\\n                }\\n            }\\n\\n            if (requests[currentRequest].isFixedToken == false && requests[currentRequest].exchangeToken == WAVAX) {\\n                // give allowance to exchangeRouter to transfer from CCExchangeRouter\\n                IWrappedToken(wrappedBitcoin).approve(\\n                    exchangeRouter,\\n                    requests[currentRequest].remainedInputAmount\\n                );\\n                uint[] memory amounts;\\n                bool result;\\n                (amounts, result) = swapExactTokensForAVAX(\\n                    requests[currentRequest].remainedInputAmount,\\n                    requests[currentRequest].exchangeAmount,\\n                    requests[currentRequest].path,\\n                    requests[currentRequest].exchangeRecipientAddress,\\n                    requests[currentRequest].deadline\\n                );\\n                if (result) {\\n                    emit CCExchange(\\n                        requests[currentRequest].exchangeRecipientAddress,\\n                        requests[currentRequest].path[0],\\n                        requests[currentRequest].path[requests[currentRequest].path.length-1],\\n                        requests[currentRequest].remainedInputAmount,\\n                        amounts[amounts.length-1],\\n                        requests[currentRequest].speed\\n                    );\\n                } else {\\n                    paybackToUser(\\n                        version, \\n                        vin, \\n                        vout, \\n                        locktime, \\n                        blockNumber, \\n                        intermediateNodes, \\n                        index, \\n                        payWithTDT, \\n                        currentRequest\\n                    );\\n                }\\n\\n            }\\n            \\n        }\\n\\n        if (requests[currentRequest].deadline < (block.number + 1)) { // deadline has passed\\n            paybackToUser(version, vin, vout, locktime, blockNumber, intermediateNodes, index, payWithTDT, currentRequest);\\n        }\\n        \\n    }\\n\\n    function instantCCExchangeWithPermit(\\n        address signer,\\n        bytes memory signature,\\n        uint amountIn, \\n        uint amountOutMin, \\n        address[] memory path, \\n        address receiver, \\n        uint deadline\\n    ) external override {\\n        uint[] memory amounts;\\n        bool result;\\n        (amounts, result) = IInstantRouter(instantRouter).instantCCExchangeWithPermit(\\n            signer,\\n            signature,\\n            amountIn, \\n            amountOutMin, \\n            path, \\n            receiver, \\n            deadline\\n        );\\n        emit CCExchange(\\n            receiver,\\n            path[0],\\n            path[path.length-1],\\n            amountIn,\\n            amounts[amounts.length-1],\\n            2 // 2 means instant\\n        );\\n    }\\n\\n    function paybackToUser (\\n        bytes4 version,\\n        bytes memory vin,\\n        bytes calldata vout,\\n        bytes4 locktime,\\n        uint256 blockNumber,\\n        bytes calldata intermediateNodes,\\n        uint index,\\n        bool payWithTDT,\\n        uint currentRequest\\n    ) internal {\\n        // mint wrapped token for cc exchange router\\n        mintWrappedBitcoin(\\n                version,\\n                vin,\\n                vout,\\n                locktime,\\n                blockNumber,\\n                intermediateNodes,\\n                index,\\n                payWithTDT\\n        );\\n        // transfer wrapped tokens to user\\n        IWrappedToken(wrappedBitcoin).transfer(\\n                requests[currentRequest].exchangeRecipientAddress,\\n                requests[currentRequest].remainedInputAmount\\n        );\\n        // pay teleporter fee\\n            IWrappedToken(wrappedBitcoin).transfer(\\n                requests[currentRequest].teleporterAddress,\\n                requests[currentRequest].teleporterFee\\n        );\\n    }\\n\\n    function parseBitcoinTransaction(bytes memory vout) internal returns (bool){\\n        bytes memory arbitraryData;\\n        // TODO: edit address for parseTxOutputs\\n        address desiredRecipient;\\n        desiredRecipient = IBitcoinTeleporter(bitcoinTeleporter).redeemScriptHash();\\n        (requests[lastRequest].bitcoinAmount, arbitraryData) = BitcoinTxParser.parseAmountForP2SH(vout, desiredRecipient);\\n        requests[lastRequest].exchangeAmount = BitcoinTxParser.parseExchangeAmount(arbitraryData);\\n        requests[lastRequest].isFixedToken = BitcoinTxParser.parseIsFixedToken(arbitraryData);\\n        requests[lastRequest].exchangeRecipientAddress = BitcoinTxParser.parseRecipientAddress(arbitraryData);\\n        requests[lastRequest].teleporterFee = BitcoinTxParser.parseTeleporterFee(arbitraryData);\\n        requests[lastRequest].exchangeToken = BitcoinTxParser.parseExchangeToken(arbitraryData);\\n        requests[lastRequest].path = [wrappedBitcoin, requests[lastRequest].exchangeToken];\\n        requests[lastRequest].teleporterAddress = msg.sender; //TODO: check who is the msg.sender? teleporter or dex?\\n        requests[lastRequest].deadline = BitcoinTxParser.parseDeadline(arbitraryData);\\n        requests[lastRequest].isExchange = BitcoinTxParser.parseIsExchange(arbitraryData);\\n        requests[lastRequest].speed = BitcoinTxParser.parseSpeed(arbitraryData);\\n        requests[lastRequest].remainedInputAmount = parseRemainedInputAmount(\\n            requests[lastRequest].bitcoinAmount,\\n            requests[lastRequest].teleporterFee,\\n            requests[lastRequest].speed\\n        );\\n        lastRequest = lastRequest + 1;\\n        return true;\\n    }\\n\\n    function parseRemainedInputAmount(\\n        uint256 bitcoinAmount, \\n        uint256 teleporterFee, \\n        uint speed\\n    ) internal view returns (uint256) {\\n        \\n        if(speed == 0) { // normal cc exchange\\n            require(bitcoinAmount > teleporterFee, \\\"Insufficient fund\\\");\\n            return bitcoinAmount.sub(teleporterFee);\\n        }\\n\\n        if(speed == 1) { // fast cc exchange\\n            // get the fastFee from the fastPool\\n            address bitcoinFastPool;\\n            bitcoinFastPool = ICCTransferRouter(ccTransferRouter).bitcoinFastPool();\\n            uint fastFee = IFastPool(bitcoinFastPool).fastFee();\\n            uint bitcoinAmountAfterFastFee = bitcoinAmount*(100-fastFee)/100;\\n            require(bitcoinAmountAfterFastFee > teleporterFee, \\\"Insufficient fund\\\");\\n            return bitcoinAmountAfterFastFee.sub(teleporterFee);\\n        }        \\n\\n        if(speed == 2) { // instant cc exchange\\n            require(bitcoinAmount > teleporterFee, \\\"Insufficient fund\\\");\\n            return bitcoinAmount.sub(teleporterFee);\\n        }      \\n    }\\n\\n    function mintWrappedBitcoin(\\n        bytes4 version,\\n        bytes memory vin,\\n        bytes memory vout,\\n        bytes4 locktime,\\n        uint256 blockNumber,\\n        bytes memory intermediateNodes,\\n        uint index,\\n        bool payWithTDT\\n    ) internal {\\n        //_WrappedToken = wrappedTokenContract;\\n        //require(_WrappedToken.mint(blockNumber, rawTransaction, encodedPath, rlpParentNodes) == ture);\\n        require(\\n            ICCTransferRouter(ccTransferRouter).ccTransfer(\\n                version,\\n                vin,\\n                vout,\\n                locktime,\\n                blockNumber,\\n                intermediateNodes,\\n                index,\\n                payWithTDT\\n            )\\n        );\\n    }\\n\\n    // check slippage and deadline\\n    // make it modifier if good\\n    function checkConditions(uint256 requestNumber) internal returns (bool) {\\n        uint256[] memory amounts;\\n        if (requests[requestNumber].isFixedToken == false) {\\n            amounts = TeleportDAOLibrary.getAmountsOut(\\n                liquidityPoolFactory,\\n                requests[requestNumber].remainedInputAmount,\\n                requests[requestNumber].path\\n            );\\n            require(\\n                amounts[amounts.length - 1] >= requests[requestNumber].exchangeAmount,\\n                \\\"exchangeRouter: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n            );\\n        }\\n        if (requests[requestNumber].isFixedToken == true) {\\n            amounts = TeleportDAOLibrary.getAmountsIn(\\n                liquidityPoolFactory,\\n                requests[requestNumber].exchangeAmount,\\n                requests[requestNumber].path\\n            );\\n            require(\\n                amounts[0] <= requests[requestNumber].remainedInputAmount,\\n                \\\"exchangeRouter: EXCESSIVE_INPUT_AMOUNT\\\"\\n            );\\n        }\\n    }\\n\\n    function bytesToAddress(bytes memory bys) internal pure returns (address) {\\n        address addr;\\n        assembly {\\n            addr := mload(add(bys, 20))\\n        }\\n        return addr;\\n    }\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) internal returns(uint[] memory amounts, bool result) {\\n        (amounts, result) = IExchangeRouter(exchangeRouter).swapExactTokensForTokens(\\n            amountIn,\\n            amountOutMin,\\n            path,\\n            to,\\n            deadline\\n        );\\n    }\\n\\n    // TODO: this function does not exist in the exchangeRouter. why?\\n    // function _fromDEX_swapTokensForExactTokensSupportingFeeOnTransferTokens(\\n    //     uint amountIn,\\n    //     uint amountOutMin,\\n    //     address[] memory path,\\n    //     address to\\n    // ) internal {\\n\\n    // }\\n\\n    // TODO: internal functions cannot be payable\\n    // function _fromDEX_swapExactAVAXForTokensSupportingFeeOnTransferTokens(\\n    //     uint amountOutMin,\\n    //     address[] memory path,\\n    //     address to\\n    // ) internal payable {\\n\\n    // }\\n\\n    function swapExactTokensForAVAX(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) internal returns(uint[] memory amounts, bool result) {\\n        (amounts, result) = IExchangeRouter(exchangeRouter).swapExactTokensForAVAX(\\n            amountIn,\\n            amountOutMin,\\n            path,\\n            to,\\n            deadline\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xd28c06795ae7f79b3f930fbd12c88f90d8d53134028114f9ae4453819e12b1b0\"},\"contracts/routers/interfaces/ICCExchangeRouter.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\ninterface ICCExchangeRouter {\\n    // structures\\n    struct request{\\n        uint bitcoinAmount; //total amount of tokenA (exchange + fee)\\n        uint exchangeAmount;\\n        uint remainedInputAmount;\\n        address exchangeToken; // exchangeToken pool address on DEX\\n        bool isFixedToken;\\n        address bitcoinRecipient;\\n        address exchangeRecipientAddress;\\n        address[] path;\\n        uint teleporterFee;\\n        address teleporterAddress;\\n        uint deadline;\\n        bool isExchange;\\n        uint speed;\\n    }\\n\\n    // events\\n    event CCExchange(address user, address inputToken, address outputToken, uint inputAmount, uint outputAmount, uint speed);\\n\\n    // read-only functions\\n    function owner() external view returns (address);\\n    function liquidityPoolFactory() external view returns(address);\\n    function WAVAX() external view returns(address);\\n    function exchangeRouter() external view returns(address);\\n    function wrappedBitcoin() external view returns(address);\\n\\n    // state-changing functions\\n    function changeOwner(address _owner) external;\\n    function setInstantRouter (address _instantRouter) external;\\n    function setBitcoinTeleporter (address _bitcoinTeleporter) external;\\n    function setCCTransferRouter (address _ccTransferRouter) external;\\n    function setExchangeRouter (address _exchangeRouter) external;\\n    function setWrappedBitcoin (address _wrappedBitcoin) external;\\n    function ccExchange(\\n        bytes4 version,\\n        bytes memory vin,\\n        bytes calldata vout,\\n        bytes4 locktime,\\n        uint256 blockNumber,\\n        bytes calldata intermediateNodes,\\n        uint index,\\n        bool payWithTDT\\n    ) external;\\n    function instantCCExchangeWithPermit(\\n        address signer,\\n        bytes memory signature,\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] memory path,\\n        address receiver,\\n        uint deadline\\n    ) external;\\n}\\n\",\"keccak256\":\"0x66738730b7404359fef12a5ec02667eb633ec0f9a3b6a60dfd00d4cbcadaa30a\"},\"contracts/routers/interfaces/ICCTransferRouter.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity ^0.7.6;\\n\\ninterface ICCTransferRouter {\\n\\n  struct wrapRequest {\\n    uint bitcoinAmount;\\n    address recipientAddress;\\n    bool isExchange;\\n    uint teleporterFee; // TODO: should I change it to uint8?\\n    uint256 speed;\\n    bool isUsed;\\n    uint deadline;\\n    uint blockNumber; // only store for fast transfers\\n    bytes intermediateNodes; // only store for fast transfers\\n    uint index; // only store for fast transfers\\n    bool isMinted; // initially is false for fast tranfer\\n    uint exchangeAmount;\\n    address exchangeToken;\\n  }\\n\\n  // events\\n  event CCTransfer(address user, address inputToken, uint inputAmount, uint speed);\\n  event PaybackFastLoan(address user, uint amount);\\n\\n  // read-only functions\\n  function owner() external view returns (address);\\n  function isRequestUsed(bytes32 txId) external view returns(bool);\\n  function isRequestMinted(bytes32 txId) external view returns(bool);\\n  function wrappedBitcoin() external view returns(address);\\n  function bitcoinFastPool() external view returns(address);\\n  function normalConfirmationParameter() external view returns(uint);\\n\\n  // state-changing functions\\n  function changeOwner (address _owner) external;\\n  function setNormalConfirmationParameter (uint _normalConfirmationParameter) external;\\n  function setBitcoinRelay (address _bitcoinRelay) external;\\n  function setFastRouter (address _fastRouter) external;\\n  function setWrappedBitcoin (address _wrappedBitcoin) external returns (bool);\\n  function setInstantRouter (address _instantRouter) external;\\n  function setCCExchangeRouter (address _ccExchangeRouter) external;\\n\\n  function ccTransfer(\\n    bytes4 version,\\n    bytes memory vin,\\n    bytes calldata vout,\\n    bytes4 locktime,\\n    uint256 blockNumber,\\n    bytes calldata intermediateNodes,\\n    uint index,\\n    bool payWithTDT\\n  ) external returns(bool);\\n  function mintAfterFinalization(bytes32 txId) external returns(bool);\\n  function instantCCTransferWithPermit(\\n    address signer,\\n    bytes memory signature,\\n    address receiver,\\n    uint instantTokenAmount,\\n    uint deadline\\n  ) external returns(bool);\\n}\",\"keccak256\":\"0x5d66660880a3baefbd1c6518ef26d375e175ceba302b16617e464b1f11f1bc82\"},\"contracts/routers/interfaces/IExchangeRouter.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\ninterface IExchangeRouter {\\n    // read-only functions\\n    function liquidityPoolFactory() external view returns (address);\\n    // function bitcoinInstantPool() external view returns (address);\\n    // function wrappedBitcoin() external view returns (address);\\n    function WAVAX() external view returns (address);\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external returns (uint[] memory amounts);\\n\\n    // state-changing functions\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityAVAX(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountAVAXMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityAVAX(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountAVAXMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountAVAX);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts, bool result);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactAVAXForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n    function swapTokensForExactAVAX(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to, uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactTokensForAVAX(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to, uint deadline\\n    ) external returns (uint[] memory amounts, bool result);\\n    function swapAVAXForExactTokens(\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\",\"keccak256\":\"0x498fbfb3d4028594c685b3b7c6b6b293bf25ff877399fe54626ae224d3552aa4\"},\"contracts/routers/interfaces/IInstantRouter.sol\":{\"content\":\"pragma solidity >=0.7.6;\\n\\ninterface IInstantRouter {\\n    // structures\\n    struct InstantTransferRequest {\\n        address user;\\n        uint collateralAmount;\\n        uint wrappedBitcoinAmount;\\n        uint creationTime;\\n        uint deadline;\\n        uint paybackDeadline;\\n        bool isPaidback;\\n        bool isUsed;\\n    }\\n    struct debt {\\n        address user;\\n        uint wrappedBitcoinAmount;\\n        uint collateralAmount;\\n        uint deadline;\\n    }\\n\\n    // events\\n    event PaybackInstantLoan(address user, uint bitcoinAmount);\\n    event PunishUser(address user, uint slashedAmount);\\n\\n    // read-only functions\\n    function owner() external view returns(address);\\n    function bitcoinInstantPool() external view returns(address);\\n    function wrappedBitcoin() external view returns(address);\\n    function ccTransferRouter() external view returns(address);\\n    function requestCollateralAmount(bytes32 messageHash) external view returns(uint);\\n    function paybackDeadline() external returns(uint);\\n    function collateralRatio() external returns(uint);\\n\\n    // state-changing functions\\n    function changeOwner(address _owner) external;\\n    function setExchangeRouter(address _ExchangeRouter) external;\\n    function setPaybackDeadline(uint _paybackDeadline) external;\\n    function setCollateralRatio(uint _paybackDeadline) external;\\n    function setCCTransferRouter (address _ccTransferRouter) external;\\n    function setPunisherReward (uint _punisherReward) external;\\n    function addLiquidity(address user, uint instantPoolTokenAmount) external returns(uint);\\n    function removeLiquidity(address user, uint instantPoolTokenAmount) external returns(uint);\\n    function instantCCTransfer (address receiver, uint amount, uint deadline) external returns (bool);\\n    function instantCCTransferWithPermit(\\n        address signer,\\n        bytes memory signature,\\n        address receiver,\\n        uint amount,\\n        uint nonce\\n    ) external returns(bool);\\n    function instantCCExchange (\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] memory path,\\n        address receiver,\\n        uint deadline\\n    ) external returns(uint[] memory amounts, bool result);\\n    function instantCCExchangeWithPermit(\\n        address signer,\\n        bytes memory signature,\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] memory path,\\n        address receiver,\\n        uint deadline\\n    ) external returns(uint[] memory amounts, bool result);\\n    function payBackInstantTransfer (uint bitcoinAmount, address user) external returns (bool);\\n    function punishUser (address user, uint[] memory debtIndex) external returns (bool);\\n\\n}\",\"keccak256\":\"0xeaabb34c7330bab37bdda379df374ff23fc0636d3aeba9aad5f5754b7242583d\"},\"contracts/teleporter/interfaces/IBitcoinTeleporter.sol\":{\"content\":\"pragma solidity 0.7.6;\\n\\ninterface IBitcoinTeleporter {\\n    // structures\\n    struct teleporter {\\n        bytes teleporterBitcoinPubKey;\\n        address teleporterAddress;\\n    }\\n\\n    // events\\n    event AddTeleporter(bytes teleporterBitcoinPubKey, address teleporterAddress, uint lockedAmount, uint addedtime);\\n    event RemoveTeleporter(bytes teleporterBitcoinPubKey, address teleporterAddress, uint unlockedAmount);\\n\\n    // read-only functions\\n    function owner() external view returns (address);\\n    function TeleportDAOToken() external view returns(address);\\n    function wrappedBitcoin() external view returns(address);\\n    function ccBurnRouter() external view returns(address);\\n    function exchangeRouter() external view returns(address);\\n    function requiredLockedAmount() external view returns(uint);\\n    function numberOfTeleporters() external view returns(uint);\\n    function redeemScript() external view returns(bytes memory);\\n    function redeemScriptHash() external view returns(address);\\n    function multisigAddress() external view returns(address);\\n    function multisigAddressBeforeEncoding() external view returns(bytes memory);\\n    function isTeleporter (address teleporter, uint index) external view returns(bool);\\n\\n    // state-changing functions\\n    function changeOwner(address _owner) external;\\n    function setUnlockFee(uint _unlockFee) external;\\n    function setUnlockPeriod(uint _unlockPeriod) external;\\n    function setRequiredLockedAmount(uint _submissionGasUsed) external;\\n    function setExchangeRouter(address _ccTransferRouter) external;\\n    function setCCBurnRouter(address _ccBurnRouter) external;\\n    function setWrappedBitcoin(address _wrappedBitcoin) external;\\n    function addTeleporter(bytes memory teleporterAddress) external returns(bool);\\n    function removeTeleporter(uint teleporterIndex) external returns(bool);\\n    function slashTeleporters (uint amount, address recipient) external;\\n}\",\"keccak256\":\"0x90c0048bb9d29f13abf09ade612feb17e66e102cf23f4c7e5dbd45aa41401a1b\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080604052600080546001600160a01b03191690553480156200002157600080fd5b50604051620033f4380380620033f4833981810160405260608110156200004757600080fd5b508051602080830151604093840151600680546001600160a01b0319166001600160a01b038087169190911791829055865163e75d75d560e01b8152965195969395929491169263e75d75d59260048083019392829003018186803b158015620000b057600080fd5b505afa158015620000c5573d6000803e3d6000fd5b505050506040513d6020811015620000dc57600080fd5b5051600480546001600160a01b0319166001600160a01b03928316178155600654604080516339d94ae160e11b8152905191909316926373b295c29281810192602092909190829003018186803b1580156200013757600080fd5b505afa1580156200014c573d6000803e3d6000fd5b505050506040513d60208110156200016357600080fd5b5051600580546001600160a01b039283166001600160a01b031991821617909155600060025560088054948316948216949094179093556009805492909116918316919091179055600b8054909116331790555061322d80620001c76000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c8063838b7ccb11610097578063d1d8d2ed11610066578063d1d8d2ed146104ea578063e35a0a88146104f2578063e75d75d5146104fa578063f5ded5181461050257610100565b8063838b7ccb14610470578063870ba6cf146104965780638da5cb5b146104bc578063a6f9dae1146104c457610100565b80632f1ed7cb116100d35780632f1ed7cb146102ea5780635615e16f1461043a57806373b295c2146104425780637f3c8b211461044a57610100565b806307980dcd146101055780630981a6661461027a5780631cb85818146102a05780631f8a4db9146102c4575b600080fd5b610278600480360361010081101561011c57600080fd5b6001600160e01b03198235169190810190604081016020820135600160201b81111561014757600080fd5b82018360208201111561015957600080fd5b803590602001918460018302840111600160201b8311171561017a57600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295949360208101935035915050600160201b8111156101cc57600080fd5b8201836020820111156101de57600080fd5b803590602001918460018302840111600160201b831117156101ff57600080fd5b919390926001600160e01b0319833516926020810135929190606081019060400135600160201b81111561023257600080fd5b82018360208201111561024457600080fd5b803590602001918460018302840111600160201b8311171561026557600080fd5b919350915080359060200135151561050a565b005b6102786004803603602081101561029057600080fd5b50356001600160a01b0316610cdf565b6102a8610d18565b604080516001600160a01b039092168252519081900360200190f35b610278600480360360208110156102da57600080fd5b50356001600160a01b0316610d27565b610278600480360360e081101561030057600080fd5b6001600160a01b038235169190810190604081016020820135600160201b81111561032a57600080fd5b82018360208201111561033c57600080fd5b803590602001918460018302840111600160201b8311171561035d57600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295843595602086013595919450925060608101915060400135600160201b8111156103bb57600080fd5b8201836020820111156103cd57600080fd5b803590602001918460208302840111600160201b831117156103ee57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929550506001600160a01b038335169350505060200135610d60565b6102a8611038565b6102a8611047565b6102786004803603602081101561046057600080fd5b50356001600160a01b0316611056565b6102786004803603602081101561048657600080fd5b50356001600160a01b031661108f565b610278600480360360208110156104ac57600080fd5b50356001600160a01b03166111d4565b6102a861120d565b610278600480360360208110156104da57600080fd5b50356001600160a01b031661121c565b6102a8611255565b6102a8611264565b6102a8611273565b6102a8611282565b600254604080516020601f8b0181900481028201810190925289815261054a918b908b908190840183828082843760009201919091525061129192505050565b61059b576040805162461bcd60e51b815260206004820152601f60248201527f5472616e73616374696f6e2064617461206973206e6f7420636f727265637400604482015290519081900360640190fd5b43600101600160008381526020019081526020016000206009015410610c9e576106388b8b8b8b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050604080516020601f8d018190048102820181019092528b81528e93508d9250908c908c90819084018382808284376000920191909152508c92508b91506115729050565b6007805460008381526001602090815260408083206008810154950154815163a9059cbb60e01b81526001600160a01b03968716600482015260248101919091529051949093169363a9059cbb93604480820194918390030190829087803b1580156106a357600080fd5b505af11580156106b7573d6000803e3d6000fd5b505050506040513d60208110156106cd57600080fd5b5050600081815260016020526040902060030154600160a01b900460ff1615801561071857506005546000828152600160205260409020600301546001600160a01b03908116911614155b156109b757600754600654600083815260016020908152604080832060020154815163095ea7b360e01b81526001600160a01b03958616600482015260248101919091529051939094169363095ea7b39360448083019491928390030190829087803b15801561078757600080fd5b505af115801561079b573d6000803e3d6000fd5b505050506040513d60208110156107b157600080fd5b50506000818152600160208181526040808420600281015493810154600690910180548351818602810186019094528084526060969561085995909492919083018282801561082957602002820191906000526020600020905b81546001600160a01b0316815260019091019060200180831161080b575b505050600089815260016020526040902060058101546009909101546001600160a01b039091169250905061176f565b909250905080156109a15760008381526001602052604081206005810154600690910180547fc8d4f413dd655a643206b602c9646c4d2a668af80f1a8d5879c9bb38911f85c0936001600160a01b0390931692906108b357fe5b60009182526020808320909101548783526001909152604090912060060180546001600160a01b039092169160001981019081106108ed57fe5b6000918252602080832090910154888352600190915260409091206002015486516001600160a01b03909216918790600019810190811061092a57fe5b6020026020010151600160008a8152602001908152602001600020600b015460405180876001600160a01b03168152602001866001600160a01b03168152602001856001600160a01b03168152602001848152602001838152602001828152602001965050505050505060405180910390a16109b4565b6109b48d8d8d8d8d8d8d8d8d8d8d6118ff565b50505b600081815260016020526040902060030154600160a01b900460ff161580156109ff57506005546000828152600160205260409020600301546001600160a01b039081169116145b15610c9e57600754600654600083815260016020908152604080832060020154815163095ea7b360e01b81526001600160a01b03958616600482015260248101919091529051939094169363095ea7b39360448083019491928390030190829087803b158015610a6e57600080fd5b505af1158015610a82573d6000803e3d6000fd5b505050506040513d6020811015610a9857600080fd5b505060008181526001602081815260408084206002810154938101546006909101805483518186028101860190945280845260609695610b40959094929190830182828015610b1057602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610af2575b505050600089815260016020526040902060058101546009909101546001600160a01b0390911692509050611ab7565b90925090508015610c885760008381526001602052604081206005810154600690910180547fc8d4f413dd655a643206b602c9646c4d2a668af80f1a8d5879c9bb38911f85c0936001600160a01b039093169290610b9a57fe5b60009182526020808320909101548783526001909152604090912060060180546001600160a01b03909216916000198101908110610bd457fe5b6000918252602080832090910154888352600190915260409091206002015486516001600160a01b039092169187906000198101908110610c1157fe5b6020026020010151600160008a8152602001908152602001600020600b015460405180876001600160a01b03168152602001866001600160a01b03168152602001856001600160a01b03168152602001848152602001838152602001828152602001965050505050505060405180910390a1610c9b565b610c9b8d8d8d8d8d8d8d8d8d8d8d6118ff565b50505b4360010160016000838152602001908152602001600020600901541015610cd257610cd28b8b8b8b8b8b8b8b8b8b8b6118ff565b5050505050505050505050565b600b546001600160a01b03163314610cf657600080fd5b600780546001600160a01b0319166001600160a01b0392909216919091179055565b6006546001600160a01b031681565b600b546001600160a01b03163314610d3e57600080fd5b600880546001600160a01b0319166001600160a01b0392909216919091179055565b60606000600a60009054906101000a90046001600160a01b03166001600160a01b0316632f1ed7cb8a8a8a8a8a8a8a6040518863ffffffff1660e01b815260040180886001600160a01b031681526020018060200187815260200186815260200180602001856001600160a01b03168152602001848152602001838103835289818151815260200191508051906020019080838360005b83811015610e0f578181015183820152602001610df7565b50505050905090810190601f168015610e3c5780820380516001836020036101000a031916815260200191505b508381038252865181528651602091820191808901910280838360005b83811015610e71578181015183820152602001610e59565b505050509050019950505050505050505050600060405180830381600087803b158015610e9d57600080fd5b505af1158015610eb1573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040908152811015610eda57600080fd5b8101908080516040519392919084600160201b821115610ef957600080fd5b908301906020820185811115610f0e57600080fd5b82518660208202830111600160201b82111715610f2a57600080fd5b82525081516020918201928201910280838360005b83811015610f57578181015183820152602001610f3f565b50505050919091016040525060200151885193955093507fc8d4f413dd655a643206b602c9646c4d2a668af80f1a8d5879c9bb38911f85c092879250889150600090610f9f57fe5b602002602001015187600189510381518110610fb757fe5b60200260200101518a86600188510381518110610fd057fe5b6020026020010151600260405180876001600160a01b03168152602001866001600160a01b03168152602001856001600160a01b03168152602001848152602001838152602001828152602001965050505050505060405180910390a1505050505050505050565b6007546001600160a01b031681565b6005546001600160a01b031681565b600b546001600160a01b0316331461106d57600080fd5b600980546001600160a01b0319166001600160a01b0392909216919091179055565b600b546001600160a01b031633146110a657600080fd5b600680546001600160a01b0319166001600160a01b0383811691909117918290556040805163e75d75d560e01b81529051929091169163e75d75d591600480820192602092909190829003018186803b15801561110257600080fd5b505afa158015611116573d6000803e3d6000fd5b505050506040513d602081101561112c57600080fd5b5051600480546001600160a01b0319166001600160a01b03928316178155600654604080516339d94ae160e11b8152905191909316926373b295c29281810192602092909190829003018186803b15801561118657600080fd5b505afa15801561119a573d6000803e3d6000fd5b505050506040513d60208110156111b057600080fd5b5051600580546001600160a01b0319166001600160a01b0390921691909117905550565b600b546001600160a01b031633146111eb57600080fd5b600a80546001600160a01b0319166001600160a01b0392909216919091179055565b600b546001600160a01b031681565b600b546001600160a01b0316331461123357600080fd5b600b80546001600160a01b0319166001600160a01b0392909216919091179055565b6008546001600160a01b031681565b600a546001600160a01b031681565b6004546001600160a01b031681565b6009546001600160a01b031681565b600060606000600860009054906101000a90046001600160a01b03166001600160a01b03166375a31bb16040518163ffffffff1660e01b815260040160206040518083038186803b1580156112e557600080fd5b505afa1580156112f9573d6000803e3d6000fd5b505050506040513d602081101561130f57600080fd5b5051905061131d8482611b40565b60025460009081526001602052604090206001600160401b03909216909155915061134782611c26565b6fffffffffffffffffffffffffffffffff166001600060025481526020019081526020016000206001018190555061137e82611c41565b60025460009081526001602052604090206003018054911515600160a01b0260ff60a01b199092169190911790556113b582611c8e565b600254600090815260016020526040902060050180546001600160a01b0319166001600160a01b03929092169190911790556113f082611ca9565b60025460009081526001602052604090206001600160401b039190911660079091015561141c82611cc4565b600280546000908152600160208181526040808420600390810180546001600160a01b0319166001600160a01b039889161790558151808301835260075488168152865480875285855292862091820154909716878401529352526114869260069091019161309a565b50600254600090815260016020526040902060080180546001600160a01b031916331790556114b482611cd4565b60025460009081526001602052604090206001600160401b03919091166009909101556114e082611ce4565b6002546000908152600160205260409020600a01805460ff191691151591909117905561150c82611cf3565b6002805460009081526001602052604080822060ff94909416600b948501559154815220805460078201549190920154611547929190611d0d565b600280546000908152600160208190526040909120820192909255805482019055925050505b919050565b600954604051630e70f50360e21b81526001600160e01b0319808b166004830190815290881660648301526084820187905260c4820185905283151560e4830152610100602483019081528a516101048401528a516001600160a01b03909416936339c3d40c938d938d938d938d938d938d938d938d93604481019160a4820191610124019060208d019080838360005b8381101561161b578181015183820152602001611603565b50505050905090810190601f1680156116485780820380516001836020036101000a031916815260200191505b5084810383528a5181528a516020918201918c019080838360005b8381101561167b578181015183820152602001611663565b50505050905090810190601f1680156116a85780820380516001836020036101000a031916815260200191505b50848103825287518152875160209182019189019080838360005b838110156116db5781810151838201526020016116c3565b50505050905090810190601f1680156117085780820380516001836020036101000a031916815260200191505b509b505050505050505050505050602060405180830381600087803b15801561173057600080fd5b505af1158015611744573d6000803e3d6000fd5b505050506040513d602081101561175a57600080fd5b505161176557600080fd5b5050505050505050565b6006546040516338ed173960e01b815260048101878152602482018790526001600160a01b0385811660648401526084830185905260a060448401908152875160a485015287516060956000959316936338ed1739938c938c938c938c938c93919260c490910190602080880191028083838f5b838110156117fb5781810151838201526020016117e3565b505050509050019650505050505050600060405180830381600087803b15801561182457600080fd5b505af1158015611838573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604090815281101561186157600080fd5b8101908080516040519392919084600160201b82111561188057600080fd5b90830190602082018581111561189557600080fd5b82518660208202830111600160201b821117156118b157600080fd5b82525081516020918201928201910280838360005b838110156118de5781810151838201526020016118c6565b50505050919091016040525060200151929a92995091975050505050505050565b61197c8b8b8b8b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050604080516020601f8d018190048102820181019092528b81528e93508d9250908c908c90819084018382808284376000920191909152508c92508b91506115729050565b60075460008281526001602090815260408083206005810154600290910154825163a9059cbb60e01b81526001600160a01b0392831660048201526024810191909152915194169363a9059cbb93604480840194938390030190829087803b1580156119e757600080fd5b505af11580156119fb573d6000803e3d6000fd5b505050506040513d6020811015611a1157600080fd5b50506007805460008381526001602090815260408083206008810154950154815163a9059cbb60e01b81526001600160a01b03968716600482015260248101919091529051949093169363a9059cbb93604480820194918390030190829087803b158015611a7e57600080fd5b505af1158015611a92573d6000803e3d6000fd5b505050506040513d6020811015611aa857600080fd5b50505050505050505050505050565b60065460405163676528d160e01b815260048101878152602482018790526001600160a01b0385811660648401526084830185905260a060448401908152875160a4850152875160609560009593169363676528d1938c938c938c938c938c93919260c490910190602087810191028083838f83156117fb5781810151838201526020016117e3565b6000606081611b5d611b528683611f17565b62ffffff1916611f3d565b9050600080600080600060606000611b7688600061206b565b6001600160401b0316905060005b81811015611c1457611b968982612184565b9750611ba18861228b565b9550611bac866122ea565b945062ffffff198086161415611bfa57611bcd62ffffff19871660036123bb565b93508b6001600160a01b0316846001600160a01b03161415611bf557611bf2886123c9565b96505b611c0c565b611c0962ffffff1986166123dd565b92505b600101611b84565b50949b909a5098505050505050505050565b600080611c36836032604161241c565b601001519392505050565b600080611c5083604a8061241c565b8051909150600090819083908290611c6457fe5b01602001516001600160f81b0319161415611c825760009250611c87565b600192505b5050919050565b600080611c9e836000601361241c565b601401519392505050565b600080611cb9836014601b61241c565b600801519392505050565b600080611c9e83601e603161241c565b600080611cb9836042604961241c565b600080611c5083601c8061241c565b600080611d0283601d8061241c565b600101519392505050565b600081611d6d57828411611d5c576040805162461bcd60e51b8152602060048201526011602482015270125b9cdd59999a58da595b9d08199d5b99607a1b604482015290519081900360640190fd5b611d6684846124d7565b9050611f10565b8160011415611ebf576009546040805163637a30c160e11b815290516000926001600160a01b03169163c6f46182916004808301926020929190829003018186803b158015611dbb57600080fd5b505afa158015611dcf573d6000803e3d6000fd5b505050506040513d6020811015611de557600080fd5b505160408051630c2dc8d960e41b815290519192506000916001600160a01b0384169163c2dc8d90916004808301926020929190829003018186803b158015611e2d57600080fd5b505afa158015611e41573d6000803e3d6000fd5b505050506040513d6020811015611e5757600080fd5b505190506064818103870204858111611eab576040805162461bcd60e51b8152602060048201526011602482015270125b9cdd59999a58da595b9d08199d5b99607a1b604482015290519081900360640190fd5b611eb581876124d7565b9350505050611f10565b8160021415611f1057828411611d5c576040805162461bcd60e51b8152602060048201526011602482015270125b9cdd59999a58da595b9d08199d5b99607a1b604482015290519081900360640190fd5b9392505050565b815160009060208401611f3264ffffffffff85168284612527565b925050505b92915050565b60008181611f53815b62ffffff19841690612561565b50611f6362ffffff19851661269f565b6001600160601b0316611f7f57611f786126ae565b9250611c87565b6000611f8c85600061206b565b90506000611f9f62ffffff19871661269f565b6001600160601b031690506001600160401b038216611fc957611fc06126ae565b94505050611c87565b6000611fd4836126b6565b60ff16905060005b836001600160401b03168110156120355782821061200757611ffc6126ae565b965050505050611c87565b600061201d62ffffff198a16848603600e61270f565b905061202881612740565b9092019150600101611fdc565b5081811461204f576120456126ae565b9550505050611c87565b61206062ffffff198816600f612782565b979650505050505050565b60008061208062ffffff198516846001612794565b905060fc8111612091579050611f37565b8060fd14156120e7576120af62ffffff1985166001850160026127b5565b91506120ba826126b6565b60ff166003146120e2576120e06120db62ffffff19861685600360006127ca565b61282f565b505b61217d565b8060fe14156121315761210562ffffff1985166001850160046127b5565b9150612110826126b6565b60ff166005146120e2576120e06120db62ffffff19861685600560006127ca565b8060ff141561217d5761214f62ffffff1985166001850160086127b5565b915061215a826126b6565b60ff1660091461217d5761217b6120db62ffffff19861685600960006127ca565b505b5092915050565b60008061219284600061206b565b6001600160401b0316905060006121ae62ffffff19861661269f565b6001600160601b03169050818410612201576040805162461bcd60e51b81526020600482015260116024820152702b37baba103932b0b21037bb32b9393ab760791b604482015290519081900360640190fd5b600061220c836126b6565b60ff1690506000805b868110156122485761223162ffffff198916848603600e61270f565b915061223c82612740565b90920191600101612215565b5061225d62ffffff198816838503600e61270f565b9050600061226a82612740565b905061227f62ffffff1989168483600d6127ca565b98975050505050505050565b600081600d61229981611f46565b5060006122a785600861206b565b90506122e16008826122b8846126b6565b60ff16016001600160401b0316600760148111156122d257fe5b62ffffff1989169291906127ca565b95945050505050565b60008160076122f881611f46565b50600061230685600061206b565b9050600061231d62ffffff19871660026001612794565b9050604d826001600160401b0316118061234057506004826001600160401b0316105b8061235d575061235862ffffff198716600180612794565b606a14155b8061238757506001600160401b0360011983011661238462ffffff19881660026001612794565b14155b1561239457611fc06126ae565b6123b162ffffff19871660036001600160401b038416600c6127ca565b9695505050505050565b6000611f1083836014612794565b6000611f3762ffffff1983168260086127b5565b60606000806123eb8461269f565b6001600160601b03169050604051915081925061240b84836020016128fd565b508181016020016040529052919050565b60606000835b836001018110156124ce5785818151811061243957fe5b602001015160f81c60f81b915082826040516020018083805190602001908083835b6020831061247a5780518252601f19909201916020918201910161245b565b6001836020036101000a038019825116818451168082178552505050505050905001826001600160f81b03191681526001019250505060405160208183030381529060405292508080600101915050612422565b50509392505050565b80820382811115611f37576040805162461bcd60e51b815260206004820152601560248201527464732d6d6174682d7375622d756e646572666c6f7760581b604482015290519081900360640190fd5b60008061253484846129eb565b9050604051811115612544575060005b806125565762ffffff19915050611f10565b6122e1858585612a3a565b600061256d8383612a4d565b61269857600061258b61257f85612a6f565b64ffffffffff16612a75565b91505060006125a08464ffffffffff16612a75565b604080517f5479706520617373657274696f6e206661696c65642e20476f742030780000006020808301919091526001600160b01b031960b088811b8216603d8501526c05c408af0e0cac6e8cac84060f609b1b604785015285901b1660548301528251603e818403018152605e83019384905262461bcd60e51b909352606282018181528351608284015283519496509294508493839260a2019185019080838360005b8381101561265d578181015183820152602001612645565b50505050905090810190601f16801561268a5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5090919050565b60181c6001600160601b031690565b62ffffff1990565b600060fc826001600160401b0316116126d15750600161156d565b61ffff826001600160401b0316116126eb5750600361156d565b63ffffffff826001600160401b0316116127075750600561156d565b50600961156d565b600061273884612731856127228861269f565b6001600160601b0316906124d7565b85856127ca565b949350505050565b600081600e61274e81611f46565b50600061275c85600861206b565b9050806001600160401b0316612771826126b6565b60ff16016008019350505050919050565b60d81b6001600160d81b039091161790565b60008160200360080260ff166127ab858585612b0d565b901c949350505050565b60006127386127c5858585612b0d565b612c33565b6000806127d686612d6d565b6001600160601b031690506127ea86612d7c565b6127fe856127f884896129eb565b906129eb565b11156128115762ffffff19915050612738565b61281b81866129eb565b90506123b18364ffffffffff168286612527565b6060600061285c6128578261284962ffffff19871661269f565b62ffffff1987169190612794565b612a75565b604080517f4e6f6e2d6d696e696d616c2076617220696e742e20476f742030780000000000602080830191909152607084901b6dffffffffffffffffffffffffffff1916603b8301528251808303602d018152604d83019384905262461bcd60e51b9093526051820181815283516071840152835194965092945084938392609101918501908083836000831561265d578181015183820152602001612645565b600061290883612da1565b6129435760405162461bcd60e51b81526004018080602001828103825260288152602001806131706028913960400191505060405180910390fd5b61294c83612db3565b6129875760405162461bcd60e51b815260040180806020018281038252602b815260200180613198602b913960400191505060405180910390fd5b60006129928461269f565b6001600160601b0316905060006129a885612d6d565b6001600160601b0316905060006040519050848111156129c85760206060fd5b8285848460045afa506123b16129dd87612a6f565b64ffffffffff168685612a3a565b80820182811015611f37576040805162461bcd60e51b815260206004820152601460248201527364732d6d6174682d6164642d6f766572666c6f7760601b604482015290519081900360640190fd5b606092831b9190911790911b1760181b90565b60008164ffffffffff16612a6084612a6f565b64ffffffffff16149392505050565b60d81c90565b600080601f5b600f8160ff161115612abf5760ff600882021684901c612a9a81612df0565b61ffff16841793508160ff16601014612ab557601084901b93505b5060001901612a7b565b50600f5b60ff8160ff161015612b075760ff600882021684901c612ae281612df0565b61ffff16831792508160ff16600014612afd57601083901b92505b5060001901612ac3565b50915091565b600060ff8216612b1f57506000611f10565b612b288461269f565b6001600160601b0316612b3e8460ff85166129eb565b1115612bbc57612b75612b5085612d6d565b6001600160601b0316612b628661269f565b6001600160601b0316858560ff16612e20565b60405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561265d578181015183820152602001612645565b60208260ff161115612bff5760405162461bcd60e51b815260040180806020018281038252603a815260200180613136603a913960400191505060405180910390fd5b600882026000612c0e86612d6d565b6001600160601b031690506000612c2483612f13565b91909501511695945050505050565b600881811c7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff167fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff009290911b9190911617601081811c7dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff167fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff00009290911b9190911617602081811c7bffffffff00000000ffffffff00000000ffffffff00000000ffffffff167fffffffff00000000ffffffff00000000ffffffff00000000ffffffff000000009290911b9190911617604081811c77ffffffffffffffff0000000000000000ffffffffffffffff1677ffffffffffffffff0000000000000000ffffffffffffffff199290911b9190911617608081811c91901b1790565b60781c6001600160601b031690565b6000612d878261269f565b612d9083612d6d565b016001600160601b03169050919050565b6000612dac82612f22565b1592915050565b6000612dbe82612a6f565b64ffffffffff1664ffffffffff1415612dd95750600061156d565b6000612de483612d7c565b60405110199392505050565b6000612e0260048360ff16901c612f2e565b60ff161760081b62ffff0016612e1782612f2e565b60ff1617919050565b60606000612e2d86612a75565b9150506000612e3b86612a75565b9150506000612e4986612a75565b9150506000612e5786612a75565b9150508383838360405160200180806131c3603591396001600160d01b031960d087811b821660358401526e040eed2e8d040d8cadccee8d04060f608b1b603b84015286901b16604a820152605001602161311582396001600160d01b031960d094851b811660218301526e040eed2e8d040d8cadccee8d04060f608b1b60278301529290931b909116603683015250601760f91b603c82015260408051601d818403018152603d90920190529b9a5050505050505050505050565b600160ff1b6000199091011d90565b62ffffff199081161490565b600060f08083179060ff82161415612f4a57603091505061156d565b8060ff1660f11415612f6057603191505061156d565b8060ff1660f21415612f7657603291505061156d565b8060ff1660f31415612f8c57603391505061156d565b8060ff1660f41415612fa257603491505061156d565b8060ff1660f51415612fb857603591505061156d565b8060ff1660f61415612fce57603691505061156d565b8060ff1660f71415612fe457603791505061156d565b8060ff1660f81415612ffa57603891505061156d565b8060ff1660f9141561301057603991505061156d565b8060ff1660fa141561302657606191505061156d565b8060ff1660fb141561303c57606291505061156d565b8060ff1660fc141561305257606391505061156d565b8060ff1660fd141561306857606491505061156d565b8060ff1660fe141561307e57606591505061156d565b8060ff1660ff141561309457606691505061156d565b50919050565b8280548282559060005260206000209081019282156130ef579160200282015b828111156130ef57825182546001600160a01b0319166001600160a01b039091161782556020909201916001909101906130ba565b506130fb9291506130ff565b5090565b5b808211156130fb576000815560010161310056fe2e20417474656d7074656420746f20696e646578206174206f666673657420307854797065644d656d566965772f696e646578202d20417474656d7074656420746f20696e646578206d6f7265207468616e20333220627974657354797065644d656d566965772f636f7079546f202d204e756c6c20706f696e74657220646572656654797065644d656d566965772f636f7079546f202d20496e76616c696420706f696e74657220646572656654797065644d656d566965772f696e646578202d204f76657272616e2074686520766965772e20536c696365206973206174203078a2646970667358221220a582a8e48090467d66bbda8db8dc3bb1cc75da0eccb04bebbdde7a04a5aa24a564736f6c63430007060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c8063838b7ccb11610097578063d1d8d2ed11610066578063d1d8d2ed146104ea578063e35a0a88146104f2578063e75d75d5146104fa578063f5ded5181461050257610100565b8063838b7ccb14610470578063870ba6cf146104965780638da5cb5b146104bc578063a6f9dae1146104c457610100565b80632f1ed7cb116100d35780632f1ed7cb146102ea5780635615e16f1461043a57806373b295c2146104425780637f3c8b211461044a57610100565b806307980dcd146101055780630981a6661461027a5780631cb85818146102a05780631f8a4db9146102c4575b600080fd5b610278600480360361010081101561011c57600080fd5b6001600160e01b03198235169190810190604081016020820135600160201b81111561014757600080fd5b82018360208201111561015957600080fd5b803590602001918460018302840111600160201b8311171561017a57600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295949360208101935035915050600160201b8111156101cc57600080fd5b8201836020820111156101de57600080fd5b803590602001918460018302840111600160201b831117156101ff57600080fd5b919390926001600160e01b0319833516926020810135929190606081019060400135600160201b81111561023257600080fd5b82018360208201111561024457600080fd5b803590602001918460018302840111600160201b8311171561026557600080fd5b919350915080359060200135151561050a565b005b6102786004803603602081101561029057600080fd5b50356001600160a01b0316610cdf565b6102a8610d18565b604080516001600160a01b039092168252519081900360200190f35b610278600480360360208110156102da57600080fd5b50356001600160a01b0316610d27565b610278600480360360e081101561030057600080fd5b6001600160a01b038235169190810190604081016020820135600160201b81111561032a57600080fd5b82018360208201111561033c57600080fd5b803590602001918460018302840111600160201b8311171561035d57600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295843595602086013595919450925060608101915060400135600160201b8111156103bb57600080fd5b8201836020820111156103cd57600080fd5b803590602001918460208302840111600160201b831117156103ee57600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929550506001600160a01b038335169350505060200135610d60565b6102a8611038565b6102a8611047565b6102786004803603602081101561046057600080fd5b50356001600160a01b0316611056565b6102786004803603602081101561048657600080fd5b50356001600160a01b031661108f565b610278600480360360208110156104ac57600080fd5b50356001600160a01b03166111d4565b6102a861120d565b610278600480360360208110156104da57600080fd5b50356001600160a01b031661121c565b6102a8611255565b6102a8611264565b6102a8611273565b6102a8611282565b600254604080516020601f8b0181900481028201810190925289815261054a918b908b908190840183828082843760009201919091525061129192505050565b61059b576040805162461bcd60e51b815260206004820152601f60248201527f5472616e73616374696f6e2064617461206973206e6f7420636f727265637400604482015290519081900360640190fd5b43600101600160008381526020019081526020016000206009015410610c9e576106388b8b8b8b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050604080516020601f8d018190048102820181019092528b81528e93508d9250908c908c90819084018382808284376000920191909152508c92508b91506115729050565b6007805460008381526001602090815260408083206008810154950154815163a9059cbb60e01b81526001600160a01b03968716600482015260248101919091529051949093169363a9059cbb93604480820194918390030190829087803b1580156106a357600080fd5b505af11580156106b7573d6000803e3d6000fd5b505050506040513d60208110156106cd57600080fd5b5050600081815260016020526040902060030154600160a01b900460ff1615801561071857506005546000828152600160205260409020600301546001600160a01b03908116911614155b156109b757600754600654600083815260016020908152604080832060020154815163095ea7b360e01b81526001600160a01b03958616600482015260248101919091529051939094169363095ea7b39360448083019491928390030190829087803b15801561078757600080fd5b505af115801561079b573d6000803e3d6000fd5b505050506040513d60208110156107b157600080fd5b50506000818152600160208181526040808420600281015493810154600690910180548351818602810186019094528084526060969561085995909492919083018282801561082957602002820191906000526020600020905b81546001600160a01b0316815260019091019060200180831161080b575b505050600089815260016020526040902060058101546009909101546001600160a01b039091169250905061176f565b909250905080156109a15760008381526001602052604081206005810154600690910180547fc8d4f413dd655a643206b602c9646c4d2a668af80f1a8d5879c9bb38911f85c0936001600160a01b0390931692906108b357fe5b60009182526020808320909101548783526001909152604090912060060180546001600160a01b039092169160001981019081106108ed57fe5b6000918252602080832090910154888352600190915260409091206002015486516001600160a01b03909216918790600019810190811061092a57fe5b6020026020010151600160008a8152602001908152602001600020600b015460405180876001600160a01b03168152602001866001600160a01b03168152602001856001600160a01b03168152602001848152602001838152602001828152602001965050505050505060405180910390a16109b4565b6109b48d8d8d8d8d8d8d8d8d8d8d6118ff565b50505b600081815260016020526040902060030154600160a01b900460ff161580156109ff57506005546000828152600160205260409020600301546001600160a01b039081169116145b15610c9e57600754600654600083815260016020908152604080832060020154815163095ea7b360e01b81526001600160a01b03958616600482015260248101919091529051939094169363095ea7b39360448083019491928390030190829087803b158015610a6e57600080fd5b505af1158015610a82573d6000803e3d6000fd5b505050506040513d6020811015610a9857600080fd5b505060008181526001602081815260408084206002810154938101546006909101805483518186028101860190945280845260609695610b40959094929190830182828015610b1057602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610af2575b505050600089815260016020526040902060058101546009909101546001600160a01b0390911692509050611ab7565b90925090508015610c885760008381526001602052604081206005810154600690910180547fc8d4f413dd655a643206b602c9646c4d2a668af80f1a8d5879c9bb38911f85c0936001600160a01b039093169290610b9a57fe5b60009182526020808320909101548783526001909152604090912060060180546001600160a01b03909216916000198101908110610bd457fe5b6000918252602080832090910154888352600190915260409091206002015486516001600160a01b039092169187906000198101908110610c1157fe5b6020026020010151600160008a8152602001908152602001600020600b015460405180876001600160a01b03168152602001866001600160a01b03168152602001856001600160a01b03168152602001848152602001838152602001828152602001965050505050505060405180910390a1610c9b565b610c9b8d8d8d8d8d8d8d8d8d8d8d6118ff565b50505b4360010160016000838152602001908152602001600020600901541015610cd257610cd28b8b8b8b8b8b8b8b8b8b8b6118ff565b5050505050505050505050565b600b546001600160a01b03163314610cf657600080fd5b600780546001600160a01b0319166001600160a01b0392909216919091179055565b6006546001600160a01b031681565b600b546001600160a01b03163314610d3e57600080fd5b600880546001600160a01b0319166001600160a01b0392909216919091179055565b60606000600a60009054906101000a90046001600160a01b03166001600160a01b0316632f1ed7cb8a8a8a8a8a8a8a6040518863ffffffff1660e01b815260040180886001600160a01b031681526020018060200187815260200186815260200180602001856001600160a01b03168152602001848152602001838103835289818151815260200191508051906020019080838360005b83811015610e0f578181015183820152602001610df7565b50505050905090810190601f168015610e3c5780820380516001836020036101000a031916815260200191505b508381038252865181528651602091820191808901910280838360005b83811015610e71578181015183820152602001610e59565b505050509050019950505050505050505050600060405180830381600087803b158015610e9d57600080fd5b505af1158015610eb1573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040908152811015610eda57600080fd5b8101908080516040519392919084600160201b821115610ef957600080fd5b908301906020820185811115610f0e57600080fd5b82518660208202830111600160201b82111715610f2a57600080fd5b82525081516020918201928201910280838360005b83811015610f57578181015183820152602001610f3f565b50505050919091016040525060200151885193955093507fc8d4f413dd655a643206b602c9646c4d2a668af80f1a8d5879c9bb38911f85c092879250889150600090610f9f57fe5b602002602001015187600189510381518110610fb757fe5b60200260200101518a86600188510381518110610fd057fe5b6020026020010151600260405180876001600160a01b03168152602001866001600160a01b03168152602001856001600160a01b03168152602001848152602001838152602001828152602001965050505050505060405180910390a1505050505050505050565b6007546001600160a01b031681565b6005546001600160a01b031681565b600b546001600160a01b0316331461106d57600080fd5b600980546001600160a01b0319166001600160a01b0392909216919091179055565b600b546001600160a01b031633146110a657600080fd5b600680546001600160a01b0319166001600160a01b0383811691909117918290556040805163e75d75d560e01b81529051929091169163e75d75d591600480820192602092909190829003018186803b15801561110257600080fd5b505afa158015611116573d6000803e3d6000fd5b505050506040513d602081101561112c57600080fd5b5051600480546001600160a01b0319166001600160a01b03928316178155600654604080516339d94ae160e11b8152905191909316926373b295c29281810192602092909190829003018186803b15801561118657600080fd5b505afa15801561119a573d6000803e3d6000fd5b505050506040513d60208110156111b057600080fd5b5051600580546001600160a01b0319166001600160a01b0390921691909117905550565b600b546001600160a01b031633146111eb57600080fd5b600a80546001600160a01b0319166001600160a01b0392909216919091179055565b600b546001600160a01b031681565b600b546001600160a01b0316331461123357600080fd5b600b80546001600160a01b0319166001600160a01b0392909216919091179055565b6008546001600160a01b031681565b600a546001600160a01b031681565b6004546001600160a01b031681565b6009546001600160a01b031681565b600060606000600860009054906101000a90046001600160a01b03166001600160a01b03166375a31bb16040518163ffffffff1660e01b815260040160206040518083038186803b1580156112e557600080fd5b505afa1580156112f9573d6000803e3d6000fd5b505050506040513d602081101561130f57600080fd5b5051905061131d8482611b40565b60025460009081526001602052604090206001600160401b03909216909155915061134782611c26565b6fffffffffffffffffffffffffffffffff166001600060025481526020019081526020016000206001018190555061137e82611c41565b60025460009081526001602052604090206003018054911515600160a01b0260ff60a01b199092169190911790556113b582611c8e565b600254600090815260016020526040902060050180546001600160a01b0319166001600160a01b03929092169190911790556113f082611ca9565b60025460009081526001602052604090206001600160401b039190911660079091015561141c82611cc4565b600280546000908152600160208181526040808420600390810180546001600160a01b0319166001600160a01b039889161790558151808301835260075488168152865480875285855292862091820154909716878401529352526114869260069091019161309a565b50600254600090815260016020526040902060080180546001600160a01b031916331790556114b482611cd4565b60025460009081526001602052604090206001600160401b03919091166009909101556114e082611ce4565b6002546000908152600160205260409020600a01805460ff191691151591909117905561150c82611cf3565b6002805460009081526001602052604080822060ff94909416600b948501559154815220805460078201549190920154611547929190611d0d565b600280546000908152600160208190526040909120820192909255805482019055925050505b919050565b600954604051630e70f50360e21b81526001600160e01b0319808b166004830190815290881660648301526084820187905260c4820185905283151560e4830152610100602483019081528a516101048401528a516001600160a01b03909416936339c3d40c938d938d938d938d938d938d938d938d93604481019160a4820191610124019060208d019080838360005b8381101561161b578181015183820152602001611603565b50505050905090810190601f1680156116485780820380516001836020036101000a031916815260200191505b5084810383528a5181528a516020918201918c019080838360005b8381101561167b578181015183820152602001611663565b50505050905090810190601f1680156116a85780820380516001836020036101000a031916815260200191505b50848103825287518152875160209182019189019080838360005b838110156116db5781810151838201526020016116c3565b50505050905090810190601f1680156117085780820380516001836020036101000a031916815260200191505b509b505050505050505050505050602060405180830381600087803b15801561173057600080fd5b505af1158015611744573d6000803e3d6000fd5b505050506040513d602081101561175a57600080fd5b505161176557600080fd5b5050505050505050565b6006546040516338ed173960e01b815260048101878152602482018790526001600160a01b0385811660648401526084830185905260a060448401908152875160a485015287516060956000959316936338ed1739938c938c938c938c938c93919260c490910190602080880191028083838f5b838110156117fb5781810151838201526020016117e3565b505050509050019650505050505050600060405180830381600087803b15801561182457600080fd5b505af1158015611838573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604090815281101561186157600080fd5b8101908080516040519392919084600160201b82111561188057600080fd5b90830190602082018581111561189557600080fd5b82518660208202830111600160201b821117156118b157600080fd5b82525081516020918201928201910280838360005b838110156118de5781810151838201526020016118c6565b50505050919091016040525060200151929a92995091975050505050505050565b61197c8b8b8b8b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050604080516020601f8d018190048102820181019092528b81528e93508d9250908c908c90819084018382808284376000920191909152508c92508b91506115729050565b60075460008281526001602090815260408083206005810154600290910154825163a9059cbb60e01b81526001600160a01b0392831660048201526024810191909152915194169363a9059cbb93604480840194938390030190829087803b1580156119e757600080fd5b505af11580156119fb573d6000803e3d6000fd5b505050506040513d6020811015611a1157600080fd5b50506007805460008381526001602090815260408083206008810154950154815163a9059cbb60e01b81526001600160a01b03968716600482015260248101919091529051949093169363a9059cbb93604480820194918390030190829087803b158015611a7e57600080fd5b505af1158015611a92573d6000803e3d6000fd5b505050506040513d6020811015611aa857600080fd5b50505050505050505050505050565b60065460405163676528d160e01b815260048101878152602482018790526001600160a01b0385811660648401526084830185905260a060448401908152875160a4850152875160609560009593169363676528d1938c938c938c938c938c93919260c490910190602087810191028083838f83156117fb5781810151838201526020016117e3565b6000606081611b5d611b528683611f17565b62ffffff1916611f3d565b9050600080600080600060606000611b7688600061206b565b6001600160401b0316905060005b81811015611c1457611b968982612184565b9750611ba18861228b565b9550611bac866122ea565b945062ffffff198086161415611bfa57611bcd62ffffff19871660036123bb565b93508b6001600160a01b0316846001600160a01b03161415611bf557611bf2886123c9565b96505b611c0c565b611c0962ffffff1986166123dd565b92505b600101611b84565b50949b909a5098505050505050505050565b600080611c36836032604161241c565b601001519392505050565b600080611c5083604a8061241c565b8051909150600090819083908290611c6457fe5b01602001516001600160f81b0319161415611c825760009250611c87565b600192505b5050919050565b600080611c9e836000601361241c565b601401519392505050565b600080611cb9836014601b61241c565b600801519392505050565b600080611c9e83601e603161241c565b600080611cb9836042604961241c565b600080611c5083601c8061241c565b600080611d0283601d8061241c565b600101519392505050565b600081611d6d57828411611d5c576040805162461bcd60e51b8152602060048201526011602482015270125b9cdd59999a58da595b9d08199d5b99607a1b604482015290519081900360640190fd5b611d6684846124d7565b9050611f10565b8160011415611ebf576009546040805163637a30c160e11b815290516000926001600160a01b03169163c6f46182916004808301926020929190829003018186803b158015611dbb57600080fd5b505afa158015611dcf573d6000803e3d6000fd5b505050506040513d6020811015611de557600080fd5b505160408051630c2dc8d960e41b815290519192506000916001600160a01b0384169163c2dc8d90916004808301926020929190829003018186803b158015611e2d57600080fd5b505afa158015611e41573d6000803e3d6000fd5b505050506040513d6020811015611e5757600080fd5b505190506064818103870204858111611eab576040805162461bcd60e51b8152602060048201526011602482015270125b9cdd59999a58da595b9d08199d5b99607a1b604482015290519081900360640190fd5b611eb581876124d7565b9350505050611f10565b8160021415611f1057828411611d5c576040805162461bcd60e51b8152602060048201526011602482015270125b9cdd59999a58da595b9d08199d5b99607a1b604482015290519081900360640190fd5b9392505050565b815160009060208401611f3264ffffffffff85168284612527565b925050505b92915050565b60008181611f53815b62ffffff19841690612561565b50611f6362ffffff19851661269f565b6001600160601b0316611f7f57611f786126ae565b9250611c87565b6000611f8c85600061206b565b90506000611f9f62ffffff19871661269f565b6001600160601b031690506001600160401b038216611fc957611fc06126ae565b94505050611c87565b6000611fd4836126b6565b60ff16905060005b836001600160401b03168110156120355782821061200757611ffc6126ae565b965050505050611c87565b600061201d62ffffff198a16848603600e61270f565b905061202881612740565b9092019150600101611fdc565b5081811461204f576120456126ae565b9550505050611c87565b61206062ffffff198816600f612782565b979650505050505050565b60008061208062ffffff198516846001612794565b905060fc8111612091579050611f37565b8060fd14156120e7576120af62ffffff1985166001850160026127b5565b91506120ba826126b6565b60ff166003146120e2576120e06120db62ffffff19861685600360006127ca565b61282f565b505b61217d565b8060fe14156121315761210562ffffff1985166001850160046127b5565b9150612110826126b6565b60ff166005146120e2576120e06120db62ffffff19861685600560006127ca565b8060ff141561217d5761214f62ffffff1985166001850160086127b5565b915061215a826126b6565b60ff1660091461217d5761217b6120db62ffffff19861685600960006127ca565b505b5092915050565b60008061219284600061206b565b6001600160401b0316905060006121ae62ffffff19861661269f565b6001600160601b03169050818410612201576040805162461bcd60e51b81526020600482015260116024820152702b37baba103932b0b21037bb32b9393ab760791b604482015290519081900360640190fd5b600061220c836126b6565b60ff1690506000805b868110156122485761223162ffffff198916848603600e61270f565b915061223c82612740565b90920191600101612215565b5061225d62ffffff198816838503600e61270f565b9050600061226a82612740565b905061227f62ffffff1989168483600d6127ca565b98975050505050505050565b600081600d61229981611f46565b5060006122a785600861206b565b90506122e16008826122b8846126b6565b60ff16016001600160401b0316600760148111156122d257fe5b62ffffff1989169291906127ca565b95945050505050565b60008160076122f881611f46565b50600061230685600061206b565b9050600061231d62ffffff19871660026001612794565b9050604d826001600160401b0316118061234057506004826001600160401b0316105b8061235d575061235862ffffff198716600180612794565b606a14155b8061238757506001600160401b0360011983011661238462ffffff19881660026001612794565b14155b1561239457611fc06126ae565b6123b162ffffff19871660036001600160401b038416600c6127ca565b9695505050505050565b6000611f1083836014612794565b6000611f3762ffffff1983168260086127b5565b60606000806123eb8461269f565b6001600160601b03169050604051915081925061240b84836020016128fd565b508181016020016040529052919050565b60606000835b836001018110156124ce5785818151811061243957fe5b602001015160f81c60f81b915082826040516020018083805190602001908083835b6020831061247a5780518252601f19909201916020918201910161245b565b6001836020036101000a038019825116818451168082178552505050505050905001826001600160f81b03191681526001019250505060405160208183030381529060405292508080600101915050612422565b50509392505050565b80820382811115611f37576040805162461bcd60e51b815260206004820152601560248201527464732d6d6174682d7375622d756e646572666c6f7760581b604482015290519081900360640190fd5b60008061253484846129eb565b9050604051811115612544575060005b806125565762ffffff19915050611f10565b6122e1858585612a3a565b600061256d8383612a4d565b61269857600061258b61257f85612a6f565b64ffffffffff16612a75565b91505060006125a08464ffffffffff16612a75565b604080517f5479706520617373657274696f6e206661696c65642e20476f742030780000006020808301919091526001600160b01b031960b088811b8216603d8501526c05c408af0e0cac6e8cac84060f609b1b604785015285901b1660548301528251603e818403018152605e83019384905262461bcd60e51b909352606282018181528351608284015283519496509294508493839260a2019185019080838360005b8381101561265d578181015183820152602001612645565b50505050905090810190601f16801561268a5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5090919050565b60181c6001600160601b031690565b62ffffff1990565b600060fc826001600160401b0316116126d15750600161156d565b61ffff826001600160401b0316116126eb5750600361156d565b63ffffffff826001600160401b0316116127075750600561156d565b50600961156d565b600061273884612731856127228861269f565b6001600160601b0316906124d7565b85856127ca565b949350505050565b600081600e61274e81611f46565b50600061275c85600861206b565b9050806001600160401b0316612771826126b6565b60ff16016008019350505050919050565b60d81b6001600160d81b039091161790565b60008160200360080260ff166127ab858585612b0d565b901c949350505050565b60006127386127c5858585612b0d565b612c33565b6000806127d686612d6d565b6001600160601b031690506127ea86612d7c565b6127fe856127f884896129eb565b906129eb565b11156128115762ffffff19915050612738565b61281b81866129eb565b90506123b18364ffffffffff168286612527565b6060600061285c6128578261284962ffffff19871661269f565b62ffffff1987169190612794565b612a75565b604080517f4e6f6e2d6d696e696d616c2076617220696e742e20476f742030780000000000602080830191909152607084901b6dffffffffffffffffffffffffffff1916603b8301528251808303602d018152604d83019384905262461bcd60e51b9093526051820181815283516071840152835194965092945084938392609101918501908083836000831561265d578181015183820152602001612645565b600061290883612da1565b6129435760405162461bcd60e51b81526004018080602001828103825260288152602001806131706028913960400191505060405180910390fd5b61294c83612db3565b6129875760405162461bcd60e51b815260040180806020018281038252602b815260200180613198602b913960400191505060405180910390fd5b60006129928461269f565b6001600160601b0316905060006129a885612d6d565b6001600160601b0316905060006040519050848111156129c85760206060fd5b8285848460045afa506123b16129dd87612a6f565b64ffffffffff168685612a3a565b80820182811015611f37576040805162461bcd60e51b815260206004820152601460248201527364732d6d6174682d6164642d6f766572666c6f7760601b604482015290519081900360640190fd5b606092831b9190911790911b1760181b90565b60008164ffffffffff16612a6084612a6f565b64ffffffffff16149392505050565b60d81c90565b600080601f5b600f8160ff161115612abf5760ff600882021684901c612a9a81612df0565b61ffff16841793508160ff16601014612ab557601084901b93505b5060001901612a7b565b50600f5b60ff8160ff161015612b075760ff600882021684901c612ae281612df0565b61ffff16831792508160ff16600014612afd57601083901b92505b5060001901612ac3565b50915091565b600060ff8216612b1f57506000611f10565b612b288461269f565b6001600160601b0316612b3e8460ff85166129eb565b1115612bbc57612b75612b5085612d6d565b6001600160601b0316612b628661269f565b6001600160601b0316858560ff16612e20565b60405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561265d578181015183820152602001612645565b60208260ff161115612bff5760405162461bcd60e51b815260040180806020018281038252603a815260200180613136603a913960400191505060405180910390fd5b600882026000612c0e86612d6d565b6001600160601b031690506000612c2483612f13565b91909501511695945050505050565b600881811c7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff167fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff009290911b9190911617601081811c7dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff167fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff00009290911b9190911617602081811c7bffffffff00000000ffffffff00000000ffffffff00000000ffffffff167fffffffff00000000ffffffff00000000ffffffff00000000ffffffff000000009290911b9190911617604081811c77ffffffffffffffff0000000000000000ffffffffffffffff1677ffffffffffffffff0000000000000000ffffffffffffffff199290911b9190911617608081811c91901b1790565b60781c6001600160601b031690565b6000612d878261269f565b612d9083612d6d565b016001600160601b03169050919050565b6000612dac82612f22565b1592915050565b6000612dbe82612a6f565b64ffffffffff1664ffffffffff1415612dd95750600061156d565b6000612de483612d7c565b60405110199392505050565b6000612e0260048360ff16901c612f2e565b60ff161760081b62ffff0016612e1782612f2e565b60ff1617919050565b60606000612e2d86612a75565b9150506000612e3b86612a75565b9150506000612e4986612a75565b9150506000612e5786612a75565b9150508383838360405160200180806131c3603591396001600160d01b031960d087811b821660358401526e040eed2e8d040d8cadccee8d04060f608b1b603b84015286901b16604a820152605001602161311582396001600160d01b031960d094851b811660218301526e040eed2e8d040d8cadccee8d04060f608b1b60278301529290931b909116603683015250601760f91b603c82015260408051601d818403018152603d90920190529b9a5050505050505050505050565b600160ff1b6000199091011d90565b62ffffff199081161490565b600060f08083179060ff82161415612f4a57603091505061156d565b8060ff1660f11415612f6057603191505061156d565b8060ff1660f21415612f7657603291505061156d565b8060ff1660f31415612f8c57603391505061156d565b8060ff1660f41415612fa257603491505061156d565b8060ff1660f51415612fb857603591505061156d565b8060ff1660f61415612fce57603691505061156d565b8060ff1660f71415612fe457603791505061156d565b8060ff1660f81415612ffa57603891505061156d565b8060ff1660f9141561301057603991505061156d565b8060ff1660fa141561302657606191505061156d565b8060ff1660fb141561303c57606291505061156d565b8060ff1660fc141561305257606391505061156d565b8060ff1660fd141561306857606491505061156d565b8060ff1660fe141561307e57606591505061156d565b8060ff1660ff141561309457606691505061156d565b50919050565b8280548282559060005260206000209081019282156130ef579160200282015b828111156130ef57825182546001600160a01b0319166001600160a01b039091161782556020909201916001909101906130ba565b506130fb9291506130ff565b5090565b5b808211156130fb576000815560010161310056fe2e20417474656d7074656420746f20696e646578206174206f666673657420307854797065644d656d566965772f696e646578202d20417474656d7074656420746f20696e646578206d6f7265207468616e20333220627974657354797065644d656d566965772f636f7079546f202d204e756c6c20706f696e74657220646572656654797065644d656d566965772f636f7079546f202d20496e76616c696420706f696e74657220646572656654797065644d656d566965772f696e646578202d204f76657272616e2074686520766965772e20536c696365206973206174203078a2646970667358221220a582a8e48090467d66bbda8db8dc3bb1cc75da0eccb04bebbdde7a04a5aa24a564736f6c63430007060033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11780,
        "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
        "label": "ZERO_ADDRESS",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 11784,
        "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
        "label": "requests",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_struct(request)17783_storage)"
      },
      {
        "astId": 11786,
        "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
        "label": "lastRequest",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 11789,
        "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
        "label": "parsedPath",
        "offset": 0,
        "slot": "3",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 11792,
        "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
        "label": "liquidityPoolFactory",
        "offset": 0,
        "slot": "4",
        "type": "t_address"
      },
      {
        "astId": 11795,
        "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
        "label": "WAVAX",
        "offset": 0,
        "slot": "5",
        "type": "t_address"
      },
      {
        "astId": 11798,
        "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
        "label": "exchangeRouter",
        "offset": 0,
        "slot": "6",
        "type": "t_address"
      },
      {
        "astId": 11801,
        "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
        "label": "wrappedBitcoin",
        "offset": 0,
        "slot": "7",
        "type": "t_address"
      },
      {
        "astId": 11803,
        "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
        "label": "bitcoinTeleporter",
        "offset": 0,
        "slot": "8",
        "type": "t_address"
      },
      {
        "astId": 11805,
        "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
        "label": "ccTransferRouter",
        "offset": 0,
        "slot": "9",
        "type": "t_address"
      },
      {
        "astId": 11807,
        "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
        "label": "instantRouter",
        "offset": 0,
        "slot": "10",
        "type": "t_address"
      },
      {
        "astId": 11810,
        "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
        "label": "owner",
        "offset": 0,
        "slot": "11",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_uint256,t_struct(request)17783_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ICCExchangeRouter.request)",
        "numberOfBytes": "32",
        "value": "t_struct(request)17783_storage"
      },
      "t_struct(request)17783_storage": {
        "encoding": "inplace",
        "label": "struct ICCExchangeRouter.request",
        "members": [
          {
            "astId": 17757,
            "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
            "label": "bitcoinAmount",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 17759,
            "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
            "label": "exchangeAmount",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 17761,
            "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
            "label": "remainedInputAmount",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 17763,
            "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
            "label": "exchangeToken",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 17765,
            "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
            "label": "isFixedToken",
            "offset": 20,
            "slot": "3",
            "type": "t_bool"
          },
          {
            "astId": 17767,
            "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
            "label": "bitcoinRecipient",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 17769,
            "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
            "label": "exchangeRecipientAddress",
            "offset": 0,
            "slot": "5",
            "type": "t_address"
          },
          {
            "astId": 17772,
            "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
            "label": "path",
            "offset": 0,
            "slot": "6",
            "type": "t_array(t_address)dyn_storage"
          },
          {
            "astId": 17774,
            "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
            "label": "teleporterFee",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          },
          {
            "astId": 17776,
            "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
            "label": "teleporterAddress",
            "offset": 0,
            "slot": "8",
            "type": "t_address"
          },
          {
            "astId": 17778,
            "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
            "label": "deadline",
            "offset": 0,
            "slot": "9",
            "type": "t_uint256"
          },
          {
            "astId": 17780,
            "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
            "label": "isExchange",
            "offset": 0,
            "slot": "10",
            "type": "t_bool"
          },
          {
            "astId": 17782,
            "contract": "contracts/routers/CCExchangeRouter.sol:CCExchangeRouter",
            "label": "speed",
            "offset": 0,
            "slot": "11",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "384"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}