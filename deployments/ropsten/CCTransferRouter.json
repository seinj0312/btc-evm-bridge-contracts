{
  "address": "0x4a34FE2aFD275d95C8971c54e8E4deFFD9A85912",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_bitcoinRelay",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_bitcoinTeleporter",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_normalConfirmationParameter",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "inputToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "inputAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "speed",
          "type": "uint256"
        }
      ],
      "name": "CCTransfer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "PaybackFastLoan",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "bitcoinFastPool",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "bitcoinInstantPool",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "bitcoinRelay",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "bitcoinTeleporter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ccExchangeRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "version",
          "type": "bytes4"
        },
        {
          "internalType": "bytes",
          "name": "vin",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "vout",
          "type": "bytes"
        },
        {
          "internalType": "bytes4",
          "name": "locktime",
          "type": "bytes4"
        },
        {
          "internalType": "uint256",
          "name": "blockNumber",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "intermediateNodes",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "payWithTDT",
          "type": "bool"
        }
      ],
      "name": "ccTransfer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        }
      ],
      "name": "changeOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fastRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "instantTokenAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "instantCCTransferWithPermit",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "instantRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "txId",
          "type": "bytes32"
        }
      ],
      "name": "isRequestMinted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "txId",
          "type": "bytes32"
        }
      ],
      "name": "isRequestUsed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "txId",
          "type": "bytes32"
        }
      ],
      "name": "mintAfterFinalization",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "normalConfirmationParameter",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_bitcoinRelay",
          "type": "address"
        }
      ],
      "name": "setBitcoinRelay",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_ccExchangeRouter",
          "type": "address"
        }
      ],
      "name": "setCCExchangeRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_fastRouter",
          "type": "address"
        }
      ],
      "name": "setFastRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_instantRouter",
          "type": "address"
        }
      ],
      "name": "setInstantRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_normalConfirmationParameter",
          "type": "uint256"
        }
      ],
      "name": "setNormalConfirmationParameter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_wrappedBitcoin",
          "type": "address"
        }
      ],
      "name": "setWrappedBitcoin",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "wrapRequests",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "bitcoinAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "recipientAddress",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "isExchange",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "teleporterFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "speed",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isUsed",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "blockNumber",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "intermediateNodes",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isMinted",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "exchangeAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "exchangeToken",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "wrappedBitcoin",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x34952ba6536ec7fe469fba846ccacd2c6ede8688ab4b5017a83d1f3be5004fd5",
  "receipt": {
    "to": null,
    "from": "0x5364E3557572bd5D5903C0e9C21BE359F2Eac1dA",
    "contractAddress": "0x4a34FE2aFD275d95C8971c54e8E4deFFD9A85912",
    "transactionIndex": 0,
    "gasUsed": "3469391",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x401296846ca0a3819441f44ee10ae50be672e22a22e9a94ea14709a10130b4a5",
    "transactionHash": "0x34952ba6536ec7fe469fba846ccacd2c6ede8688ab4b5017a83d1f3be5004fd5",
    "logs": [],
    "blockNumber": 12331323,
    "cumulativeGasUsed": "3469391",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x9fa5Fd5E52D0793e4bc9A170eEF232eD15DaA6Ad",
    "0xD57a0FF38FE9b8803904D0F79f44792bd79524C6",
    3
  ],
  "numDeployments": 1,
  "solcInputHash": "b766d894e7507eaf09e41e8de1c94935",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bitcoinRelay\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bitcoinTeleporter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_normalConfirmationParameter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"speed\",\"type\":\"uint256\"}],\"name\":\"CCTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaybackFastLoan\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bitcoinFastPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bitcoinInstantPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bitcoinRelay\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bitcoinTeleporter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ccExchangeRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"version\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"vin\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"vout\",\"type\":\"bytes\"},{\"internalType\":\"bytes4\",\"name\":\"locktime\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"intermediateNodes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"payWithTDT\",\"type\":\"bool\"}],\"name\":\"ccTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fastRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"instantTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"instantCCTransferWithPermit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"instantRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"}],\"name\":\"isRequestMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"}],\"name\":\"isRequestUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"}],\"name\":\"mintAfterFinalization\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"normalConfirmationParameter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bitcoinRelay\",\"type\":\"address\"}],\"name\":\"setBitcoinRelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ccExchangeRouter\",\"type\":\"address\"}],\"name\":\"setCCExchangeRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fastRouter\",\"type\":\"address\"}],\"name\":\"setFastRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_instantRouter\",\"type\":\"address\"}],\"name\":\"setInstantRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_normalConfirmationParameter\",\"type\":\"uint256\"}],\"name\":\"setNormalConfirmationParameter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wrappedBitcoin\",\"type\":\"address\"}],\"name\":\"setWrappedBitcoin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"wrapRequests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bitcoinAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isExchange\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"teleporterFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"speed\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUsed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"intermediateNodes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isMinted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"exchangeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedBitcoin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/routers/CCTransferRouter.sol\":\"CCTransferRouter\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/erc20/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\",\"keccak256\":\"0x9487ba287d6d9b15151de0ac35dfd739366f830c44205edbab7c4298166f7a47\",\"license\":\"MIT\"},\"contracts/erc20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport '../libraries/SafeMath.sol';\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint;\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_, uint initialMintedAmount) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        if (initialMintedAmount > 0) {\\n            _mint(msg.sender, initialMintedAmount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        // require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\",\"keccak256\":\"0xd3fbcc112f6825c2c4505b86c1c20f84782d5f0a3689a707e7b7d946a8600a28\",\"license\":\"MIT\"},\"contracts/erc20/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\ninterface IERC20 {\\n    // events\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    // read-only functions\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    // state-changing functions\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xbfce47b32957e65d24a0a087221880a77cde7bd13f0bb3af913cb9b0877ddad5\"},\"contracts/erc20/interfaces/IWrappedToken.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity ^0.7.6;\\n\\nimport './IERC20.sol';\\n\\ninterface IWrappedToken is IERC20 {\\n  // events\\n  event Mint(address indexed to, uint value);\\n  event Burn(address indexed to, uint value);\\n  // read-only functions\\n  function CCTransferRouter() external view returns(address);\\n  // state-changing functions\\n  function mint(address receiver, uint amount) external returns(bool);\\n  function burn(uint256 amount) external;\\n  function mintTestToken() external;\\n\\n}\",\"keccak256\":\"0x6b71fe630cb15f15e9acb388070c5d0a67b630dddb9ab18731388403a3846675\"},\"contracts/libraries/BitcoinTxParser.sol\":{\"content\":\"pragma solidity 0.7.6;\\n\\nimport \\\"./TypedMemView.sol\\\";\\nimport \\\"./ViewBTC.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n// a library for parsing bitcoin transactions\\n\\nlibrary BitcoinTxParser {\\n\\n    using TypedMemView for bytes;\\n    using TypedMemView for bytes29;\\n    using ViewBTC for bytes29;\\n\\n    function parseAmountForP2SH (bytes memory vout, address desiredRecipient) internal returns(uint64, bytes memory) {\\n        bytes29 voutView = vout.ref(0).tryAsVout();\\n        bytes29 output;\\n        uint64 bitcoinAmount;\\n        bytes29 scriptPubkey;\\n        bytes29 _arbitraryData;\\n        address bitcoinRecipient;\\n        bytes memory arbitraryData;\\n        uint numberOfOutputs = uint256(ViewBTC.indexCompactInt(voutView, 0));\\n        for(uint index = 0; index < numberOfOutputs; index++){\\n            output = ViewBTC.indexVout(voutView, index);\\n            scriptPubkey = ViewBTC.scriptPubkey(output);\\n            _arbitraryData = ViewBTC.opReturnPayload(scriptPubkey);\\n            // check whether the output is an arbitarary data or not\\n            if(_arbitraryData == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\\n                // output is not an arbitrary data\\n                // indexAddress starts with 3, because the first 2 bytes are opcode.\\n                bitcoinRecipient = scriptPubkey.indexAddress(3);\\n                if (bitcoinRecipient == desiredRecipient) {\\n                    bitcoinAmount = ViewBTC.value(output); // number of btc that user locked\\n                }\\n            } else {\\n                // output is an arbitrary data\\n                arbitraryData = _arbitraryData.clone(); // bytes29.clone() returns the whole bytes array\\n            }\\n        }\\n        // console.log(value);\\n        // console.logBytes(requestData);\\n        return (bitcoinAmount, arbitraryData);\\n    }\\n\\n        function parseAmountForP2PK (\\n            bytes memory vout,\\n            address desiredRecipient\\n        ) internal returns(uint64, bytes memory) {\\n        bytes29 voutView = vout.ref(0).tryAsVout();\\n        bytes29 output;\\n        uint64 bitcoinAmount;\\n        bytes29 scriptPubkey;\\n        bytes29 _arbitraryData;\\n        address bitcoinRecipient;\\n        bytes memory arbitraryData;\\n        uint numberOfOutputs = uint256(ViewBTC.indexCompactInt(voutView, 0));\\n        for (uint index = 0; index < numberOfOutputs; index++) {\\n            output = ViewBTC.indexVout(voutView, index);\\n            scriptPubkey = ViewBTC.scriptPubkey(output);\\n            _arbitraryData = ViewBTC.opReturnPayload(scriptPubkey);\\n            // check whether the output is an arbitarary data or not\\n            if(_arbitraryData == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\\n                // output is not an arbitrary data\\n                if (scriptPubkey.len() == 26) {\\n                    bitcoinRecipient = scriptPubkey.indexAddress(4);\\n                }\\n                if (scriptPubkey.len() == 23) {\\n                    bitcoinRecipient = scriptPubkey.indexAddress(3);\\n                }\\n                if (bitcoinRecipient == desiredRecipient) {\\n                    bitcoinAmount = ViewBTC.value(output); // number of btc that user locked\\n                }\\n            } else {\\n                // output is an arbitrary data\\n                arbitraryData = _arbitraryData.clone(); // bytes29.clone() returns the whole bytes array\\n            }\\n        }\\n        // console.log(value);\\n        // console.logBytes(requestData);\\n        return (bitcoinAmount, arbitraryData);\\n    }\\n    \\n    function parseRecipientAddress(bytes memory arbitraryData) internal returns (address parsedValue){\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 0, 19);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 20))\\n        }\\n        // console.log(\\\"parseRecipientAddress\\\", parsedValue);\\n    }\\n\\n    function parseTeleporterFee(bytes memory arbitraryData) internal returns (uint64 parsedValue){\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 20, 27);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 8))\\n        }\\n        // console.log(\\\"parseTeleporterFee\\\", parsedValue);\\n    }\\n\\n    function parseIsExchange(bytes memory arbitraryData) internal returns (bool parsedValue){\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 28, 28);\\n        bytes1 zero = 0x00;\\n        if (slicedBytes[0] == zero) {\\n            parsedValue = false;\\n        } else {\\n            parsedValue = true;\\n        }\\n        // console.log(\\\"parseIsExchange\\\", parsedValue);\\n    }\\n\\n    function parseSpeed(bytes memory arbitraryData) internal returns (uint8 parsedValue){\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 29, 29);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 1))\\n        }\\n        // console.log(\\\"parseSpeed\\\", parsedValue);\\n    }\\n\\n    function parseExchangeToken(bytes memory arbitraryData) internal returns (address parsedValue){\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 30, 49);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 20))\\n        }\\n        // console.log(\\\"parseExchangeToken\\\", parsedValue);\\n    }\\n\\n    function parseExchangeAmount(bytes memory arbitraryData) internal returns (uint128 parsedValue){\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 50, 65);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 16))\\n        }\\n        // console.log(\\\"parseExchangeAmount\\\", parsedValue);\\n    }\\n\\n    function parseDeadline(bytes memory arbitraryData) internal returns (uint64 parsedValue){\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 66, 73);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 8))\\n        }\\n        // console.log(\\\"parseDeadline\\\", parsedValue);\\n    }\\n\\n    function parseIsFixedToken(bytes memory arbitraryData) internal returns (bool parsedValue) {\\n        bytes memory slicedBytes = sliceBytes(arbitraryData, 74, 74);\\n        bytes1 zero = 0x00;\\n        if (slicedBytes[0] == zero) {\\n            parsedValue = false;\\n        } else {\\n            parsedValue = true;\\n        }\\n        // console.log(\\\"parseIsFixedToken\\\", parsedValue);\\n    }\\n\\n    function sliceBytes(bytes memory data, uint start, uint end) internal returns (bytes memory result) {\\n        byte temp;\\n        for (uint i = start; i < end + 1; i++) {\\n            temp = data[i];\\n            result = abi.encodePacked(result, temp);\\n        }\\n    }\\n\\n    // TODO: add exchange path to arbitrary data (for now, user only gives us the exchnage token address)\\n    // function parsePath(bytes memory arbitraryData)\\n    //     internal\\n    //     returns (address[] memory)\\n    // {\\n    //     uint256 sizeofPath;\\n    //     assembly {\\n    //         sizeofPath := mload(add(arbitraryData, 356)) // bias = 4*32 + 4\\n    //     } // found the postion using testing\\n    //     address temp;\\n    //     uint256 index;\\n    //     index = 356 + 32;\\n\\n    //     for (uint256 i = 0; i < sizeofPath; i++) {\\n    //         assembly {\\n    //             temp := mload(add(arbitraryData, index))\\n    //         }\\n    //         parsedPath.push(temp);\\n    //         index = index + 32;\\n    //     }\\n    //     return parsedPath;\\n    // }\\n\\n}\\n\",\"keccak256\":\"0x6053440b5f729a61008c0a084fcfde7c1cfe839eb1c8363dd732c1d0203af6f7\"},\"contracts/libraries/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n    \\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b; //TODO: edit it\\n    }\\n}\\n\",\"keccak256\":\"0x8d7c458d27f34a0512d902ee3b662022a586ce1c27a79a0c260c676fd55c454d\"},\"contracts/libraries/TeleportDAOLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\nimport '../pools/interfaces/ILiquidityPool.sol';\\nimport '../pools/interfaces/ILiquidityPoolFactory.sol';\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary TeleportDAOLibrary {\\n    using SafeMath for uint;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'TeleportDAOLibrary: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'TeleportDAOLibrary: ZERO_ADDRESS');\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    // function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n    //     (address token0, address token1) = sortTokens(tokenA, tokenB);\\n    //     pair = address(uint(keccak256(abi.encodePacked(\\n    //             hex'ff',\\n    //             factory,\\n    //             keccak256(abi.encodePacked(token0, token1)),\\n    //             hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\\n    //         ))));\\n    // }\\n    \\n    //Instead of TeleportDAOLibrary\\n    function pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {\\n        // (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = ILiquidityPoolFactory(factory).getLiquidityPool(tokenA, tokenB);\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    // function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\n    //     (address token0,) = sortTokens(tokenA, tokenB);\\n    //     (uint reserve0, uint reserve1,) = ITeleportDAOPair(pairFor(factory, tokenA, tokenB)).getReserves();\\n    //     (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    // }\\n    \\n    //Instead of TeleportDAOLibrary\\n    function getReserves(address factory, address tokenA, address tokenB) internal returns (uint reserveA, uint reserveB) {\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        (uint reserve0, uint reserve1,) = ILiquidityPool(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA > 0, 'TeleportDAOLibrary: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'TeleportDAOLibrary: INSUFFICIENT_LIQUIDITY');\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\n        require(amountIn > 0, 'TeleportDAOLibrary: INSUFFICIENT_INPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'TeleportDAOLibrary: INSUFFICIENT_LIQUIDITY');\\n        uint amountInWithFee = amountIn.mul(997);\\n        uint numerator = amountInWithFee.mul(reserveOut);\\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\\n        require(amountOut > 0, 'TeleportDAOLibrary: INSUFFICIENT_OUTPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'TeleportDAOLibrary: INSUFFICIENT_LIQUIDITY');\\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\\n        uint denominator = reserveOut.sub(amountOut).mul(997);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    // function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\\n    //     require(path.length >= 2, 'TeleportDAOLibrary: INVALID_PATH');\\n    //     amounts = new uint[](path.length);\\n    //     amounts[0] = amountIn;\\n    //     for (uint i; i < path.length - 1; i++) {\\n    //         (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n    //         amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n    //     }\\n    // }\\n    \\n    //Instead of TeleportDAOLibrary\\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'TeleportDAOLibrary: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint i; i < path.length - 1; i++) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    // function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\\n    //     require(path.length >= 2, 'TeleportDAOLibrary: INVALID_PATH');\\n    //     amounts = new uint[](path.length);\\n    //     amounts[amounts.length - 1] = amountOut;\\n    //     for (uint i = path.length - 1; i > 0; i--) {\\n    //         (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n    //         amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n    //     }\\n    // }\\n    \\n    //Instead of TeleportDAOLibrary\\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'TeleportDAOLibrary: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint i = path.length - 1; i > 0; i--) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x03a5272548efe0c985e326d3b480dd2a2c780d2b021b48ebbaa74eeca8b462bd\"},\"contracts/libraries/TypedMemView.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.7.6;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary TypedMemView {\\n    using SafeMath for uint256;\\n\\n    // Why does this exist?\\n    // the solidity `bytes memory` type has a few weaknesses.\\n    // 1. You can't index ranges effectively\\n    // 2. You can't slice without copying\\n    // 3. The underlying data may represent any type\\n    // 4. Solidity never deallocates memory, and memory costs grow\\n    //    superlinearly\\n\\n    // By using a memory view instead of a `bytes memory` we get the following\\n    // advantages:\\n    // 1. Slices are done on the stack, by manipulating the pointer\\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\\n    // 3. We can insert type info into the pointer, and typecheck at runtime\\n\\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\\n    // algorithms.\\n\\n    // Why bytes29?\\n    // We want to avoid confusion between views, digests, and other common\\n    // types so we chose a large and uncommonly used odd number of bytes\\n    //\\n    // Note that while bytes are left-aligned in a word, integers and addresses\\n    // are right-aligned. This means when working in assembly we have to\\n    // account for the 3 unused bytes on the righthand side\\n    //\\n    // First 5 bytes are a type flag.\\n    // - ff_ffff_fffe is reserved for unknown type.\\n    // - ff_ffff_ffff is reserved for invalid types/errors.\\n    // next 12 are memory address\\n    // next 12 are len\\n    // bottom 3 bytes are empty\\n\\n    // Assumptions:\\n    // - non-modification of memory.\\n    // - No Solidity updates\\n    // - - wrt free mem point\\n    // - - wrt bytes representation in memory\\n    // - - wrt memory addressing in general\\n\\n    // Usage:\\n    // - create type constants\\n    // - use `assertType` for runtime type assertions\\n    // - - unfortunately we can't do this at compile time yet :(\\n    // - recommended: implement modifiers that perform type checking\\n    // - - e.g.\\n    // - - `uint40 constant MY_TYPE = 3;`\\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\\n    // - instantiate a typed view from a bytearray using `ref`\\n    // - use `index` to inspect the contents of the view\\n    // - use `slice` to create smaller views into the same memory\\n    // - - `slice` can increase the offset\\n    // - - `slice can decrease the length`\\n    // - - must specify the output type of `slice`\\n    // - - `slice` will return a null view if you try to overrun\\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\\n    // - use `equal` for typed comparisons.\\n\\n\\n    // The null view\\n    bytes29 public constant NULL = hex\\\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\\";\\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\\n    uint8 constant TWELVE_BYTES = 96;\\n\\n    /**\\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\\n     * @param _b    The byte\\n     * @return      char - The encoded hex character\\n     */\\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\\n        // This can probably be done more efficiently, but it's only in error\\n        // paths, so we don't really care :)\\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\\n        if (_nibble == 0xf0) {return 0x30;} // 0\\n        if (_nibble == 0xf1) {return 0x31;} // 1\\n        if (_nibble == 0xf2) {return 0x32;} // 2\\n        if (_nibble == 0xf3) {return 0x33;} // 3\\n        if (_nibble == 0xf4) {return 0x34;} // 4\\n        if (_nibble == 0xf5) {return 0x35;} // 5\\n        if (_nibble == 0xf6) {return 0x36;} // 6\\n        if (_nibble == 0xf7) {return 0x37;} // 7\\n        if (_nibble == 0xf8) {return 0x38;} // 8\\n        if (_nibble == 0xf9) {return 0x39;} // 9\\n        if (_nibble == 0xfa) {return 0x61;} // a\\n        if (_nibble == 0xfb) {return 0x62;} // b\\n        if (_nibble == 0xfc) {return 0x63;} // c\\n        if (_nibble == 0xfd) {return 0x64;} // d\\n        if (_nibble == 0xfe) {return 0x65;} // e\\n        if (_nibble == 0xff) {return 0x66;} // f\\n    }\\n\\n    /**\\n     * @notice      Returns a uint16 containing the hex-encoded byte.\\n     * @param _b    The byte\\n     * @return      encoded - The hex-encoded byte\\n     */\\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\\n        encoded |= nibbleHex(_b >> 4); // top 4 bits\\n        encoded <<= 8;\\n        encoded |= nibbleHex(_b); // lower 4 bits\\n    }\\n\\n    /**\\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\\n     *              `second` contains the encoded lower 16 bytes.\\n     *\\n     * @param _b    The 32 bytes as uint256\\n     * @return      first - The top 16 bytes\\n     * @return      second - The bottom 16 bytes\\n     */\\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\\n        for (uint8 i = 31; i > 15; i -= 1) {\\n            uint8 _byte = uint8(_b >> (i * 8));\\n            first |= byteHex(_byte);\\n            if (i != 16) {\\n                first <<= 16;\\n            }\\n        }\\n\\n        // abusing underflow here =_=\\n        for (uint8 i = 15; i < 255 ; i -= 1) {\\n            uint8 _byte = uint8(_b >> (i * 8));\\n            second |= byteHex(_byte);\\n            if (i != 0) {\\n                second <<= 16;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice          Changes the endianness of a uint256.\\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\\n     * @param _b        The unsigned integer to reverse\\n     * @return          v - The reversed value\\n     */\\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\\n        v = _b;\\n\\n        // swap bytes\\n        v = ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n        // swap 2-byte long pairs\\n        v = ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n        // swap 4-byte long pairs\\n        v = ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n        // swap 8-byte long pairs\\n        v = ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n        // swap 16-byte long pairs\\n        v = (v >> 128) | (v << 128);\\n    }\\n\\n    /**\\n     * @notice      Create a mask with the highest `_len` bits set.\\n     * @param _len  The length\\n     * @return      mask - The mask\\n     */\\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\\n        // ugly. redo without assembly?\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            mask := sar(\\n                sub(_len, 1),\\n                0x8000000000000000000000000000000000000000000000000000000000000000\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @notice      Return the null view.\\n     * @return      bytes29 - The null view\\n     */\\n    function nullView() internal pure returns (bytes29) {\\n        return NULL;\\n    }\\n\\n    /**\\n     * @notice      Check if the view is null.\\n     * @return      bool - True if the view is null\\n     */\\n    function isNull(bytes29 memView) internal pure returns (bool) {\\n        return memView == NULL;\\n    }\\n\\n    /**\\n     * @notice      Check if the view is not null.\\n     * @return      bool - True if the view is not null\\n     */\\n    function notNull(bytes29 memView) internal pure returns (bool) {\\n        return !isNull(memView);\\n    }\\n\\n    /**\\n     * @notice          Check if the view is of a valid type and points to a valid location\\n     *                  in memory.\\n     * @dev             We perform this check by examining solidity's unallocated memory\\n     *                  pointer and ensuring that the view's upper bound is less than that.\\n     * @param memView   The view\\n     * @return          ret - True if the view is valid\\n     */\\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\\n        if (typeOf(memView) == 0xffffffffff) {return false;}\\n        uint256 _end = end(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ret := not(gt(_end, mload(0x40)))\\n        }\\n    }\\n\\n    /**\\n     * @notice          Require that a typed memory view be valid.\\n     * @dev             Returns the view for easy chaining.\\n     * @param memView   The view\\n     * @return          bytes29 - The validated view\\n     */\\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\\n        require(isValid(memView), \\\"Validity assertion failed\\\");\\n        return memView;\\n    }\\n\\n    /**\\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\\n     * @param memView   The view\\n     * @param _expected The expected type\\n     * @return          bool - True if the memview is of the expected type\\n     */\\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\\n        return typeOf(memView) == _expected;\\n    }\\n\\n    /**\\n     * @notice          Require that a typed memory view has a specific type.\\n     * @dev             Returns the view for easy chaining.\\n     * @param memView   The view\\n     * @param _expected The expected type\\n     * @return          bytes29 - The view with validated type\\n     */\\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\\n        if (!isType(memView, _expected)) {\\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\\n            (, uint256 e) = encodeHex(uint256(_expected));\\n            string memory err = string(\\n                abi.encodePacked(\\n                    \\\"Type assertion failed. Got 0x\\\",\\n                    uint80(g),\\n                    \\\". Expected 0x\\\",\\n                    uint80(e)\\n                )\\n            );\\n            revert(err);\\n        }\\n        return memView;\\n    }\\n\\n    /**\\n     * @notice          Return an identical view with a different type.\\n     * @param memView   The view\\n     * @param _newType  The new type\\n     * @return          newView - The new view with the specified type\\n     */\\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\\n        // then | in the new type\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // shift off the top 5 bytes\\n            newView := or(newView, shr(40, shl(40, memView)))\\n            newView := or(newView, shl(216, _newType))\\n        }\\n    }\\n\\n    /**\\n     * @notice          Unsafe raw pointer construction. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @dev             Unsafe raw pointer construction. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @param _type     The type\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @return          newView - The new view with the specified type, location and length\\n     */\\n    function unsafeBuildUnchecked(uint256 _type, uint256 _loc, uint256 _len) private pure returns (bytes29 newView) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            newView := shl(96, or(newView, _type)) // insert type\\n            newView := shl(96, or(newView, _loc))  // insert loc\\n            newView := shl(24, or(newView, _len))  // empty bottom 3 bytes\\n        }\\n    }\\n\\n    /**\\n     * @notice          Instantiate a new memory view. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @dev             Instantiate a new memory view. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @param _type     The type\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @return          newView - The new view with the specified type, location and length\\n     */\\n    function build(uint256 _type, uint256 _loc, uint256 _len) internal pure returns (bytes29 newView) {\\n        uint256 _end = _loc.add(_len);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            if gt(_end, mload(0x40)) {\\n                _end := 0\\n            }\\n        }\\n        if (_end == 0) {\\n            return NULL;\\n        }\\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Instantiate a memory view from a byte array.\\n     * @dev             Note that due to Solidity memory representation, it is not possible to\\n     *                  implement a deref, as the `bytes` type stores its len in memory.\\n     * @param arr       The byte array\\n     * @param newType   The type\\n     * @return          bytes29 - The memory view\\n     */\\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\\n        uint256 _len = arr.length;\\n\\n        uint256 _loc;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            _loc := add(arr, 0x20)  // our view is of the data, not the struct\\n        }\\n\\n        return build(newType, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Return the associated type information.\\n     * @param memView   The memory view\\n     * @return          _type - The type associated with the view\\n     */\\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // 216 == 256 - 40\\n            _type := shr(216, memView) // shift out lower 24 bytes\\n        }\\n    }\\n\\n    /**\\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the 5-byte type flag is equal\\n     */\\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return (left ^ right) >> (2 * TWELVE_BYTES) == 0;\\n    }\\n\\n    /**\\n     * @notice          Return the memory address of the underlying bytes.\\n     * @param memView   The view\\n     * @return          _loc - The memory address\\n     */\\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\\n            _loc := and(shr(120, memView), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          The number of memory words this memory view occupies, rounded up.\\n     * @param memView   The view\\n     * @return          uint256 - The number of memory words\\n     */\\n    function words(bytes29 memView) internal pure returns (uint256) {\\n        return uint256(len(memView)).add(32) / 32;\\n    }\\n\\n    /**\\n     * @notice          The in-memory footprint of a fresh copy of the view.\\n     * @param memView   The view\\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\\n     */\\n    function footprint(bytes29 memView) internal pure returns (uint256) {\\n        return words(memView) * 32;\\n    }\\n\\n    /**\\n     * @notice          The number of bytes of the view.\\n     * @param memView   The view\\n     * @return          _len - The length of the view\\n     */\\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            _len := and(shr(24, memView), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Returns the endpoint of `memView`.\\n     * @param memView   The view\\n     * @return          uint256 - The endpoint of `memView`\\n     */\\n    function end(bytes29 memView) internal pure returns (uint256) {\\n        return loc(memView) + len(memView);\\n    }\\n\\n    /**\\n     * @notice          Safe slicing without memory modification.\\n     * @param memView   The view\\n     * @param _index    The start index\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function slice(bytes29 memView, uint256 _index, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        uint256 _loc = loc(memView);\\n\\n        // Ensure it doesn't overrun the view\\n        if (_loc.add(_index).add(_len) > end(memView)) {\\n            return NULL;\\n        }\\n\\n        _loc = _loc.add(_index);\\n        return build(newType, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\\n     * @param memView   The view\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function prefix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        return slice(memView, 0, _len, newType);\\n    }\\n\\n    /**\\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\\n     * @param memView   The view\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function postfix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        return slice(memView, uint256(len(memView)).sub(_len), _len, newType);\\n    }\\n\\n    /**\\n     * @notice          Construct an error message for an indexing overrun.\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @param _index    The index\\n     * @param _slice    The slice where the overrun occurred\\n     * @return          err - The err\\n     */\\n    function indexErrOverrun(\\n        uint256 _loc,\\n        uint256 _len,\\n        uint256 _index,\\n        uint256 _slice\\n    ) internal pure returns (string memory err) {\\n        (, uint256 a) = encodeHex(_loc);\\n        (, uint256 b) = encodeHex(_len);\\n        (, uint256 c) = encodeHex(_index);\\n        (, uint256 d) = encodeHex(_slice);\\n        err = string(\\n            abi.encodePacked(\\n                \\\"TypedMemView/index - Overran the view. Slice is at 0x\\\",\\n                uint48(a),\\n                \\\" with length 0x\\\",\\n                uint48(b),\\n                \\\". Attempted to index at offset 0x\\\",\\n                uint48(c),\\n                \\\" with length 0x\\\",\\n                uint48(d),\\n                \\\".\\\"\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice          Load up to 32 bytes from the view onto the stack.\\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\\n     *                  This can be immediately cast to a smaller fixed-length byte array.\\n     *                  To automatically cast to an integer, use `indexUint`.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The 32 byte result\\n     */\\n    function index(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (bytes32 result) {\\n        if (_bytes == 0) {return bytes32(0);}\\n        if (_index.add(_bytes) > len(memView)) {\\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\\n        }\\n        require(_bytes <= 32, \\\"TypedMemView/index - Attempted to index more than 32 bytes\\\");\\n\\n        uint8 bitLength = _bytes * 8;\\n        uint256 _loc = loc(memView);\\n        uint256 _mask = leftMask(bitLength);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            result := and(mload(add(_loc, _index)), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Parse an unsigned integer from the view at `_index`.\\n     * @dev             Requires that the view have >= `_bytes` bytes following that index.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The unsigned integer\\n     */\\n    function indexUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {\\n        return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\\n    }\\n\\n    /**\\n     * @notice          Parse an unsigned integer from LE bytes.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes\\n     * @return          result - The unsigned integer\\n     */\\n    function indexLEUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {\\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\\n    }\\n\\n    /**\\n     * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\\n     *                  following that index.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @return          address - The address\\n     */\\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\\n        return address(uint160(indexUint(memView, _index, 20)));\\n    }\\n\\n    /**\\n     * @notice          Return the keccak256 hash of the underlying memory\\n     * @param memView   The view\\n     * @return          digest - The keccak256 hash of the underlying memory\\n     */\\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            digest := keccak256(_loc, _len)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Return the sha2 digest of the underlying memory.\\n     * @dev             We explicitly deallocate memory afterwards.\\n     * @param memView   The view\\n     * @return          digest - The sha2 hash of the underlying memory\\n     */\\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\\n     * @param memView   The pre-image\\n     * @return          digest - the Digest\\n     */\\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\\n        }\\n    }\\n\\n    /**\\n     * @notice          Implements bitcoin's hash256 (double sha2)\\n     * @param memView   A view of the preimage\\n     * @return          digest - the Digest\\n     */\\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Return true if the underlying memory is equal. Else false.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the underlying memory is equal\\n     */\\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\\n    }\\n\\n    /**\\n     * @notice          Return false if the underlying memory is equal. Else true.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - False if the underlying memory is equal\\n     */\\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return !untypedEqual(left, right);\\n    }\\n\\n    /**\\n     * @notice          Compares type equality.\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the types are the same\\n     */\\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\\n    }\\n\\n    /**\\n     * @notice          Compares type inequality.\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the types are not the same\\n     */\\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return !equal(left, right);\\n    }\\n\\n    /**\\n     * @notice          Copy the view to a location, return an unsafe memory reference\\n     * @dev             Super Dangerous direct memory access.\\n     *\\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\\n     *                  As such it MUST be consumed IMMEDIATELY.\\n     *                  This function is private to prevent unsafe usage by callers.\\n     * @param memView   The view\\n     * @param _newLoc   The new location\\n     * @return          written - the unsafe memory reference\\n     */\\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\\n        require(notNull(memView), \\\"TypedMemView/copyTo - Null pointer deref\\\");\\n        require(isValid(memView), \\\"TypedMemView/copyTo - Invalid pointer deref\\\");\\n        uint256 _len = len(memView);\\n        uint256 _oldLoc = loc(memView);\\n\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40)\\n            // revert if we're writing in occupied memory\\n            if gt(ptr, _newLoc) {\\n                revert(0x60, 0x20) // empty revert message\\n            }\\n\\n            // use the identity precompile to copy\\n            // guaranteed not to fail, so pop the success\\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\\n        }\\n\\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\\n    }\\n\\n    /**\\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\\n     *                  the new memory\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param memView   The view\\n     * @return          ret - The view pointing to the new memory\\n     */\\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\\n        uint256 ptr;\\n        uint256 _len = len(memView);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n            ret := ptr\\n        }\\n        unsafeCopyTo(memView, ptr + 0x20);\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\\n            mstore(ptr, _len) // write len of new array (in bytes)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\\n     * @dev             Super Dangerous direct memory access.\\n     *\\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\\n     *                  As such it MUST be consumed IMMEDIATELY.\\n     *                  This function is private to prevent unsafe usage by callers.\\n     * @param memViews  The views\\n     * @return          unsafeView - The conjoined view pointing to the new memory\\n     */\\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            // revert if we're writing in occupied memory\\n            if gt(ptr, _location) {\\n                revert(0x60, 0x20) // empty revert message\\n            }\\n        }\\n\\n        uint256 _offset = 0;\\n        for (uint256 i = 0; i < memViews.length; i ++) {\\n            bytes29 memView = memViews[i];\\n            unsafeCopyTo(memView, _location + _offset);\\n            _offset += len(memView);\\n        }\\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\\n    }\\n\\n    /**\\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\\n     * @param memViews  The views\\n     * @return          bytes32 - The keccak256 digest\\n     */\\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n        return keccak(unsafeJoin(memViews, ptr));\\n    }\\n\\n    /**\\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\\n     * @param memViews  The views\\n     * @return          bytes32 - The sha256 digest\\n     */\\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n        return sha2(unsafeJoin(memViews, ptr));\\n    }\\n\\n    /**\\n     * @notice          copies all views, joins them into a new bytearray.\\n     * @param memViews  The views\\n     * @return          ret - The new byte array\\n     */\\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\\n        uint256 ptr;\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n\\n        bytes29 _newView = unsafeJoin(memViews, ptr + 0x20);\\n        uint256 _written = len(_newView);\\n        uint256 _footprint = footprint(_newView);\\n\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            // store the legnth\\n            mstore(ptr, _written)\\n            // new pointer is old + 0x20 + the footprint of the body\\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\\n            ret := ptr\\n        }\\n    }\\n}\",\"keccak256\":\"0x00cbfbbcbe4334fe3f66659074dc2785d689c249ebf259a60b65e2e52cde1a73\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/libraries/ViewBTC.sol\":{\"content\":\"pragma solidity 0.7.6;\\n\\n/** @title BitcoinSPV */\\n/** @author Summa (https://summa.one) */\\n\\nimport \\\"./TypedMemView.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary ViewBTC {\\n    using TypedMemView for bytes29;\\n    using SafeMath for uint256;\\n\\n    // The target at minimum Difficulty. Also the target of the genesis block\\n    uint256 public constant DIFF1_TARGET = 0xffff0000000000000000000000000000000000000000000000000000;\\n\\n    uint256 public constant RETARGET_PERIOD = 2 * 7 * 24 * 60 * 60;  // 2 weeks in seconds\\n    uint256 public constant RETARGET_PERIOD_BLOCKS = 2016;  // 2 weeks in blocks\\n\\n    enum BTCTypes {\\n        Unknown,            // 0x0\\n        CompactInt,         // 0x1\\n        ScriptSig,          // 0x2 - with length prefix\\n        Outpoint,           // 0x3\\n        TxIn,               // 0x4\\n        IntermediateTxIns,  // 0x5 - used in vin parsing\\n        Vin,                // 0x6\\n        ScriptPubkey,       // 0x7 - with length prefix\\n        PKH,                // 0x8 - the 20-byte payload digest\\n        WPKH,               // 0x9 - the 20-byte payload digest\\n        WSH,                // 0xa - the 32-byte payload digest\\n        SH,                 // 0xb - the 20-byte payload digest\\n        OpReturnPayload,    // 0xc\\n        TxOut,              // 0xd\\n        IntermediateTxOuts, // 0xe - used in vout parsing\\n        Vout,               // 0xf\\n        Header,             // 0x10\\n        HeaderArray,        // 0x11\\n        MerkleNode,         // 0x12\\n        MerkleStep,         // 0x13\\n        MerkleArray         // 0x14\\n    }\\n\\n    // TODO: any way to bubble up more info?\\n    // @notice             requires `memView` to be of a specified type\\n    // @param memView      a 29-byte view with a 5-byte type\\n    // @param t            the expected type (e.g. BTCTypes.Outpoint, BTCTypes.TxIn, etc)\\n    // @return             passes if it is the correct type, errors if not\\n    modifier typeAssert(bytes29 memView, BTCTypes t) {\\n        memView.assertType(uint40(t));\\n        _;\\n    }\\n\\n    // Revert with an error message re: non-minimal VarInts\\n    function revertNonMinimal(bytes29 ref) private pure returns (string memory) {\\n        (, uint256 g) = TypedMemView.encodeHex(ref.indexUint(0, uint8(ref.len())));\\n        string memory err = string(\\n            abi.encodePacked(\\n                \\\"Non-minimal var int. Got 0x\\\",\\n                uint144(g)\\n            )\\n        );\\n        revert(err);\\n    }\\n\\n    // @notice             reads a compact int from the view at the specified index\\n    // @param memView      a 29-byte view with a 5-byte type\\n    // @param _index       the index\\n    // @return             the compact int at the specified index\\n    function indexCompactInt(bytes29 memView, uint256 _index) internal pure returns (uint64 number) {\\n        uint256 flag = memView.indexUint(_index, 1);\\n        if (flag <= 0xfc) {\\n            return uint64(flag);\\n        } else if (flag == 0xfd) {\\n            number = uint64(memView.indexLEUint(_index + 1, 2));\\n            if (compactIntLength(number) != 3) {revertNonMinimal(memView.slice(_index, 3, 0));}\\n        } else if (flag == 0xfe) {\\n            number = uint64(memView.indexLEUint(_index + 1, 4));\\n            if (compactIntLength(number) != 5) {revertNonMinimal(memView.slice(_index, 5, 0));}\\n        } else if (flag == 0xff) {\\n            number = uint64(memView.indexLEUint(_index + 1, 8));\\n            if (compactIntLength(number) != 9) {revertNonMinimal(memView.slice(_index, 9, 0));}\\n        }\\n    }\\n\\n    // @notice         gives the total length (in bytes) of a CompactInt-encoded number\\n    // @param number   the number as uint64\\n    // @return         the compact integer as uint8\\n    function compactIntLength(uint64 number) internal pure returns (uint8) {\\n        if (number <= 0xfc) {\\n            return 1;\\n        } else if (number <= 0xffff) {\\n            return 3;\\n        } else if (number <= 0xffffffff) {\\n            return 5;\\n        } else {\\n            return 9;\\n        }\\n    }\\n\\n    // @notice             extracts the LE txid from an outpoint\\n    // @param _outpoint    the outpoint\\n    // @return             the LE txid\\n    function txidLE(bytes29 _outpoint) internal pure typeAssert(_outpoint, BTCTypes.Outpoint) returns (bytes32) {\\n        return _outpoint.index(0, 32);\\n    }\\n\\n    // @notice             extracts the index as an integer from the outpoint\\n    // @param _outpoint    the outpoint\\n    // @return             the index\\n    function outpointIdx(bytes29 _outpoint) internal pure typeAssert(_outpoint, BTCTypes.Outpoint) returns (uint32) {\\n        return uint32(_outpoint.indexLEUint(32, 4));\\n    }\\n\\n    // @notice          extracts the outpoint from an input\\n    // @param _input    the input\\n    // @return          the outpoint as a typed memory\\n    function outpoint(bytes29 _input) internal pure typeAssert(_input, BTCTypes.TxIn) returns (bytes29) {\\n        return _input.slice(0, 36, uint40(BTCTypes.Outpoint));\\n    }\\n\\n    // @notice           extracts the script sig from an input\\n    // @param _input     the input\\n    // @return           the script sig as a typed memory\\n    function scriptSig(bytes29 _input) internal pure typeAssert(_input, BTCTypes.TxIn) returns (bytes29) {\\n        uint64 scriptLength = indexCompactInt(_input, 36);\\n        return _input.slice(36, compactIntLength(scriptLength) + scriptLength, uint40(BTCTypes.ScriptSig));\\n    }\\n\\n    // @notice         extracts the sequence from an input\\n    // @param _input   the input\\n    // @return         the sequence\\n    function sequence(bytes29 _input) internal pure typeAssert(_input, BTCTypes.TxIn) returns (uint32) {\\n        uint64 scriptLength = indexCompactInt(_input, 36);\\n        uint256 scriptEnd = 36 + compactIntLength(scriptLength) + scriptLength;\\n        return uint32(_input.indexLEUint(scriptEnd, 4));\\n    }\\n\\n    // @notice         determines the length of the first input in an array of inputs\\n    // @param _inputs  the vin without its length prefix\\n    // @return         the input length\\n    function inputLength(bytes29 _inputs) internal pure typeAssert(_inputs, BTCTypes.IntermediateTxIns) returns (uint256) {\\n        uint64 scriptLength = indexCompactInt(_inputs, 36);\\n        return uint256(compactIntLength(scriptLength)) + uint256(scriptLength) + 36 + 4;\\n    }\\n\\n    // @notice         extracts the input at a specified index\\n    // @param _vin     the vin\\n    // @param _index   the index of the desired input\\n    // @return         the desired input\\n    function indexVin(bytes29 _vin, uint256 _index) internal pure typeAssert(_vin, BTCTypes.Vin) returns (bytes29) {\\n        uint256 _nIns = uint256(indexCompactInt(_vin, 0));\\n        uint256 _viewLen = _vin.len();\\n        require(_index < _nIns, \\\"Vin read overrun\\\");\\n\\n        uint256 _offset = uint256(compactIntLength(uint64(_nIns)));\\n        bytes29 _remaining;\\n        for (uint256 _i = 0; _i < _index; _i += 1) {\\n            _remaining = _vin.postfix(_viewLen.sub(_offset), uint40(BTCTypes.IntermediateTxIns));\\n            _offset += inputLength(_remaining);\\n        }\\n\\n        _remaining = _vin.postfix(_viewLen.sub(_offset), uint40(BTCTypes.IntermediateTxIns));\\n        uint256 _len = inputLength(_remaining);\\n        return _vin.slice(_offset, _len, uint40(BTCTypes.TxIn));\\n    }\\n\\n    // @notice         extracts the raw LE bytes of the output value\\n    // @param _output  the output\\n    // @return         the raw LE bytes of the output value\\n    function valueBytes(bytes29 _output) internal pure typeAssert(_output, BTCTypes.TxOut) returns (bytes8) {\\n        return bytes8(_output.index(0, 8));\\n    }\\n\\n    // @notice         extracts the value from an output\\n    // @param _output  the output\\n    // @return         the value\\n    // function value(bytes29 _output) internal pure typeAssert(_output, BTCTypes.TxOut) returns (uint64) {\\n    //     return uint64(_output.indexLEUint(0, 8));\\n    // }\\n    function value(bytes29 _output) internal pure returns (uint64) {\\n        return uint64(_output.indexLEUint(0, 8));\\n    }\\n\\n    // @notice             extracts the scriptPubkey from an output\\n    // @param _output      the output\\n    // @return             the scriptPubkey\\n    function scriptPubkey(bytes29 _output) internal typeAssert(_output, BTCTypes.TxOut) returns (bytes29) {\\n        uint64 scriptLength = indexCompactInt(_output, 8);\\n        return _output.slice(8, compactIntLength(scriptLength) + scriptLength, uint40(BTCTypes.ScriptPubkey));\\n    }\\n\\n    function scriptPubkeyBytes(bytes29 _output) internal typeAssert(_output, BTCTypes.TxOut) returns (bytes32) {\\n        uint64 scriptLength = indexCompactInt(_output, 8);\\n        bytes29 scriptPubkeyView = _output.slice(8, compactIntLength(scriptLength) + scriptLength, uint40(BTCTypes.ScriptPubkey));\\n        return scriptPubkeyView.index(compactIntLength(scriptLength), uint8(scriptLength));\\n    }\\n\\n    // @notice             determines the length of the first output in an array of outputs\\n    // @param _outputs     the vout without its length prefix\\n    // @return             the output length\\n    function outputLength(bytes29 _outputs) internal pure typeAssert(_outputs, BTCTypes.IntermediateTxOuts) returns (uint256) {\\n        uint64 scriptLength = indexCompactInt(_outputs, 8);\\n        return uint256(compactIntLength(scriptLength)) + uint256(scriptLength) + 8;\\n    }\\n\\n    // @notice         extracts the output at a specified index\\n    // @param _vout    the vout\\n    // @param _index   the index of the desired output\\n    // @return         the desired output\\n    // function indexVout(bytes29 _vout, uint256 _index) internal pure typeAssert(_vout, BTCTypes.Vout) returns (bytes29) {\\n    //     uint256 _nOuts = uint256(indexCompactInt(_vout, 0));\\n    //     uint256 _viewLen = _vout.len();\\n    //     require(_index < _nOuts, \\\"Vout read overrun\\\");\\n\\n    //     uint256 _offset = uint256(compactIntLength(uint64(_nOuts)));\\n    //     bytes29 _remaining;\\n    //     for (uint256 _i = 0; _i < _index; _i += 1) {\\n    //         _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n    //         _offset += outputLength(_remaining);\\n    //     }\\n\\n    //     _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n    //     uint256 _len = outputLength(_remaining);\\n    //     return _vout.slice(_offset, _len, uint40(BTCTypes.TxOut));\\n    // }\\n    function indexVout(bytes29 _vout, uint256 _index) internal pure returns (bytes29) {\\n        uint256 _nOuts = uint256(indexCompactInt(_vout, 0));\\n        uint256 _viewLen = _vout.len();\\n        require(_index < _nOuts, \\\"Vout read overrun\\\");\\n\\n        uint256 _offset = uint256(compactIntLength(uint64(_nOuts)));\\n        bytes29 _remaining;\\n        for (uint256 _i = 0; _i < _index; _i += 1) {\\n            _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n            _offset += outputLength(_remaining);\\n        }\\n\\n        _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n        uint256 _len = outputLength(_remaining);\\n        return _vout.slice(_offset, _len, uint40(BTCTypes.TxOut));\\n    }\\n\\n    // @notice         extracts the Op Return Payload\\n    // @param _spk     the scriptPubkey\\n    // @return         the Op Return Payload (or null if not a valid Op Return output)\\n    function opReturnPayload(bytes29 _spk) internal pure typeAssert(_spk, BTCTypes.ScriptPubkey) returns (bytes29) {\\n        uint64 _bodyLength = indexCompactInt(_spk, 0);\\n        uint64 _payloadLen = uint64(_spk.indexUint(2, 1));\\n        if (_bodyLength > 77 || _bodyLength < 4 || _spk.indexUint(1, 1) != 0x6a || _spk.indexUint(2, 1) != _bodyLength - 2) {\\n            return TypedMemView.nullView();\\n        }\\n        return _spk.slice(3, _payloadLen, uint40(BTCTypes.OpReturnPayload));\\n    }\\n\\n    // @notice         extracts the payload from a scriptPubkey\\n    // @param _spk     the scriptPubkey\\n    // @return         the payload (or null if not a valid PKH, SH, WPKH, or WSH output)\\n    function payload(bytes29 _spk) internal pure typeAssert(_spk, BTCTypes.ScriptPubkey) returns (bytes29) {\\n        uint256 _spkLength = _spk.len();\\n        uint256 _bodyLength = indexCompactInt(_spk, 0);\\n        if (_bodyLength > 0x22 || _bodyLength < 0x16 || _bodyLength + 1 != _spkLength) {\\n            return TypedMemView.nullView();\\n        }\\n\\n        // Legacy\\n        if (_bodyLength == 0x19 && _spk.indexUint(0, 4) == 0x1976a914 && _spk.indexUint(_spkLength - 2, 2) == 0x88ac) {\\n            return _spk.slice(4, 20, uint40(BTCTypes.PKH));\\n        } else if (_bodyLength == 0x17 && _spk.indexUint(0, 3) == 0x17a914 && _spk.indexUint(_spkLength - 1, 1) == 0x87) {\\n            return _spk.slice(3, 20, uint40(BTCTypes.SH));\\n        }\\n\\n        // Witness v0\\n        if (_spk.indexUint(1, 1) == 0) {\\n            uint256 _payloadLen = _spk.indexUint(2, 1);\\n            if (_bodyLength != 0x22 && _bodyLength != 0x16 || _payloadLen != _bodyLength - 2) {\\n                return TypedMemView.nullView();\\n            }\\n            uint40 newType = uint40(_payloadLen == 0x20 ? BTCTypes.WSH : BTCTypes.WPKH);\\n            return _spk.slice(3, _payloadLen, newType);\\n        }\\n\\n        return TypedMemView.nullView();\\n    }\\n\\n    // @notice     (loosely) verifies an spk and converts to a typed memory\\n    // @dev        will return null in error cases. Will not check for disabled opcodes.\\n    // @param _spk the spk\\n    // @return     the typed spk (or null if error)\\n    function tryAsSPK(bytes29 _spk) internal pure typeAssert(_spk, BTCTypes.Unknown) returns (bytes29) {\\n        if (_spk.len() == 0) {\\n            return TypedMemView.nullView();\\n        }\\n        uint64 _len = indexCompactInt(_spk, 0);\\n        if (_spk.len() == compactIntLength(_len) + _len) {\\n            return _spk.castTo(uint40(BTCTypes.ScriptPubkey));\\n        } else {\\n            return TypedMemView.nullView();\\n        }\\n    }\\n\\n    // @notice     verifies the vin and converts to a typed memory\\n    // @dev        will return null in error cases\\n    // @param _vin the vin\\n    // @return     the typed vin (or null if error)\\n    function tryAsVin(bytes29 _vin) internal pure typeAssert(_vin, BTCTypes.Unknown) returns (bytes29) {\\n        if (_vin.len() == 0) {\\n            return TypedMemView.nullView();\\n        }\\n        uint64 _nIns = indexCompactInt(_vin, 0);\\n        uint256 _viewLen = _vin.len();\\n        if (_nIns == 0) {\\n            return TypedMemView.nullView();\\n        }\\n\\n        uint256 _offset = uint256(compactIntLength(_nIns));\\n        for (uint256 i = 0; i < _nIns; i++) {\\n            if (_offset >= _viewLen) {\\n                // We've reached the end, but are still trying to read more\\n                return TypedMemView.nullView();\\n            }\\n            bytes29 _remaining = _vin.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxIns));\\n            _offset += inputLength(_remaining);\\n        }\\n        if (_offset != _viewLen) {\\n            return TypedMemView.nullView();\\n        }\\n        return _vin.castTo(uint40(BTCTypes.Vin));\\n    }\\n\\n    // @notice         verifies the vout and converts to a typed memory\\n    // @dev            will return null in error cases\\n    // @param _vout    the vout\\n    // @return         the typed vout (or null if error)\\n    function tryAsVout(bytes29 _vout) internal pure typeAssert(_vout, BTCTypes.Unknown) returns (bytes29) {\\n        if (_vout.len() == 0) {\\n            return TypedMemView.nullView();\\n        }\\n        uint64 _nOuts = indexCompactInt(_vout, 0);\\n        uint256 _viewLen = _vout.len();\\n        if (_nOuts == 0) {\\n            return TypedMemView.nullView();\\n        }\\n\\n        uint256 _offset = uint256(compactIntLength(_nOuts));\\n        for (uint256 i = 0; i < _nOuts; i++) {\\n            if (_offset >= _viewLen) {\\n                // We've reached the end, but are still trying to read more\\n                return TypedMemView.nullView();\\n            }\\n            bytes29 _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n            _offset += outputLength(_remaining);\\n        }\\n        if (_offset != _viewLen) {\\n            return TypedMemView.nullView();\\n        }\\n        return _vout.castTo(uint40(BTCTypes.Vout));\\n    }\\n\\n    // @notice         verifies the header and converts to a typed memory\\n    // @dev            will return null in error cases\\n    // @param _header  the header\\n    // @return         the typed header (or null if error)\\n    function tryAsHeader(bytes29 _header) internal pure typeAssert(_header, BTCTypes.Unknown) returns (bytes29) {\\n        if (_header.len() != 80) {\\n            return TypedMemView.nullView();\\n        }\\n        return _header.castTo(uint40(BTCTypes.Header));\\n    }\\n\\n\\n    // @notice         Index a header array.\\n    // @dev            Errors on overruns\\n    // @param _arr     The header array\\n    // @param index    The 0-indexed location of the header to get\\n    // @return         the typed header at `index`\\n    function indexHeaderArray(bytes29 _arr, uint256 index) internal pure typeAssert(_arr, BTCTypes.HeaderArray) returns (bytes29) {\\n        uint256 _start = index.mul(80);\\n        return _arr.slice(_start, 80, uint40(BTCTypes.Header));\\n    }\\n\\n\\n    // @notice     verifies the header array and converts to a typed memory\\n    // @dev        will return null in error cases\\n    // @param _arr the header array\\n    // @return     the typed header array (or null if error)\\n    function tryAsHeaderArray(bytes29 _arr) internal pure typeAssert(_arr, BTCTypes.Unknown) returns (bytes29) {\\n        if (_arr.len() % 80 != 0) {\\n            return TypedMemView.nullView();\\n        }\\n        return _arr.castTo(uint40(BTCTypes.HeaderArray));\\n    }\\n\\n    // @notice     verifies the merkle array and converts to a typed memory\\n    // @dev        will return null in error cases\\n    // @param _arr the merkle array\\n    // @return     the typed merkle array (or null if error)\\n    function tryAsMerkleArray(bytes29 _arr) internal pure typeAssert(_arr, BTCTypes.Unknown) returns (bytes29) {\\n        if (_arr.len() % 32 != 0) {\\n            return TypedMemView.nullView();\\n        }\\n        return _arr.castTo(uint40(BTCTypes.MerkleArray));\\n    }\\n\\n    // @notice         extracts the merkle root from the header\\n    // @param _header  the header\\n    // @return         the merkle root\\n    // function merkleRoot(bytes29 _header) internal pure typeAssert(_header, BTCTypes.Header) returns (bytes32) {\\n    //     return _header.index(36, 32);\\n    // }\\n\\n    function merkleRoot(bytes29 _header) internal pure returns (bytes32) {\\n        return _header.index(36, 32);\\n    }\\n\\n    // @notice         extracts the target from the header\\n    // @param _header  the header\\n    // @return         the target\\n    function target(bytes29  _header) internal pure typeAssert(_header, BTCTypes.Header) returns (uint256) {\\n        uint256 _mantissa = _header.indexLEUint(72, 3);\\n        uint256 _exponent = _header.indexUint(75, 1).sub(3);\\n        return _mantissa.mul(256 ** _exponent);\\n    }\\n\\n    // @notice         calculates the difficulty from a target\\n    // @param _target  the target\\n    // @return         the difficulty\\n    function toDiff(uint256  _target) internal pure returns (uint256) {\\n        return DIFF1_TARGET.div(_target);\\n    }\\n\\n    // @notice         extracts the difficulty from the header\\n    // @param _header  the header\\n    // @return         the difficulty\\n    function diff(bytes29  _header) internal pure typeAssert(_header, BTCTypes.Header) returns (uint256) {\\n        return toDiff(target(_header));\\n    }\\n\\n    // @notice         extracts the timestamp from the header\\n    // @param _header  the header\\n    // @return         the timestamp\\n    function time(bytes29  _header) internal pure typeAssert(_header, BTCTypes.Header) returns (uint32) {\\n        return uint32(_header.indexLEUint(68, 4));\\n    }\\n\\n    // @notice         extracts the parent hash from the header\\n    // @param _header  the header\\n    // @return         the parent hash\\n    function parent(bytes29 _header) internal pure typeAssert(_header, BTCTypes.Header) returns (bytes32) {\\n        return _header.index(4, 32);\\n    }\\n\\n    // @notice         calculates the Proof of Work hash of the header\\n    // @param _header  the header\\n    // @return         the Proof of Work hash\\n    function workHash(bytes29 _header) internal view typeAssert(_header, BTCTypes.Header) returns (bytes32) {\\n        return _header.hash256();\\n    }\\n\\n    // @notice         calculates the Proof of Work hash of the header, and converts to an integer\\n    // @param _header  the header\\n    // @return         the Proof of Work hash as an integer\\n    function work(bytes29 _header) internal view typeAssert(_header, BTCTypes.Header) returns (uint256) {\\n        return TypedMemView.reverseUint256(uint256(workHash(_header)));\\n    }\\n\\n    // @notice          Concatenates and hashes two inputs for merkle proving\\n    // @dev             Not recommended to call directly.\\n    // @param _a        The first hash\\n    // @param _b        The second hash\\n    // @return          The double-sha256 of the concatenated hashes\\n    function _merkleStep(bytes32 _a, bytes32 _b) internal view returns (bytes32 digest) {\\n        assembly {\\n            // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            mstore(ptr, _a)\\n            mstore(add(ptr, 0x20), _b)\\n            pop(staticcall(gas(), 2, ptr, 0x40, ptr, 0x20)) // sha2 #1\\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    // @notice         verifies a merkle proof\\n    // @param _leaf    the leaf\\n    // @param _proof   the merkle proof\\n    // @param _root    the merkle root\\n    // @param _index   the index\\n    // @return         true if valid, false if otherwise\\n    // function checkMerkle(\\n    //     bytes32 _leaf,\\n    //     bytes29 _proof,\\n    //     bytes32 _root,\\n    //     uint256 _index\\n    // ) internal view typeAssert(_proof, BTCTypes.MerkleArray) returns (bool) {\\n    //     uint256 nodes = _proof.len() / 32;\\n    //     if (nodes == 0) {\\n    //         return _leaf == _root;\\n    //     }\\n\\n    //     uint256 _idx = _index;\\n    //     bytes32 _current = _leaf;\\n\\n    //     for (uint i = 0; i < nodes; i++) {\\n    //         bytes32 _next = _proof.index(i * 32, 32);\\n    //         if (_idx % 2 == 1) {\\n    //             _current = _merkleStep(_next, _current);\\n    //         } else {\\n    //             _current = _merkleStep(_current, _next);\\n    //         }\\n    //         _idx >>= 1;\\n    //     }\\n\\n    //     return _current == _root;\\n    // }\\n    function checkMerkle(\\n        bytes32 _leaf, // _leaf is LE\\n        bytes29 _proof, // _proof nodes are LE\\n        bytes32 _root, // _root is BE (same as the merkle root that is stored in the block header)\\n        uint256 _index\\n    ) internal returns (bool) {\\n        uint256 nodes = _proof.len() / 32;\\n        if (nodes == 0) {\\n            return _leaf == _root;\\n        }\\n\\n        uint256 _idx = _index;\\n        bytes32 _current = _leaf;\\n\\n        for (uint i = 0; i < nodes; i++) {\\n            bytes32 _next = _proof.index(i * 32, 32);\\n            if (_idx % 2 == 1) {\\n                _current = _merkleStep(_next, _current);\\n            } else {\\n                _current = _merkleStep(_current, _next);\\n            }\\n            _idx >>= 1;\\n        }\\n\\n        return revertBytes32(_current) == _root;\\n    }\\n\\n    function revertBytes32 (bytes32 input) internal returns(bytes32) {\\n        bytes memory temp;\\n        bytes32 result;\\n        for (uint i = 0; i < 32; i++) {\\n            temp = abi.encodePacked(temp, input[31-i]);\\n        }\\n        assembly {\\n            result := mload(add(temp, 32))\\n        }\\n        return result;\\n    }\\n    // @notice                 performs the bitcoin difficulty retarget\\n    // @dev                    implements the Bitcoin algorithm precisely\\n    // @param _previousTarget  the target of the previous period\\n    // @param _firstTimestamp  the timestamp of the first block in the difficulty period\\n    // @param _secondTimestamp the timestamp of the last block in the difficulty period\\n    // @return                 the new period's target threshold\\n    function retargetAlgorithm(\\n        uint256 _previousTarget,\\n        uint256 _firstTimestamp,\\n        uint256 _secondTimestamp\\n    ) internal pure returns (uint256) {\\n        uint256 _elapsedTime = _secondTimestamp.sub(_firstTimestamp);\\n\\n        // Normalize ratio to factor of 4 if very long or very short\\n        if (_elapsedTime < RETARGET_PERIOD.div(4)) {\\n            _elapsedTime = RETARGET_PERIOD.div(4);\\n        }\\n        if (_elapsedTime > RETARGET_PERIOD.mul(4)) {\\n            _elapsedTime = RETARGET_PERIOD.mul(4);\\n        }\\n\\n        /*\\n            NB: high targets e.g. ffff0020 can cause overflows here\\n                so we divide it by 256**2, then multiply by 256**2 later\\n                we know the target is evenly divisible by 256**2, so this isn't an issue\\n        */\\n        uint256 _adjusted = _previousTarget.div(65536).mul(_elapsedTime);\\n        return _adjusted.div(RETARGET_PERIOD).mul(65536);\\n    }\\n}\",\"keccak256\":\"0x8e0dd74955a8b68e55672cd2b42c4eceb5dc363f7d3a9f0ef08dfd89fc9dad1c\"},\"contracts/pools/FastPool.sol\":{\"content\":\"pragma solidity ^0.7.6;\\n\\nimport './interfaces/IFastPool.sol';\\nimport '../libraries/SafeMath.sol';\\nimport '../erc20/ERC20.sol';\\nimport 'hardhat/console.sol';\\n\\ncontract FastPool is IFastPool, ERC20{\\n\\n  using SafeMath for uint256;\\n  address public override wrappedBitcoin;\\n  address public override fastRouter;\\n  mapping (uint=>uint) public override totalRequestedAmount;\\n  mapping (address => uint256) private _balances;\\n  mapping (address => mapping (address => uint256)) private _allowances;\\n  uint256 private _totalSupply;\\n  string private _name;\\n  string private _symbol;\\n  uint public override fastLimit;\\n  uint public override fastFee; // percentage of total amount \\n  uint public override fastConfirmationParameter;\\n  address public override owner;\\n\\n  modifier onlyOwner {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  constructor(\\n    address _wrappedBitcoin,\\n    address _fastRouter,\\n    string memory _name,\\n    string memory _symbol,\\n    uint _fastLimit,\\n    uint _fastFee,\\n    uint _fastConfirmationParameter,\\n    address _owner\\n  ) ERC20(_name, _symbol, 0) public {\\n    wrappedBitcoin = _wrappedBitcoin;\\n    fastRouter = _fastRouter;\\n    fastLimit = _fastLimit;\\n    fastFee = _fastFee;\\n    fastConfirmationParameter = _fastConfirmationParameter;\\n    owner = _owner;\\n  }\\n\\n  function changeOwner(address _owner) external override onlyOwner {\\n    owner = _owner;\\n  }\\n\\n  function setFastRouter(address _fastRouter) external override onlyOwner {\\n    fastRouter = _fastRouter;\\n  }\\n\\n  function setFastLimit(uint _fastLimit) external override onlyOwner {\\n    fastLimit = _fastLimit;\\n  }\\n\\n  function setFastFee(uint _fastFee) external override onlyOwner {\\n    fastFee = _fastFee;\\n  }\\n\\n  function setFastConfirmationParameter(uint _fastConfirmationParameter) external override {\\n    fastConfirmationParameter = _fastConfirmationParameter;\\n  }\\n      \\n  function addLiquidity (address user, uint wrappedBitcoinAmount) public override returns (uint) {\\n    uint liquidity;\\n    uint totalWrappedBitcoin = totalWrappedBitcoin();\\n    if (totalWrappedBitcoin == 0) {\\n      liquidity = wrappedBitcoinAmount;\\n    } else {\\n      liquidity = wrappedBitcoinAmount*_totalSupply/totalWrappedBitcoin;\\n    }\\n    IERC20(wrappedBitcoin).transferFrom(msg.sender, address(this), wrappedBitcoinAmount);\\n    _mint(user, liquidity); // mint fast pool token for user\\n    emit AddLiquidity(user, wrappedBitcoinAmount);\\n    return wrappedBitcoinAmount;\\n  }\\n\\n  function removeLiquidity(address user, uint fastPoolTokenAmount) public override returns(uint){\\n    require(_balances[msg.sender] >= fastPoolTokenAmount, \\\"balance is not sufficient\\\"); // cannot burn more than his fp token balance\\n    uint userShare = (totalWrappedBitcoin()*fastPoolTokenAmount)/_totalSupply;\\n    require(IERC20(wrappedBitcoin).transfer(user, userShare), \\\"balance is not sufficient\\\"); // give msg.sender his share of fees\\n    _burn(msg.sender, fastPoolTokenAmount); \\n    emit RemoveLiquidity(user, userShare); // TODO: is user correct?\\n    return userShare;\\n  }\\n  \\n  function fastTransfer(address user, uint amount, uint blockNumber) override public returns(bool){\\n    require(msg.sender == fastRouter, \\\"sender is not fast router\\\");\\n    require((totalRequestedAmount[blockNumber] + amount) < fastLimit, \\\"fast limit is reached\\\");\\n    require(totalWrappedBitcoin() >= amount, \\\"fast pool does not have enough balance\\\");\\n    uint transferredAmount = amount*(100-fastFee)/100; // get fast fee from user\\n    IERC20(wrappedBitcoin).transfer(user, transferredAmount);\\n    totalRequestedAmount[blockNumber] = totalRequestedAmount[blockNumber] + amount;\\n    emit FastTransfer(user, amount, transferredAmount, blockNumber);\\n    return true;\\n  }\\n  \\n  function totalWrappedBitcoin() override public view returns(uint){\\n    return IERC20(wrappedBitcoin).balanceOf(address(this));\\n  }\\n    \\n}\",\"keccak256\":\"0xb09866c55df2b5bf70f28b14c7c113430ddd4d4d2233caff1c9ff007fe4f79f1\"},\"contracts/pools/InstantPool.sol\":{\"content\":\"pragma solidity ^0.7.6;\\n\\nimport './interfaces/IInstantPool.sol';\\nimport '../libraries/SafeMath.sol';\\nimport '../erc20/ERC20.sol';\\n\\ncontract InstantPool is IInstantPool, ERC20{\\n\\n  using SafeMath for uint256;\\n  address public override wrappedBitcoin;\\n  address public instantRouter;\\n  address public override owner;\\n  mapping (address => uint256) private _balances;\\n  mapping (address => mapping (address => uint256)) private _allowances;\\n  uint256 private _totalSupply;\\n  string private _name;\\n  string private _symbol;\\n  uint public override instantFee; // percentage of total amount \\n\\n  modifier onlyOwner {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  constructor(\\n    address _instantRouter, \\n    address _wrappedBitcoin, \\n    string memory _name, \\n    string memory _symbol,\\n    address _owner,\\n    uint _instantFee\\n  ) ERC20(_name, _symbol, 0) public {\\n    instantRouter = _instantRouter;\\n    wrappedBitcoin = _wrappedBitcoin;\\n    owner = _owner;\\n    instantFee = _instantFee;\\n  }\\n\\n  function changeOwner(address _owner) external override onlyOwner {\\n    owner = _owner;\\n  }\\n\\n  function setInstantRouter(address _instantRouter) external override onlyOwner {\\n    instantRouter = _instantRouter;\\n  }\\n\\n  function setInstantFee (uint _instantFee) external override onlyOwner {\\n    instantFee = _instantFee;\\n  }\\n    \\n  function addLiquidity(address user, uint wrappedBitcoinAmount) external override returns(uint) {\\n    uint liquidity;\\n    uint totalWrappedBitcoin = totalWrappedBitcoin();\\n    if (totalWrappedBitcoin == 0) {\\n      liquidity = wrappedBitcoinAmount;\\n    } else {\\n      liquidity = wrappedBitcoinAmount*_totalSupply/totalWrappedBitcoin;\\n    }\\n    IERC20(wrappedBitcoin).transferFrom(msg.sender, address(this), wrappedBitcoinAmount);\\n    _mint(user, liquidity); // mint instant pool token for user\\n    emit AddLiquidity(user, wrappedBitcoinAmount);\\n    return wrappedBitcoinAmount;\\n  }\\n\\n  function removeLiquidity(address user, uint instantPoolTokenAmount) external override returns(uint){\\n    require(_balances[msg.sender] >= instantPoolTokenAmount, \\\"balance is not sufficient\\\"); // cannot burn more than his ip token balance\\n    uint userShare = (instantPoolTokenAmount*totalWrappedBitcoin())/_totalSupply;\\n    IERC20(wrappedBitcoin).transfer(msg.sender, userShare); // give msg.sender his share of fees\\n    _burn(msg.sender, instantPoolTokenAmount); \\n    emit RemoveLiquidity(msg.sender, userShare);\\n    return userShare;\\n  }\\n  \\n  function instantTransfer(address user, uint amount) override external returns(bool){\\n    require(msg.sender == instantRouter, \\\"sender is not instant router\\\");\\n    uint transferredAmount = amount*(100-instantFee)/100; // get instant fee from user\\n    IERC20(wrappedBitcoin).transfer(user, transferredAmount);\\n    emit InstantTransfer(user, amount, transferredAmount);\\n    return true;\\n  }\\n  \\n  function totalWrappedBitcoin() override public view returns(uint){\\n    return IERC20(wrappedBitcoin).balanceOf(address(this));\\n  }\\n     \\n}\",\"keccak256\":\"0xf30620fef9321a9f2a7967c38002dc721a27b4858cc5364b447b6389d48b1103\"},\"contracts/pools/interfaces/IFastPool.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity ^0.7.6;\\n\\nimport '../../erc20/interfaces/IERC20.sol';\\n\\ninterface IFastPool is IERC20 {\\n  // events\\n  event AddLiquidity(address user, uint wrappedBitcoinAmount); \\n  event RemoveLiquidity(address user, uint256 wrappedBitcoinAmount);\\n  event FastTransfer(address user, uint256 requestedAmount, uint256 transferredAmount, uint blockNumber);\\n\\n  // read-only functions\\n  function owner() external view returns (address);\\n  function wrappedBitcoin() external view returns (address); // gives back the wrapped bitcoin address\\n  function fastRouter() external view returns (address);\\n  function fastFee() external view returns (uint);\\n  function fastLimit() external view returns (uint);\\n  function fastConfirmationParameter() external view returns(uint);\\n  function totalRequestedAmount(uint blockNumber) external view returns(uint);\\n  function totalWrappedBitcoin() external view returns(uint);\\n\\n  // state-changing functions\\n  function changeOwner(address _owner) external;\\n  function setFastRouter(address _fastRouter) external;\\n  function setFastLimit(uint _fastLimit) external;\\n  function setFastFee(uint _fastFee) external;\\n  function setFastConfirmationParameter (uint _fastConfirmationParameter) external;\\n  function addLiquidity(address user, uint wrappedBitcoinAmount) external returns (uint);\\n  function removeLiquidity(address user, uint fastPoolTokenAmount) external returns (uint);\\n  function fastTransfer(address user, uint amount, uint blockNumber) external returns(bool);\\n}\",\"keccak256\":\"0x215efef21f04db1979779766f5046217cb060f64df0e8ead3e27ad920ff8c4a1\"},\"contracts/pools/interfaces/IInstantPool.sol\":{\"content\":\"pragma solidity ^0.7.6;\\n\\nimport '../../erc20/interfaces/IERC20.sol';\\n\\ninterface IInstantPool is IERC20{\\n  // events\\n  event AddLiquidity(address user, uint wrappedBitcoinAmount); \\n  event RemoveLiquidity(address user, uint wrappedBitcoinAmount);\\n  event InstantTransfer(address user, uint256 requestedAmount, uint transferredAmount);\\n\\n  // read-only functions\\n  function owner() external view returns (address);\\n  function wrappedBitcoin() external view returns (address);\\n  function totalWrappedBitcoin() external view returns(uint);\\n  function instantFee() external view returns(uint);\\n  \\n  // state-changing fucntions\\n  function changeOwner(address _owner) external;\\n  function setInstantRouter(address _instantRouter) external;\\n  function setInstantFee(uint _instantFee) external;\\n  function addLiquidity(address user, uint wrappedBitcoinAmount) external returns(uint);\\n  function removeLiquidity(address user, uint instantPoolTokenAmount) external returns (uint);\\n  function instantTransfer(address user, uint amount) external returns(bool);\\n}\",\"keccak256\":\"0xc2b97f8754264233288acaf27f9a5734be9f134d02b307a5496b6358cbdcec63\"},\"contracts/pools/interfaces/ILiquidityPool.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\nimport '../../erc20/interfaces/IERC20.sol';\\n\\ninterface ILiquidityPool is IERC20 {\\n    // events\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n    // read-only functions\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n    // state-changing functions\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n    // function initialize(address, address) external;\\n}\\n\",\"keccak256\":\"0x38d1961bb850ffcc3bccd3de2803e231b1b3fd5bbea9b85875dd005afc600181\"},\"contracts/pools/interfaces/ILiquidityPoolFactory.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\ninterface ILiquidityPoolFactory {\\n    // events\\n    event LiquidityPoolCreated(address indexed token0, address indexed token1, address pair, uint liquidityPoolsLength);\\n\\n    // read-only functions\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function getLiquidityPool(address tokenA, address tokenB) external view returns (address pair);\\n    function allLiquidityPools(uint number) external view returns (address pair);\\n    function allLiquidityPoolsLength() external view returns (uint);\\n\\n    // state-changing functions\\n    function createLiquidityPool(address tokenA, address tokenB) external returns (address pair);\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\",\"keccak256\":\"0x11e8a406afd3e558ca821261ed8ab8745c595f948353cf71af72b85f8f880d6e\"},\"contracts/relay/interfaces/IBitcoinRelay.sol\":{\"content\":\"pragma solidity 0.7.6;\\n\\ninterface IBitcoinRelay {\\n    // structures\\n    struct blockHeader{\\n        bytes32 selfHash;\\n\\t\\tbytes32 parentHash;\\n\\t\\tbytes32 merkleRoot;\\n    }\\n\\n    // events\\n    event BlockAdded(uint256 firstHeight, uint256 lastHeight, address relayer, uint rewardAmount, bool isTDT);\\n    event NewTip(bytes32 indexed _from, bytes32 indexed _to, bytes32 indexed _gcd);\\n\\n    // read-only functions\\n    function owner() external view returns (address);\\n    function getCurrentEpochDifficulty() external view returns (uint256);\\n    function getPrevEpochDifficulty() external view returns (uint256);\\n    function getRelayGenesis() external view returns (bytes32);\\n    function getBestKnownDigest() external view returns (bytes32);\\n    function getLastReorgCommonAncestor() external view returns (bytes32);\\n    function initialHeight() external view returns(uint);\\n    function lastSubmittedHeight() external view returns(uint);\\n    function finalizationParameter() external view returns(uint);\\n    function TeleportDAOToken() external view returns(address);\\n\\tfunction feeRatio() external view returns(uint);\\n\\tfunction epochLength() external view returns(uint);\\n\\tfunction lastEpochQueries() external view returns(uint);\\n\\tfunction baseQueries() external view returns(uint);\\n\\tfunction submissionGasUsed() external view returns(uint);\\n\\t// function chain(uint) external returns(blockHeader[] memory);\\n\\tfunction getBlockHeaderHash (uint height, uint index) external returns(bytes32);\\n\\tfunction getNumberOfSubmittedHeaders (uint height) external view returns (uint);\\n\\t// function availableTDT() external view returns(uint);\\n    // function availableTNT() external view returns(uint);\\n\\tfunction lastBuyBack() external view returns(uint);\\n\\tfunction buyBackPeriod() external view returns(uint);\\n\\tfunction exchangeRouter() external view returns(address);\\n\\tfunction WAVAX() external view returns(address);\\n    function findHeight(bytes32 _digest) external view returns (uint256);\\n    function findAncestor(bytes32 _digest, uint256 _offset) external view returns (bytes32);\\n    function isAncestor(bytes32 _ancestor, bytes32 _descendant, uint256 _limit) external view returns (bool);\\n\\n    // state-changing functions\\n    function changeOwner(address _owner) external;\\n    function setFinalizationParameter(uint _finalizationParameter) external;\\n    function setFeeRatio(uint _feeRatio) external;\\n    function setEpochLength(uint _epochLength) external;\\n    function setBuyBackPeriod(uint _buyBackPeriod) external;\\n    function setBaseQueries(uint _baseQueries) external;\\n    function setSubmissionGasUsed(uint _submissionGasUsed) external;\\n    function setExchangeRouter(address _exchangeRouter) external;\\n    function checkTxProof(\\n        bytes32 txid,\\n        uint blockHeight,\\n        bytes calldata intermediateNodes,\\n        uint index,\\n        bool payWithTDT,\\n        uint neededConfirmations\\n    ) external returns (bool);\\n    function addHeaders(bytes calldata _anchor, bytes calldata _headers) external returns (bool);\\n    function addHeadersWithRetarget(\\n        bytes calldata _oldPeriodStartHeader,\\n        bytes calldata _oldPeriodEndHeader,\\n        bytes calldata _headers\\n    ) external returns (bool);\\n    function markNewHeaviest(\\n        bytes32 _ancestor,\\n        bytes calldata _currentBest,\\n        bytes calldata _newBest,\\n        uint256 _limit\\n    ) external returns (bool);\\n    function calculateTxId (\\n        bytes4 _version,\\n        bytes memory _vin,\\n        bytes memory _vout,\\n        bytes4 _locktime\\n    ) external returns(bytes32);\\n\\n}\",\"keccak256\":\"0x3b8ad1a1ea89e7fb16e802ad6afb59bbca9bd991242aeb8385c09dad77563851\"},\"contracts/routers/CCTransferRouter.sol\":{\"content\":\"pragma solidity ^0.7.6;\\n\\nimport \\\"../libraries/SafeMath.sol\\\";\\nimport \\\"../libraries/BitcoinTxParser.sol\\\";\\nimport \\\"./interfaces/ICCTransferRouter.sol\\\";\\nimport \\\"./interfaces/ICCExchangeRouter.sol\\\";\\nimport \\\"../erc20/interfaces/IWrappedToken.sol\\\";\\nimport \\\"../relay/interfaces/IBitcoinRelay.sol\\\";\\nimport \\\"../teleporter/interfaces/IBitcoinTeleporter.sol\\\";\\nimport \\\"./interfaces/IInstantRouter.sol\\\";\\nimport \\\"./interfaces/IFastRouter.sol\\\";\\nimport \\\"./InstantRouter.sol\\\";\\nimport \\\"./FastRouter.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract CCTransferRouter is ICCTransferRouter {\\n    using SafeMath for uint256;\\n    address public bitcoinRelay;\\n    address public bitcoinTeleporter;\\n    mapping(bytes32 => wrapRequest) public wrapRequests;\\n    address public ccExchangeRouter;\\n    address public instantRouter;\\n    address public fastRouter;\\n    address public override wrappedBitcoin;\\n    address public override bitcoinFastPool;\\n    address public bitcoinInstantPool;\\n    uint public override normalConfirmationParameter;\\n    address public override owner;\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    constructor(\\n        address _bitcoinRelay,\\n        address _bitcoinTeleporter, \\n        uint _normalConfirmationParameter\\n    ) public {\\n        bitcoinRelay = _bitcoinRelay;\\n        bitcoinTeleporter = _bitcoinTeleporter;\\n        normalConfirmationParameter = _normalConfirmationParameter;\\n        owner = msg.sender;\\n    }\\n\\n    function changeOwner(address _owner) external override onlyOwner {\\n        owner = _owner;\\n    }\\n\\n    function setNormalConfirmationParameter(uint _normalConfirmationParameter) external override onlyOwner {\\n        normalConfirmationParameter = _normalConfirmationParameter;\\n    }\\n\\n    function setBitcoinRelay(address _bitcoinRelay) external override onlyOwner {\\n        bitcoinRelay = _bitcoinRelay;\\n    }\\n    \\n    function setFastRouter(address _fastRouter) external override onlyOwner {\\n        fastRouter = _fastRouter;\\n        bitcoinFastPool = IFastRouter(fastRouter).bitcoinFastPool();\\n    }\\n\\n    function setInstantRouter(address _instantRouter) external override onlyOwner {\\n        instantRouter = _instantRouter;\\n        bitcoinInstantPool = IInstantRouter(instantRouter).bitcoinInstantPool();\\n    }\\n\\n    function setCCExchangeRouter(address _ccExchangeRouter) external override onlyOwner {\\n        ccExchangeRouter = _ccExchangeRouter;\\n        // ICCExchangeRouter(ccExchangeRouter).setInstantRouter(instantRouter);\\n    }\\n\\n    function setWrappedBitcoin(address _wrappedBitcoin) external override onlyOwner returns (bool) {\\n        wrappedBitcoin = _wrappedBitcoin;\\n        return true;\\n    }\\n    // TODO: add burn with permit\\n    // TODO: handle fast transactions that are not executed because the fast limit was reached (they can mint token after finalization)\\n    function ccTransfer(\\n        bytes4 version,\\n        bytes memory vin,\\n        bytes calldata vout,\\n        bytes4 locktime,\\n        uint256 blockNumber,\\n        bytes calldata intermediateNodes,\\n        uint index,\\n        bool payWithTDT\\n    ) external override returns (bool) {\\n        bytes32 txId = calculateTxId(version, vin, vout, locktime);\\n        txId = revertBytes32(txId);\\n        require(\\n            !wrapRequests[txId].isUsed,\\n            \\\"Request has been used before\\\"\\n        );\\n        saveWrapRequest(vout, blockNumber, intermediateNodes, index, txId);\\n\\n        if (wrapRequests[txId].speed == 0) {\\n            // check that the block has received enough confirmations\\n            require(\\n                isConfirmed(\\n                    txId,\\n                    blockNumber,\\n                    intermediateNodes,\\n                    index,\\n                    payWithTDT,\\n                    normalConfirmationParameter\\n                ),\\n                \\\"Transaction has not finalized\\\"\\n            );\\n            require(normalCCTransfer(txId), \\\"normal cc transfer was not successful\\\");\\n            emit CCTransfer(\\n                wrapRequests[txId].recipientAddress, \\n                wrappedBitcoin, \\n                wrapRequests[txId].bitcoinAmount, \\n                wrapRequests[txId].speed\\n            );\\n            return true;\\n        }\\n\\n        if (wrapRequests[txId].speed == 1) {\\n            // if transaction has been already finalized, there is no need to borrow wrapped token from fast pool\\n            if (isConfirmed(txId, blockNumber, intermediateNodes, index, payWithTDT, normalConfirmationParameter) == true) {\\n                require(normalCCTransfer(txId), \\\"fast cc transfer was not successful\\\");\\n                wrapRequests[txId].isMinted = true; // wrapped token is minted\\n                emit CCTransfer(\\n                    wrapRequests[txId].recipientAddress, \\n                    wrappedBitcoin, \\n                    wrapRequests[txId].bitcoinAmount, \\n                    0 // the token is wrapped normally\\n                );\\n            } else {            \\n                // check that the block has received enough confirmations\\n                require(\\n                    isConfirmed(\\n                        txId,\\n                        blockNumber,\\n                        intermediateNodes,\\n                        index,\\n                        payWithTDT,\\n                        getFastNeededConfirmations()\\n                    ),\\n                    \\\"Transaction has not received enough confirmations\\\"\\n                );\\n                require(fastCCTransfer(txId), \\\"fast cc transfer was not successful\\\");\\n                emit CCTransfer(\\n                    wrapRequests[txId].recipientAddress, \\n                    wrappedBitcoin, \\n                    wrapRequests[txId].bitcoinAmount, \\n                    wrapRequests[txId].speed\\n                );\\n            }\\n            return true;\\n        }\\n\\n        if (wrapRequests[txId].speed == 2) { // pay back instant loan\\n            // check that the block has received enough confirmations\\n            require(\\n                isConfirmed(\\n                    txId,\\n                    blockNumber,\\n                    intermediateNodes,\\n                    index,\\n                    payWithTDT,\\n                    normalConfirmationParameter\\n                ),\\n                \\\"Transaction has not finalized\\\"\\n            );\\n            require(instantCCTransfer(txId), \\\"instant cc transfer was not successful\\\");\\n            return true;\\n        }\\n    }\\n\\n    function normalCCTransfer (bytes32 txId) internal returns(bool) {\\n\\n        if (wrapRequests[txId].isExchange == true) {\\n            // require(msg.sender == ccExchangeRouter, \\\"message sender is not cc exchange router\\\");\\n            if (msg.sender == ccExchangeRouter) {\\n                IWrappedToken(wrappedBitcoin).mint(ccExchangeRouter, wrapRequests[txId].bitcoinAmount);\\n                return true;\\n            }\\n\\n            if (msg.sender != ccExchangeRouter) { \\n                // handle unpredicted cases that exchange request execution was not succesful, so we want to mint wrapped token for user\\n                // wrapped token can only be mint after passing of deadline\\n                require(wrapRequests[txId].deadline < block.number, \\\"deadline has not passed yet\\\");\\n                require(\\n                    wrapRequests[txId].teleporterFee <= wrapRequests[txId].bitcoinAmount,\\n                    \\\"teleporter fee is too much\\\"\\n                );\\n                if (wrapRequests[txId].teleporterFee > 0) {\\n                    IWrappedToken(wrappedBitcoin).mint(msg.sender, wrapRequests[txId].teleporterFee);\\n                }\\n                IWrappedToken(wrappedBitcoin).mint(\\n                    wrapRequests[txId].recipientAddress,\\n                    wrapRequests[txId].bitcoinAmount.sub(wrapRequests[txId].teleporterFee)\\n                );\\n                return true;    \\n            }   \\n        } \\n\\n        if (wrapRequests[txId].isExchange == false) {\\n            require(\\n                wrapRequests[txId].teleporterFee < wrapRequests[txId].bitcoinAmount,\\n                \\\"teleporter fee is too much\\\"\\n            );\\n            if (wrapRequests[txId].teleporterFee > 0) {\\n                IWrappedToken(wrappedBitcoin).mint(msg.sender, wrapRequests[txId].teleporterFee);\\n            }\\n            IWrappedToken(wrappedBitcoin).mint(\\n                wrapRequests[txId].recipientAddress,\\n                wrapRequests[txId].bitcoinAmount.sub(wrapRequests[txId].teleporterFee)\\n            );\\n            return true; \\n        }\\n    }\\n\\n    function fastCCTransfer (bytes32 txId) internal returns(bool) {\\n        // determine transer recipient\\n        if (wrapRequests[txId].isExchange == true) {\\n            if (msg.sender == ccExchangeRouter) {\\n                // borrow wrapped token from fast pool and transfer it to cc exchnage router\\n                require(\\n                    fastTransfer(ccExchangeRouter, wrapRequests[txId].bitcoinAmount, wrapRequests[txId].blockNumber),\\n                    \\\"fast transfer was failed\\\"\\n                );\\n                return true;\\n            }\\n            if (msg.sender != ccExchangeRouter) {\\n                // TODO\\n                return true;\\n            }\\n        }\\n\\n        if (wrapRequests[txId].isExchange == false) {\\n            // TODO: handle failed fast transfer request (because the fast limit was reached)\\n            if (wrapRequests[txId].teleporterFee > 0) {\\n                // pay half of the teleporter fee now and rest of it after finalization\\n                require(\\n                    fastTransfer(\\n                        msg.sender,\\n                        wrapRequests[txId].teleporterFee/2,\\n                        wrapRequests[txId].blockNumber\\n                    ),\\n                \\\"fast transfer to teleporter was failed\\\"\\n                );\\n            }\\n            require(\\n                fastTransfer(\\n                    wrapRequests[txId].recipientAddress,\\n                    wrapRequests[txId].bitcoinAmount - wrapRequests[txId].teleporterFee,\\n                    wrapRequests[txId].blockNumber\\n                ),\\n                \\\"fast transfer to user was failed\\\"\\n            );\\n            return true;\\n        }\\n    }\\n\\n    function instantCCTransfer (bytes32 txId) internal returns(bool) {\\n\\n        require(\\n            wrapRequests[txId].teleporterFee < wrapRequests[txId].bitcoinAmount,\\n            \\\"teleporter fee is too much\\\"\\n        );\\n        if (wrapRequests[txId].teleporterFee > 0) {\\n            IWrappedToken(wrappedBitcoin).mint(msg.sender, wrapRequests[txId].teleporterFee);\\n        }\\n        // mint wrapped token for cc transfer router\\n        IWrappedToken(wrappedBitcoin).mint(\\n            address(this),\\n            wrapRequests[txId].bitcoinAmount.sub(wrapRequests[txId].teleporterFee)\\n        );\\n        // give allowance to instant pool to transfer mint wrapped tokens\\n        IWrappedToken(wrappedBitcoin).approve(\\n            instantRouter,\\n            wrapRequests[txId].bitcoinAmount.sub(wrapRequests[txId].teleporterFee)\\n        );\\n        // user wants to pay back the borrowed asset\\n        bool paybackResult = IInstantRouter(instantRouter).payBackInstantTransfer(\\n            wrapRequests[txId].bitcoinAmount.sub(wrapRequests[txId].teleporterFee),\\n            wrapRequests[txId].recipientAddress\\n        );\\n        return true;\\n    }\\n\\n    function instantCCTransferWithPermit(\\n        address signer,\\n        bytes memory signature,\\n        address receiver, \\n        uint instantTokenAmount,\\n        uint deadline\\n    ) public override returns(bool) {\\n        IInstantRouter(instantRouter).instantCCTransferWithPermit(\\n            signer, \\n            signature, \\n            receiver, \\n            instantTokenAmount, \\n            deadline\\n        );\\n        emit CCTransfer(\\n            receiver, \\n            wrappedBitcoin, \\n            instantTokenAmount, \\n            2 // 2 means fast\\n        );\\n        return true;\\n    }\\n\\n    function calculateTxId (\\n        bytes4 _version,\\n        bytes memory _vin,\\n        bytes calldata _vout,\\n        bytes4 _locktime\\n    ) internal returns(bytes32) {\\n        bytes32 inputHash1 = sha256(abi.encodePacked(_version, _vin, _vout, _locktime));\\n        bytes32 inputHash2 = sha256(abi.encodePacked(inputHash1));\\n        return inputHash2;\\n    }\\n\\n    function fastTransfer(\\n        address _recipient,\\n        uint amount,\\n        uint blockNumber\\n    ) internal returns (bool) {\\n        return\\n            IFastRouter(fastRouter).fastTransfer(\\n                _recipient,\\n                amount,\\n                blockNumber\\n            );\\n    }\\n\\n    function mintAfterFinalization(bytes32 txId) public override returns (bool) {\\n        wrapRequest memory request;\\n        request = wrapRequests[txId];\\n        require(request.isUsed == true, \\\"The reuqest has not been submitted before\\\");\\n        require(request.isMinted == false, \\\"The reuqest has been minted before\\\");\\n        // only mint wrapped token after finalization\\n        require(\\n            isConfirmed(\\n                txId,\\n                request.blockNumber,\\n                request.intermediateNodes,\\n                request.index,\\n                true, // TODO: replace it\\n                normalConfirmationParameter\\n            ),\\n            \\\"Transaction has not been finalized\\\"\\n        );\\n        wrapRequests[txId].isMinted = true;\\n\\n        IWrappedToken(wrappedBitcoin).mint(\\n            bitcoinFastPool, \\n            wrapRequests[txId].bitcoinAmount - wrapRequests[txId].teleporterFee/2\\n        ); // mint for the bitcoin fast pool\\n        IWrappedToken(wrappedBitcoin).mint(msg.sender, wrapRequests[txId].teleporterFee/2); // mint for the teleporter\\n        emit PaybackFastLoan(\\n            wrapRequests[txId].recipientAddress, \\n            wrapRequests[txId].bitcoinAmount - wrapRequests[txId].teleporterFee/2\\n        );\\n        return true;\\n    }\\n\\n    function saveWrapRequest(\\n        bytes memory vout,\\n        uint blockNumber,\\n        bytes memory intermediateNodes,\\n        uint index,\\n        bytes32 txId\\n    ) internal {\\n        bytes memory arbitraryData;\\n        wrapRequest memory request;\\n        address desiredRecipient;\\n        desiredRecipient = IBitcoinTeleporter(bitcoinTeleporter).redeemScriptHash();\\n        (request.bitcoinAmount, arbitraryData) = BitcoinTxParser.parseAmountForP2SH(vout, desiredRecipient);\\n        request.recipientAddress = BitcoinTxParser.parseRecipientAddress(arbitraryData);\\n        request.teleporterFee = BitcoinTxParser.parseTeleporterFee(arbitraryData);\\n        request.isExchange = BitcoinTxParser.parseIsExchange(arbitraryData);\\n        request.speed = BitcoinTxParser.parseSpeed(arbitraryData);\\n        request.deadline = BitcoinTxParser.parseDeadline(arbitraryData);\\n        if (request.speed == 1) {\\n            // ~ if it is a fast request\\n            request.blockNumber = blockNumber;\\n            request.intermediateNodes = intermediateNodes;\\n            request.index = index;\\n        }\\n        if (request.speed == 2) {\\n            // ~ if it is an instant request\\n            request.exchangeToken = BitcoinTxParser.parseExchangeToken(arbitraryData);\\n            request.exchangeAmount = BitcoinTxParser.parseExchangeAmount(arbitraryData);\\n        }\\n        request.isUsed = true;\\n        wrapRequests[txId] = request;\\n    }\\n\\n    function getFastNeededConfirmations() internal view returns(uint) {\\n        return IFastRouter(fastRouter).getNeededConfirmations();\\n    }\\n    \\n    function isConfirmed(\\n        bytes32 txId,\\n        uint256 blockNumber,\\n        bytes memory intermediateNodes,\\n        uint index,\\n        bool payWithTDT,\\n        uint neededConfirmations\\n    ) internal returns (bool) {\\n        // TODO: uncomment it\\n        // uint feeAmount;\\n        // IERC20(feeTokenAddress).transferFrom(msg.sender, address(this), feeAmount);\\n        return IBitcoinRelay(bitcoinRelay).checkTxProof(\\n                txId,\\n                blockNumber,\\n                intermediateNodes,\\n                index,\\n                payWithTDT,\\n                neededConfirmations\\n            );\\n    }\\n\\n    function isRequestUsed(bytes32 txId) external view override returns(bool) {\\n        if (wrapRequests[txId].isUsed == true) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function isRequestMinted(bytes32 txId) external view override returns(bool) {\\n        if (wrapRequests[txId].isMinted == true) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function revertBytes32 (bytes32 input) internal returns(bytes32) {\\n        bytes memory temp;\\n        bytes32 result;\\n        for (uint i = 0; i < 32; i++) {\\n            temp = abi.encodePacked(temp, input[31-i]);\\n        }\\n        assembly {\\n            result := mload(add(temp, 32))\\n        }\\n        return result;\\n    }\\n}\",\"keccak256\":\"0x369b95d79f3247929d9ae303656c4f9200a69dc51441b4de1cf6cd4494a51d19\"},\"contracts/routers/FastRouter.sol\":{\"content\":\"pragma solidity 0.7.6;\\n\\nimport '../erc20/interfaces/IERC20.sol';\\nimport './interfaces/IFastRouter.sol';\\nimport '../pools/FastPool.sol';\\nimport '../pools/interfaces/IFastPool.sol';\\nimport './interfaces/ICCTransferRouter.sol';\\nimport '../libraries/SafeMath.sol';\\n\\ncontract FastRouter is IFastRouter {\\n    \\n    using SafeMath for uint;\\n    address public override bitcoinFastPool;\\n    address public override ccTransferRouter;\\n    address public wrappedBitcoin;\\n    address public override owner;\\n    \\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    constructor (address _ccTransferRouter, uint _fastLimit, uint _fastFee, uint _neededConfirmations) public {\\n        ccTransferRouter = _ccTransferRouter;\\n        wrappedBitcoin = ICCTransferRouter(ccTransferRouter).wrappedBitcoin();\\n        FastPool _bitcoinFastPool;\\n        _bitcoinFastPool = new FastPool(\\n            wrappedBitcoin, \\n            address(this), \\n            \\\"BitcoinFastPoolToken\\\", \\n            \\\"BTCFPT\\\", \\n            _fastLimit, \\n            _fastFee, \\n            _neededConfirmations,\\n            msg.sender\\n        );\\n        bitcoinFastPool = address(_bitcoinFastPool);\\n        owner = msg.sender;\\n    }\\n    \\n    function changeOwner(address _owner) external override onlyOwner {\\n        owner = _owner;\\n    }\\n\\n    function setCCTransferRouter(address _ccTransferRouter) external override onlyOwner {\\n        ccTransferRouter = _ccTransferRouter;\\n    }\\n    // it is called by cc transfer router\\n    function fastTransfer(address receiver, uint amount, uint blockNumber) external override returns(bool){\\n        require(msg.sender == ccTransferRouter, \\\"message sender was not cc transfer router\\\");\\n        require(IFastPool(bitcoinFastPool).fastTransfer(\\n                receiver,\\n                amount,\\n                blockNumber),\\n            \\\"transfer was not succesfull\\\"\\n        ); // transfer bitcoin to user\\n        return true;\\n    }\\n\\n    function getNeededConfirmations() public view override returns(uint) {\\n        return IFastPool(bitcoinFastPool).fastConfirmationParameter();\\n    }\\n    \\n    function addLiquidity(address user, uint wrappedBitcoinAmount) external override returns(uint){\\n        require(IERC20(wrappedBitcoin).transferFrom(\\n            msg.sender, address(this), \\n            wrappedBitcoinAmount), \\n            \\\"user balance is not sufficient\\\"\\n        );\\n        require(IERC20(wrappedBitcoin).approve(\\n            bitcoinFastPool, \\n            wrappedBitcoinAmount), \\n            \\\"fast router balance is not sufficient\\\"\\n        );\\n        return IFastPool(bitcoinFastPool).addLiquidity(user, wrappedBitcoinAmount);\\n    }\\n\\n    function removeLiquidity(address user, uint fastPoolTokenAmount) external override returns(uint) {\\n        require(IFastPool(bitcoinFastPool).transferFrom(\\n            msg.sender, address(this), \\n            fastPoolTokenAmount), \\n            \\\"user balance is not sufficient\\\"\\n        );\\n        return IFastPool(bitcoinFastPool).removeLiquidity(user, fastPoolTokenAmount);\\n    }\\n\\n}\\n\",\"keccak256\":\"0xd3aa2fd8224b899e457c0a20a17da64c1c8cdbdf3aa7920e5320f18c43eaa129\"},\"contracts/routers/InstantRouter.sol\":{\"content\":\"pragma solidity 0.7.6;\\n\\n\\nimport '../libraries/TeleportDAOLibrary.sol';\\nimport '../libraries/SafeMath.sol';\\nimport './interfaces/IInstantRouter.sol';\\nimport './interfaces/IExchangeRouter.sol';\\nimport './interfaces/ICCTransferRouter.sol';\\nimport '../pools/interfaces/IInstantPool.sol';\\nimport '../erc20/interfaces/IERC20.sol';\\nimport '../pools/interfaces/IInstantPool.sol';\\nimport '../pools/InstantPool.sol';\\nimport '../staking/interfaces/IStaking.sol';\\nimport \\\"../relay/interfaces/IBitcoinRelay.sol\\\";\\nimport 'hardhat/console.sol';\\n\\ncontract InstantRouter is IInstantRouter {\\n    \\n    using SafeMath for uint;\\n    // mapping(address => uint) override public lockedTDT;\\n    mapping(bytes32 => InstantTransferRequest) public requests;\\n    mapping(bytes32 => bool) public isUsed;\\n    mapping(address => debt[]) public debts;\\n    uint punisherReward;\\n    uint override public paybackDeadline; // this is the deadline for paying back the borrowed amount \\n    address public liquidityPoolFactory;\\n    address public override wrappedBitcoin;\\n    address public override ccTransferRouter;\\n    address public override bitcoinInstantPool;\\n    address public TeleportDAOToken;\\n    address public WAVAX;\\n    address public exchangeRouter;\\n    address public staking;\\n    address public bitcoinRelay;\\n    uint public override collateralRatio; // multplied by 100\\n    address public override owner; \\n    \\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    constructor (\\n        address _ccTransferRouter,\\n        address _exchangeRouter,\\n        address _TeleportDAOToken, \\n        address _liquidityPoolFactory, \\n        address _staking,\\n        address _bitcoinRelay,\\n        uint _punisherReward,\\n        uint _paybackDeadline,\\n        uint _collateralRatio,\\n        uint _instantFee\\n    ) public {\\n        ccTransferRouter = _ccTransferRouter;\\n        wrappedBitcoin = ICCTransferRouter(ccTransferRouter).wrappedBitcoin();\\n        exchangeRouter = _exchangeRouter;\\n        WAVAX = IExchangeRouter(exchangeRouter).WAVAX();\\n        TeleportDAOToken = _TeleportDAOToken;\\n        staking = _staking;\\n        bitcoinRelay = _bitcoinRelay;\\n        punisherReward = _punisherReward;\\n        liquidityPoolFactory = _liquidityPoolFactory;\\n        paybackDeadline = _paybackDeadline;\\n        collateralRatio = _collateralRatio;\\n        InstantPool _bitcoinInstantPool;\\n        _bitcoinInstantPool = new InstantPool(\\n            address(this), \\n            wrappedBitcoin, \\n            \\\"BitcoinInstantPoolToken\\\", \\n            \\\"BIPT\\\", \\n            msg.sender, \\n            _instantFee\\n        );\\n        bitcoinInstantPool = address(_bitcoinInstantPool);\\n        owner = msg.sender;\\n    }\\n\\n    function changeOwner(address _owner) external override onlyOwner {\\n        owner = _owner;\\n    }\\n    \\n    function setExchangeRouter (address _exchangeRouter) external override onlyOwner {\\n        exchangeRouter = _exchangeRouter;\\n        WAVAX = IExchangeRouter(exchangeRouter).WAVAX();\\n    }\\n\\n    function setCCTransferRouter (address _ccTransferRouter) external override onlyOwner {\\n        ccTransferRouter = _ccTransferRouter;\\n    }\\n\\n    function setPaybackDeadline (uint _paybackDeadline) external override onlyOwner {\\n        paybackDeadline = _paybackDeadline;\\n    }\\n\\n    function setPunisherReward (uint _punisherReward) external override onlyOwner {\\n        punisherReward = _punisherReward;\\n    }\\n\\n    function setCollateralRatio (uint _paybackDeadline) external override onlyOwner {\\n        paybackDeadline = _paybackDeadline;\\n    }\\n\\n    function requestCollateralAmount (bytes32 messageHash) public view override returns(uint) {\\n        return requests[messageHash].collateralAmount;\\n    }\\n\\n    function addLiquidity(address user, uint wrappedBitcoinAmount) public override returns(uint) {\\n        IERC20(wrappedBitcoin).transferFrom(msg.sender, address(this), wrappedBitcoinAmount);\\n        // InstantRouter allows instantPool to transfer from it \\n        IERC20(wrappedBitcoin).approve(bitcoinInstantPool, wrappedBitcoinAmount);\\n        return IInstantPool(bitcoinInstantPool).addLiquidity(user, wrappedBitcoinAmount);\\n    }\\n\\n    function removeLiquidity(address user, uint instantPoolTokenAmount) public override returns(uint) {\\n        uint ipBalance = IInstantPool(bitcoinInstantPool).balanceOf(msg.sender);\\n        require(ipBalance >= instantPoolTokenAmount, \\\"instant pool token is not enough\\\");\\n        // send ipToken to InstantRouter\\n        IInstantPool(bitcoinInstantPool).transferFrom(msg.sender, address(this), instantPoolTokenAmount);\\n        // remove liquidity from instant pool\\n        return IInstantPool(bitcoinInstantPool).removeLiquidity(user, instantPoolTokenAmount); \\n    }\\n\\n    function _instantTransfer (\\n        address user, \\n        address receiver, \\n        uint amount, \\n        uint deadline,\\n        bytes32 messageHash\\n    ) internal returns(bool) {\\n        require(deadline >= block.number, \\\"deadline has passed\\\");\\n        uint _requiredTDT = requiredTDT(amount)*(collateralRatio/100);\\n        uint requiredStakingShare = IStaking(staking).equivalentStakingShare(_requiredTDT);\\n        uint userStakingShare = IStaking(staking).stakingShare(user);\\n        require(userStakingShare >= requiredStakingShare,\\\"TDT staked amount is not sufficient\\\");\\n        IStaking(staking).unstake(user, requiredStakingShare);\\n        // transfer wrappedBitcoin to user \\n        require(\\n            IInstantPool(bitcoinInstantPool).instantTransfer(receiver, amount), \\n            \\\"transfer was not succesfull\\\"\\n        ); \\n        debt memory _debt;\\n        _debt.user = user;\\n        _debt.wrappedBitcoinAmount = amount;\\n        _debt.collateralAmount = _requiredTDT;\\n        _debt.deadline = IBitcoinRelay(bitcoinRelay).lastSubmittedHeight() + paybackDeadline;\\n        debts[user].push(_debt);\\n        isUsed[messageHash] = true;\\n\\n    }\\n\\n    function _instantExchange (\\n        address user, \\n        address receiver, \\n        uint amountIn, \\n        uint amountOutMin,\\n        address[] memory path,\\n        uint deadline,\\n        bytes32 messageHash\\n    ) internal returns(uint[] memory amounts, bool result) {\\n        require(deadline >= block.number, \\\"deadline has passed\\\");\\n        // check that path[0] is wrapped bitcoin\\n        require(path[0] == wrappedBitcoin, \\\"input token is not correct\\\");\\n        // check that the signer has locked enough TDT\\n        uint _requiredTDT = requiredTDT(amountIn)*(collateralRatio/100);\\n        uint requiredStakingShare = IStaking(staking).equivalentStakingShare(_requiredTDT);\\n        require(IStaking(staking).stakingShare(user) >= requiredStakingShare,\\\"TDT staked amount is not sufficient\\\");\\n        IStaking(staking).unstake(user, requiredStakingShare);\\n        // transfer wrappedBitcoin to the instant router\\n        require(\\n            IInstantPool(bitcoinInstantPool).instantTransfer(address(this), amountIn), \\n            \\\"transfer was not succesfull\\\"\\n        ); \\n        debt memory _debt;\\n        _debt.user = user;\\n        _debt.wrappedBitcoinAmount = amountIn;\\n        _debt.collateralAmount = _requiredTDT;\\n        _debt.deadline = IBitcoinRelay(bitcoinRelay).lastSubmittedHeight() + paybackDeadline;\\n        debts[user].push(_debt);\\n        isUsed[messageHash] = true;\\n        // reduce the instant fee from amountIn\\n        amountIn = amountIn*(100-InstantPool(bitcoinInstantPool).instantFee())/100;\\n        // give allowance to exchangeRouter\\n        IERC20(path[0]).approve(exchangeRouter, amountIn);\\n        // call exchangeRouter\\n        if (path[path.length-1] == WAVAX) {\\n            (amounts, result) = IExchangeRouter(exchangeRouter).swapExactTokensForAVAX(\\n                amountIn,\\n                amountOutMin,\\n                path,\\n                receiver,\\n                deadline\\n            );\\n        } else {\\n            (amounts, result) = IExchangeRouter(exchangeRouter).swapExactTokensForTokens(\\n                amountIn,\\n                amountOutMin,\\n                path,\\n                receiver,\\n                deadline\\n            );\\n        }\\n\\n    }\\n    \\n    function instantCCTransfer (address receiver, uint amount, uint deadline) public override returns (bool) {\\n        bytes32 messageHash = keccak256(abi.encodePacked(msg.sender, amount, deadline));\\n        _instantTransfer(msg.sender, receiver, amount, deadline, messageHash);\\n    }\\n\\n    // TODO: give time to user to pay back the instant transfer based on the last finalized block header of the relay\\n    // user signs the request using the target blockchain wallet\\n    function instantCCTransferWithPermit (\\n        address signer,\\n        bytes memory signature,\\n        address receiver, \\n        uint amount,\\n        uint deadline\\n    ) public override returns(bool) {\\n        bytes32 messageHash = keccak256(abi.encodePacked(signer, amount, deadline));\\n        // require(requests[messageHash].isUsed == false, \\\"request has been executed before\\\");\\n        require(isUsed[messageHash] == false, \\\"request has been executed before\\\");\\n        require(\\n            verifySignature(signer, signature, messageHash),\\n            \\\"signature is not valid\\\"\\n        );\\n        _instantTransfer(signer, receiver, amount, deadline, messageHash);\\n    }\\n\\n    function instantCCExchange (\\n        uint amountIn, \\n        uint amountOutMin, \\n        address[] memory path, \\n        address receiver, \\n        uint deadline\\n    ) public override returns(uint[] memory amounts, bool result) {\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(amountIn, amountOutMin, path[path.length-1], msg.sender, deadline)\\n        );\\n        return _instantExchange(msg.sender, receiver, amountIn, amountOutMin, path, deadline, messageHash);\\n    }\\n\\n    function instantCCExchangeWithPermit(\\n        address signer,\\n        bytes memory signature,\\n        uint amountIn, \\n        uint amountOutMin, \\n        address[] memory path, \\n        address receiver, \\n        uint deadline\\n    ) public override returns(uint[] memory amounts, bool result) {\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(amountIn, amountOutMin, path[path.length-1], receiver, deadline)\\n        );\\n        require(isUsed[messageHash] == false, \\\"request has been executed before\\\");\\n        // require(requests[messageHash].isUsed == false, \\\"request has been executed before\\\");\\n        // verify the correctness of signature\\n        require(\\n            verifySignature(signer, signature, messageHash),\\n            \\\"signature is not valid\\\"\\n        );\\n        return _instantExchange(signer, receiver, amountIn, amountOutMin, path, deadline, messageHash);\\n    }\\n\\n    function payBackInstantTransfer (uint bitcoinAmount, address user) public override returns (bool) {\\n\\n        uint unlockedCollateralAmount;\\n        uint _bitcoinAmount = bitcoinAmount;\\n        uint lastSubmittedHeight = IBitcoinRelay(bitcoinRelay).lastSubmittedHeight();\\n        for (uint i = 0; i < debts[user].length; i++) {\\n            if (_bitcoinAmount >= debts[user][i].wrappedBitcoinAmount && debts[user][i].deadline >= lastSubmittedHeight) {\\n                IERC20(wrappedBitcoin).transferFrom(msg.sender, bitcoinInstantPool, debts[user][i].wrappedBitcoinAmount);\\n                unlockedCollateralAmount = unlockedCollateralAmount + debts[user][i].collateralAmount;\\n                _bitcoinAmount = _bitcoinAmount - debts[user][i].wrappedBitcoinAmount;\\n                // delete debt after user pay it\\n                delete debts[user][i];\\n            } else if (debts[user][i].deadline <= lastSubmittedHeight) {\\n                IERC20(wrappedBitcoin).transferFrom(ccTransferRouter, bitcoinInstantPool, _bitcoinAmount);\\n                debts[user][i].wrappedBitcoinAmount = debts[user][i].wrappedBitcoinAmount - _bitcoinAmount;\\n                _bitcoinAmount = 0;\\n                break;\\n            }\\n        }\\n        \\n        if (_bitcoinAmount > 0) {\\n            IERC20(wrappedBitcoin).transferFrom(msg.sender, user, _bitcoinAmount);\\n        }\\n\\n        // stake the unlocked collateral\\n        if (unlockedCollateralAmount > 0) {\\n            IERC20(TeleportDAOToken).approve(staking, unlockedCollateralAmount);\\n            IStaking(staking).stake(user, unlockedCollateralAmount);\\n        }\\n\\n        emit PaybackInstantLoan(user, bitcoinAmount);\\n        return true;\\n\\n    }\\n\\n    function requiredTDT (uint wrappedBitcoinAmount) private returns(uint){\\n        (uint wrappedBitcoinReserve, uint TeleportDAOTokenReserve) = TeleportDAOLibrary.getReserves(\\n            liquidityPoolFactory, \\n            wrappedBitcoin, \\n            TeleportDAOToken);\\n        uint _requiredTDT = TeleportDAOLibrary.getAmountIn(wrappedBitcoinAmount, TeleportDAOTokenReserve, wrappedBitcoinReserve);\\n        return _requiredTDT;\\n    }\\n\\n    function punishUser (address user, uint[] memory debtIndex) override external returns (bool) {\\n        \\n        require(debts[user].length >= debtIndex.length, \\\"too many indexes\\\");\\n        uint wrappedBitcoinAmount;\\n        uint collateralAmount;\\n        uint lastSubmittedHeight = IBitcoinRelay(bitcoinRelay).lastSubmittedHeight();\\n        \\n        for (uint i = 0; i < debtIndex.length; i++) {\\n            require(debts[user][debtIndex[i]].deadline < lastSubmittedHeight, \\\"deadline has not passed\\\");\\n            wrappedBitcoinAmount = wrappedBitcoinAmount + debts[user][debtIndex[i]].wrappedBitcoinAmount;\\n            collateralAmount = collateralAmount + debts[user][debtIndex[i]].collateralAmount;\\n            delete debts[user][debtIndex[i]];\\n            // TODO: delete operation leaves gaps. remove gaps\\n        }\\n        uint _requiredTDT = requiredTDT(wrappedBitcoinAmount); // needed TDT amount to buy wrappedBitcoin\\n        // address[] memory path;\\n        address[] memory path = new address[](2);\\n        path[0] = TeleportDAOToken;\\n        path[1] = wrappedBitcoin;\\n        buyWrappedBitcoinUsingTDT(\\n            _requiredTDT, \\n            wrappedBitcoinAmount,\\n            path,\\n            bitcoinInstantPool, \\n            2*block.timestamp\\n        );\\n       \\n        // send rest of TDT to TeleportDAOTreasury and punisher \\n        uint remainedTDT = collateralAmount - _requiredTDT;\\n        IERC20(TeleportDAOToken).transfer(msg.sender, punisherReward*remainedTDT/100); // send reward to punisher \\n        emit PunishUser(user, wrappedBitcoinAmount);\\n        return true;\\n    }\\n\\n    function buyWrappedBitcoinUsingTDT (\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint deadline\\n    ) internal {\\n        IERC20(TeleportDAOToken).approve(exchangeRouter, amountIn);\\n        IExchangeRouter(exchangeRouter).swapExactTokensForTokens(\\n            amountIn,\\n            amountOutMin,\\n            path,\\n            to,\\n            deadline\\n        );\\n    }\\n    // TODO: replace the buyWrappedBitcoinUsingTDT with the below function\\n    function _buyWrappedBitcoinUsingTDT(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] memory path,\\n        address to,\\n        uint deadline\\n    ) internal {\\n        IERC20(TeleportDAOToken).approve(exchangeRouter, amountInMax);\\n        IExchangeRouter(exchangeRouter).swapTokensForExactTokens(\\n            amountOut,\\n            amountInMax,\\n            path,\\n            to,\\n            deadline\\n        ); \\n    }\\n\\n    function verifySignature(\\n        address signer,\\n        bytes memory signature,\\n        bytes32 messageHash\\n    ) internal pure returns (bool) {\\n        bytes32 ethSignedMessageHash = keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", messageHash)\\n        );\\n        return recoverSigner(ethSignedMessageHash, signature) == signer;\\n    }\\n\\n    function recoverSigner(\\n        bytes32 ethSignedMessageHash, \\n        bytes memory signature\\n    ) internal pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\\n\\n        return ecrecover(ethSignedMessageHash, v, r, s);\\n    }\\n\\n    function splitSignature(bytes memory signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\\n        require(signature.length == 65, \\\"invalid signature length\\\");\\n        assembly {\\n            r := mload(add(signature, 32))\\n            s := mload(add(signature, 64))\\n            v := byte(0, mload(add(signature, 96)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x13f63c689bdeb131032545bd9a384c703dbf64774e85a9f1fec3d8f48ace6e44\"},\"contracts/routers/interfaces/ICCExchangeRouter.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\ninterface ICCExchangeRouter {\\n    // structures\\n    struct request{\\n        uint bitcoinAmount; //total amount of tokenA (exchange + fee)\\n        uint exchangeAmount;\\n        uint remainedInputAmount;\\n        address exchangeToken; // exchangeToken pool address on DEX\\n        bool isFixedToken;\\n        address bitcoinRecipient;\\n        address exchangeRecipientAddress;\\n        address[] path;\\n        uint teleporterFee;\\n        address teleporterAddress;\\n        uint deadline;\\n        bool isExchange;\\n        uint speed;\\n    }\\n\\n    // events\\n    event CCExchange(address user, address inputToken, address outputToken, uint inputAmount, uint outputAmount, uint speed);\\n\\n    // read-only functions\\n    function owner() external view returns (address);\\n    function liquidityPoolFactory() external view returns(address);\\n    function WAVAX() external view returns(address);\\n    function exchangeRouter() external view returns(address);\\n    function wrappedBitcoin() external view returns(address);\\n\\n    // state-changing functions\\n    function changeOwner(address _owner) external;\\n    function setInstantRouter (address _instantRouter) external;\\n    function setBitcoinTeleporter (address _bitcoinTeleporter) external;\\n    function setCCTransferRouter (address _ccTransferRouter) external;\\n    function setExchangeRouter (address _exchangeRouter) external;\\n    function setWrappedBitcoin (address _wrappedBitcoin) external;\\n    function ccExchange(\\n        bytes4 version,\\n        bytes memory vin,\\n        bytes calldata vout,\\n        bytes4 locktime,\\n        uint256 blockNumber,\\n        bytes calldata intermediateNodes,\\n        uint index,\\n        bool payWithTDT\\n    ) external;\\n    function instantCCExchangeWithPermit(\\n        address signer,\\n        bytes memory signature,\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] memory path,\\n        address receiver,\\n        uint deadline\\n    ) external;\\n}\\n\",\"keccak256\":\"0x66738730b7404359fef12a5ec02667eb633ec0f9a3b6a60dfd00d4cbcadaa30a\"},\"contracts/routers/interfaces/ICCTransferRouter.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity ^0.7.6;\\n\\ninterface ICCTransferRouter {\\n\\n  struct wrapRequest {\\n    uint bitcoinAmount;\\n    address recipientAddress;\\n    bool isExchange;\\n    uint teleporterFee; // TODO: should I change it to uint8?\\n    uint256 speed;\\n    bool isUsed;\\n    uint deadline;\\n    uint blockNumber; // only store for fast transfers\\n    bytes intermediateNodes; // only store for fast transfers\\n    uint index; // only store for fast transfers\\n    bool isMinted; // initially is false for fast tranfer\\n    uint exchangeAmount;\\n    address exchangeToken;\\n  }\\n\\n  // events\\n  event CCTransfer(address user, address inputToken, uint inputAmount, uint speed);\\n  event PaybackFastLoan(address user, uint amount);\\n\\n  // read-only functions\\n  function owner() external view returns (address);\\n  function isRequestUsed(bytes32 txId) external view returns(bool);\\n  function isRequestMinted(bytes32 txId) external view returns(bool);\\n  function wrappedBitcoin() external view returns(address);\\n  function bitcoinFastPool() external view returns(address);\\n  function normalConfirmationParameter() external view returns(uint);\\n\\n  // state-changing functions\\n  function changeOwner (address _owner) external;\\n  function setNormalConfirmationParameter (uint _normalConfirmationParameter) external;\\n  function setBitcoinRelay (address _bitcoinRelay) external;\\n  function setFastRouter (address _fastRouter) external;\\n  function setWrappedBitcoin (address _wrappedBitcoin) external returns (bool);\\n  function setInstantRouter (address _instantRouter) external;\\n  function setCCExchangeRouter (address _ccExchangeRouter) external;\\n\\n  function ccTransfer(\\n    bytes4 version,\\n    bytes memory vin,\\n    bytes calldata vout,\\n    bytes4 locktime,\\n    uint256 blockNumber,\\n    bytes calldata intermediateNodes,\\n    uint index,\\n    bool payWithTDT\\n  ) external returns(bool);\\n  function mintAfterFinalization(bytes32 txId) external returns(bool);\\n  function instantCCTransferWithPermit(\\n    address signer,\\n    bytes memory signature,\\n    address receiver,\\n    uint instantTokenAmount,\\n    uint deadline\\n  ) external returns(bool);\\n}\",\"keccak256\":\"0x5d66660880a3baefbd1c6518ef26d375e175ceba302b16617e464b1f11f1bc82\"},\"contracts/routers/interfaces/IExchangeRouter.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity 0.7.6;\\n\\ninterface IExchangeRouter {\\n    // read-only functions\\n    function liquidityPoolFactory() external view returns (address);\\n    // function bitcoinInstantPool() external view returns (address);\\n    // function wrappedBitcoin() external view returns (address);\\n    function WAVAX() external view returns (address);\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external returns (uint[] memory amounts);\\n\\n    // state-changing functions\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityAVAX(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountAVAXMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityAVAX(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountAVAXMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountAVAX);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts, bool result);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactAVAXForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n    function swapTokensForExactAVAX(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to, uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactTokensForAVAX(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to, uint deadline\\n    ) external returns (uint[] memory amounts, bool result);\\n    function swapAVAXForExactTokens(\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\",\"keccak256\":\"0x498fbfb3d4028594c685b3b7c6b6b293bf25ff877399fe54626ae224d3552aa4\"},\"contracts/routers/interfaces/IFastRouter.sol\":{\"content\":\"// SPDX-License-Identifier: <SPDX-License>\\npragma solidity >=0.7.6;\\n\\ninterface IFastRouter {\\n    // read-only functions\\n    function owner() external view returns (address);\\n    function bitcoinFastPool() external view returns(address);\\n    function ccTransferRouter() external view returns(address);\\n    function getNeededConfirmations() external view returns(uint);\\n\\n    // state-changing functions\\n    function changeOwner(address _owner) external;\\n    function setCCTransferRouter(address _ccTransferRouter) external;\\n    function fastTransfer(\\n        address receiver,\\n        uint amount,\\n        uint blockNumber\\n    ) external returns(bool);\\n    function addLiquidity(address user, uint wrappedBitcoinAmount) external returns(uint);\\n    function removeLiquidity(address user, uint fastPoolTokenAmount) external returns(uint);\\n\\n}\\n\",\"keccak256\":\"0x79056516e0f8b5d24b855ed8cbb81c4c43360b95e13a233bf2c97a7cfbe93d8c\"},\"contracts/routers/interfaces/IInstantRouter.sol\":{\"content\":\"pragma solidity >=0.7.6;\\n\\ninterface IInstantRouter {\\n    // structures\\n    struct InstantTransferRequest {\\n        address user;\\n        uint collateralAmount;\\n        uint wrappedBitcoinAmount;\\n        uint creationTime;\\n        uint deadline;\\n        uint paybackDeadline;\\n        bool isPaidback;\\n        bool isUsed;\\n    }\\n    struct debt {\\n        address user;\\n        uint wrappedBitcoinAmount;\\n        uint collateralAmount;\\n        uint deadline;\\n    }\\n\\n    // events\\n    event PaybackInstantLoan(address user, uint bitcoinAmount);\\n    event PunishUser(address user, uint slashedAmount);\\n\\n    // read-only functions\\n    function owner() external view returns(address);\\n    function bitcoinInstantPool() external view returns(address);\\n    function wrappedBitcoin() external view returns(address);\\n    function ccTransferRouter() external view returns(address);\\n    function requestCollateralAmount(bytes32 messageHash) external view returns(uint);\\n    function paybackDeadline() external returns(uint);\\n    function collateralRatio() external returns(uint);\\n\\n    // state-changing functions\\n    function changeOwner(address _owner) external;\\n    function setExchangeRouter(address _ExchangeRouter) external;\\n    function setPaybackDeadline(uint _paybackDeadline) external;\\n    function setCollateralRatio(uint _paybackDeadline) external;\\n    function setCCTransferRouter (address _ccTransferRouter) external;\\n    function setPunisherReward (uint _punisherReward) external;\\n    function addLiquidity(address user, uint instantPoolTokenAmount) external returns(uint);\\n    function removeLiquidity(address user, uint instantPoolTokenAmount) external returns(uint);\\n    function instantCCTransfer (address receiver, uint amount, uint deadline) external returns (bool);\\n    function instantCCTransferWithPermit(\\n        address signer,\\n        bytes memory signature,\\n        address receiver,\\n        uint amount,\\n        uint nonce\\n    ) external returns(bool);\\n    function instantCCExchange (\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] memory path,\\n        address receiver,\\n        uint deadline\\n    ) external returns(uint[] memory amounts, bool result);\\n    function instantCCExchangeWithPermit(\\n        address signer,\\n        bytes memory signature,\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] memory path,\\n        address receiver,\\n        uint deadline\\n    ) external returns(uint[] memory amounts, bool result);\\n    function payBackInstantTransfer (uint bitcoinAmount, address user) external returns (bool);\\n    function punishUser (address user, uint[] memory debtIndex) external returns (bool);\\n\\n}\",\"keccak256\":\"0xeaabb34c7330bab37bdda379df374ff23fc0636d3aeba9aad5f5754b7242583d\"},\"contracts/staking/interfaces/IStaking.sol\":{\"content\":\"pragma solidity ^0.7.6;\\n\\ninterface IStaking {\\n  // events\\n  event Stake(address user, uint TDTAmount);\\n  event Unstake(address user, uint TDTAmount);\\n\\n  // read-only functions\\n  function owner() external view returns (address);\\n  function TeleportDAOToken() external view returns (address);\\n  function instantRouter() external view returns (address);\\n  function totalStakingShare() external view returns(uint);\\n  function stakedAmount (address user) external returns(uint);\\n  function stakingShare (address user) external returns(uint);\\n  function earnedTDT (address user) external view returns (uint);\\n  \\n  // state-changing fucntions\\n  function changeOwner (address _owner) external;\\n  function setInstantRouter (address _instantRouter) external;\\n  function stake (address user, uint amount) external;\\n  function unstake (address user, uint _stakingShare) external;\\n  function claimReward (address user) external returns (bool);\\n  function equivalentStakingShare (uint TDTAmount) external returns (uint);\\n  function equivalentTDT (uint stakingShare) external returns (uint);\\n}\",\"keccak256\":\"0x35601c5143e0b1f5d359e0aaad2f471e7c0f8516d92b44374403af8560d9c446\"},\"contracts/teleporter/interfaces/IBitcoinTeleporter.sol\":{\"content\":\"pragma solidity 0.7.6;\\n\\ninterface IBitcoinTeleporter {\\n    // structures\\n    struct teleporter {\\n        bytes teleporterBitcoinPubKey;\\n        address teleporterAddress;\\n    }\\n\\n    // events\\n    event AddTeleporter(bytes teleporterBitcoinPubKey, address teleporterAddress, uint lockedAmount, uint addedtime);\\n    event RemoveTeleporter(bytes teleporterBitcoinPubKey, address teleporterAddress, uint unlockedAmount);\\n\\n    // read-only functions\\n    function owner() external view returns (address);\\n    function TeleportDAOToken() external view returns(address);\\n    function wrappedBitcoin() external view returns(address);\\n    function ccBurnRouter() external view returns(address);\\n    function exchangeRouter() external view returns(address);\\n    function requiredLockedAmount() external view returns(uint);\\n    function numberOfTeleporters() external view returns(uint);\\n    function redeemScript() external view returns(bytes memory);\\n    function redeemScriptHash() external view returns(address);\\n    function multisigAddress() external view returns(address);\\n    function multisigAddressBeforeEncoding() external view returns(bytes memory);\\n    function isTeleporter (address teleporter, uint index) external view returns(bool);\\n\\n    // state-changing functions\\n    function changeOwner(address _owner) external;\\n    function setUnlockFee(uint _unlockFee) external;\\n    function setUnlockPeriod(uint _unlockPeriod) external;\\n    function setRequiredLockedAmount(uint _submissionGasUsed) external;\\n    function setExchangeRouter(address _ccTransferRouter) external;\\n    function setCCBurnRouter(address _ccBurnRouter) external;\\n    function setWrappedBitcoin(address _wrappedBitcoin) external;\\n    function addTeleporter(bytes memory teleporterAddress) external returns(bool);\\n    function removeTeleporter(uint teleporterIndex) external returns(bool);\\n    function slashTeleporters (uint amount, address recipient) external;\\n}\",\"keccak256\":\"0x90c0048bb9d29f13abf09ade612feb17e66e102cf23f4c7e5dbd45aa41401a1b\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50604051613cb8380380613cb88339818101604052606081101561003357600080fd5b5080516020820151604090920151600080546001600160a01b039384166001600160a01b0319918216178255600180549490951693811693909317909355600955600a805490911633179055613c2990819061008f90396000f3fe608060405234801561001057600080fd5b506004361061014d5760003560e01c80638c99247b116100c3578063c6f461821161007c578063c6f4618214610623578063cc1c29901461062b578063d1d8d2ed14610645578063e35a0a881461064d578063e7740b2714610655578063e97fe07d146106725761014d565b80638c99247b146104e25780638da5cb5b146105aa578063a6f9dae1146105b2578063a7edfd92146105d8578063aafcad75146105f5578063ae13be3b146105fd5761014d565b806339c3d40c1161011557806339c3d40c146102e15780635615e16f146104545780636006bb441461045c5780637a7db8c71461048257806380bc47261461049f578063870ba6cf146104bc5761014d565b806302b0b472146101525780630981a666146101765780630c03c205146101b05780630e232b45146101d857806325dcd36a146102d9575b600080fd5b61015a61067a565b604080516001600160a01b039092168252519081900360200190f35b61019c6004803603602081101561018c57600080fd5b50356001600160a01b0316610689565b604080519115158252519081900360200190f35b6101d6600480360360208110156101c657600080fd5b50356001600160a01b03166106c7565b005b6101f5600480360360208110156101ee57600080fd5b5035610788565b604051808e81526020018d6001600160a01b031681526020018c151581526020018b81526020018a81526020018915158152602001888152602001878152602001806020018681526020018515158152602001848152602001836001600160a01b03168152602001828103825287818151815260200191508051906020019080838360005b8381101561029257818101518382015260200161027a565b50505050905090810190601f1680156102bf5780820380516001836020036101000a031916815260200191505b509e50505050505050505050505050505060405180910390f35b61015a610893565b61019c60048036036101008110156102f857600080fd5b6001600160e01b03198235169190810190604081016020820135600160201b81111561032357600080fd5b82018360208201111561033557600080fd5b803590602001918460018302840111600160201b8311171561035657600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295949360208101935035915050600160201b8111156103a857600080fd5b8201836020820111156103ba57600080fd5b803590602001918460018302840111600160201b831117156103db57600080fd5b919390926001600160e01b0319833516926020810135929190606081019060400135600160201b81111561040e57600080fd5b82018360208201111561042057600080fd5b803590602001918460018302840111600160201b8311171561044157600080fd5b91935091508035906020013515156108a2565b61015a610e1e565b6101d66004803603602081101561047257600080fd5b50356001600160a01b0316610e2d565b6101d66004803603602081101561049857600080fd5b5035610e66565b61019c600480360360208110156104b557600080fd5b5035610e82565b6101d6600480360360208110156104d257600080fd5b50356001600160a01b0316610eb1565b61019c600480360360a08110156104f857600080fd5b6001600160a01b038235169190810190604081016020820135600160201b81111561052257600080fd5b82018360208201111561053457600080fd5b803590602001918460018302840111600160201b8311171561055557600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550506001600160a01b038335169350505060208101359060400135610f6e565b61015a6110eb565b6101d6600480360360208110156105c857600080fd5b50356001600160a01b03166110fa565b61019c600480360360208110156105ee57600080fd5b5035611133565b61015a61115a565b6101d66004803603602081101561061357600080fd5b50356001600160a01b0316611169565b61015a6111a2565b6106336111b1565b60408051918252519081900360200190f35b61015a6111b7565b61015a6111c6565b61019c6004803603602081101561066b57600080fd5b50356111d5565b61015a6115aa565b6008546001600160a01b031681565b600a546000906001600160a01b031633146106a357600080fd5b50600680546001600160a01b0319166001600160a01b03831617905560015b919050565b600a546001600160a01b031633146106de57600080fd5b600580546001600160a01b0319166001600160a01b0383811691909117918290556040805163637a30c160e11b81529051929091169163c6f4618291600480820192602092909190829003018186803b15801561073a57600080fd5b505afa15801561074e573d6000803e3d6000fd5b505050506040513d602081101561076457600080fd5b5051600780546001600160a01b0319166001600160a01b0390921691909117905550565b60026020818152600092835260409283902080546001808301548386015460038501546004860154600587015460068801546007890180548d51610100998216159990990260001901169b909b04601f81018b90048b0288018b01909c528b8752969a6001600160a01b0386169a600160a01b90960460ff9081169a95999498931696919592949192918301828280156108635780601f1061083857610100808354040283529160200191610863565b820191906000526020600020905b81548152906001019060200180831161084657829003601f168201915b5050505060088301546009840154600a850154600b909501549394919360ff90911692506001600160a01b03168d565b6005546001600160a01b031681565b6000806108b28c8c8c8c8c6115b9565b90506108bd81611792565b60008181526002602052604090206004015490915060ff1615610927576040805162461bcd60e51b815260206004820152601c60248201527f5265717565737420686173206265656e2075736564206265666f726500000000604482015290519081900360640190fd5b6109a08a8a8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050604080516020601f8c018190048102820181019092528a81528c935091508a908a90819084018382808284376000920191909152508a92508791506118489050565b600081815260026020526040902060030154610b10576109fd818888888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250506009548a9250899150611acb565b610a4e576040805162461bcd60e51b815260206004820152601d60248201527f5472616e73616374696f6e20686173206e6f742066696e616c697a6564000000604482015290519081900360640190fd5b610a5781611bea565b610a925760405162461bcd60e51b8152600401808060200182810382526025815260200180613a5c6025913960400191505060405180910390fd5b6000818152600260209081526040918290206001810154600654825460039093015485516001600160a01b039384168152919092169381019390935282840191909152606082015290517f4dd447d32b0eb26431cafc536583d8145b95b1eb93077de974f521fcea816e1c9181900360800190a16001915050610e10565b60008181526002602052604090206003015460011415610d1757610b71818888888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250506009548a9250899150611acb565b151560011415610c4157610b8481611bea565b610bbf5760405162461bcd60e51b8152600401808060200182810382526023815260200180613acb6023913960400191505060405180910390fd5b600081815260026020908152604080832060098101805460ff19166001908117909155810154600654915483516001600160a01b039283168152919092169381019390935282820152606082019290925290517f4dd447d32b0eb26431cafc536583d8145b95b1eb93077de974f521fcea816e1c9181900360800190a1610d0d565b610c8e818888888080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508a9250899150610c899050611f4c565b611acb565b610cc95760405162461bcd60e51b8152600401808060200182810382526031815260200180613a056031913960400191505060405180910390fd5b610cd281611fc2565b610a925760405162461bcd60e51b8152600401808060200182810382526023815260200180613acb6023913960400191505060405180910390fd5b6001915050610e10565b6000818152600260208190526040909120600301541415610e0e57610d79818888888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250506009548a9250899150611acb565b610dca576040805162461bcd60e51b815260206004820152601d60248201527f5472616e73616374696f6e20686173206e6f742066696e616c697a6564000000604482015290519081900360640190fd5b610dd3816121c1565b610d0d5760405162461bcd60e51b8152600401808060200182810382526026815260200180613a366026913960400191505060405180910390fd5b505b9a9950505050505050505050565b6006546001600160a01b031681565b600a546001600160a01b03163314610e4457600080fd5b600080546001600160a01b0319166001600160a01b0392909216919091179055565b600a546001600160a01b03163314610e7d57600080fd5b600955565b60008181526002602052604081206004015460ff16151560011415610ea9575060016106c2565b5060006106c2565b600a546001600160a01b03163314610ec857600080fd5b600480546001600160a01b0319166001600160a01b0383811691909117808355604080516301585a3960e11b8152905191909216926302b0b47292808201926020929091829003018186803b158015610f2057600080fd5b505afa158015610f34573d6000803e3d6000fd5b505050506040513d6020811015610f4a57600080fd5b5051600880546001600160a01b0319166001600160a01b0390921691909117905550565b6000600460009054906101000a90046001600160a01b03166001600160a01b0316638c99247b87878787876040518663ffffffff1660e01b815260040180866001600160a01b0316815260200180602001856001600160a01b03168152602001848152602001838152602001828103825286818151815260200191508051906020019080838360005b8381101561100f578181015183820152602001610ff7565b50505050905090810190601f16801561103c5780820380516001836020036101000a031916815260200191505b509650505050505050602060405180830381600087803b15801561105f57600080fd5b505af1158015611073573d6000803e3d6000fd5b505050506040513d602081101561108957600080fd5b5050600654604080516001600160a01b038088168252909216602083015281810185905260026060830152517f4dd447d32b0eb26431cafc536583d8145b95b1eb93077de974f521fcea816e1c9181900360800190a150600195945050505050565b600a546001600160a01b031681565b600a546001600160a01b0316331461111157600080fd5b600a80546001600160a01b0319166001600160a01b0392909216919091179055565b60008181526002602052604081206009015460ff16151560011415610ea9575060016106c2565b6000546001600160a01b031681565b600a546001600160a01b0316331461118057600080fd5b600380546001600160a01b0319166001600160a01b0392909216919091179055565b6007546001600160a01b031681565b60095481565b6001546001600160a01b031681565b6004546001600160a01b031681565b60006111df6138bd565b60008381526002602081815260409283902083516101a081018552815481526001808301546001600160a01b03811683860152600160a01b900460ff90811615158388015283860154606084015260038401546080840152600484015416151560a0830152600583015460c0830152600683015460e083015260078301805487516101009382161584026000190190911696909604601f810186900486028701860190975286865291959294908601939092908301828280156112e35780601f106112b8576101008083540402835291602001916112e3565b820191906000526020600020905b8154815290600101906020018083116112c657829003601f168201915b505050918352505060088201546020820152600982015460ff1615156040820152600a8201546060820152600b909101546001600160a01b031660809091015260a0810151909150151560011461136b5760405162461bcd60e51b8152600401808060200182810382526029815260200180613aa26029913960400191505060405180910390fd5b610140810151156113ad5760405162461bcd60e51b8152600401808060200182810382526022815260200180613b286022913960400191505060405180910390fd5b6113cc838260e001518361010001518461012001516001600954611acb565b6114075760405162461bcd60e51b8152600401808060200182810382526022815260200180613b4a6022913960400191505060405180910390fd5b600083815260026020818152604080842060098101805460ff1916600117905560065460075482860154925484516340c10f1960e01b81526001600160a01b03928316600482015296909304909203602486015291519116936340c10f19936044808201949392918390030190829087803b15801561148557600080fd5b505af1158015611499573d6000803e3d6000fd5b505050506040513d60208110156114af57600080fd5b5050600654600084815260026020818152604080842083015481516340c10f1960e01b81523360048201529390046024840152516001600160a01b03909416936340c10f19936044808501948390030190829087803b15801561151157600080fd5b505af1158015611525573d6000803e3d6000fd5b505050506040513d602081101561153b57600080fd5b5050600083815260026020818152604092839020600181015481840154915485516001600160a01b039092168252939091049092039082015281517f04b4e6dca8cce7a9ba30efb65be30df4386de23abacb58603039fbd821ab9038929181900390910190a150600192915050565b6003546001600160a01b031681565b6000806002878787878760405160200180866001600160e01b031916815260040185805190602001908083835b602083106116055780518252601f1990920191602091820191016115e6565b6001836020036101000a03801982511681845116808217855250505050505090500184848082843780830192505050826001600160e01b0319168152600401955050505050506040516020818303038152906040526040518082805190602001908083835b602083106116895780518252601f19909201916020918201910161166a565b51815160209384036101000a60001901801990921691161790526040519190930194509192505080830381855afa1580156116c8573d6000803e3d6000fd5b5050506040513d60208110156116dd57600080fd5b5051604080516020818101849052825180830382018152918301928390528151939450600093600293918291908401908083835b602083106117305780518252601f199092019160209182019101611711565b51815160209384036101000a60001901801990921691161790526040519190930194509192505080830381855afa15801561176f573d6000803e3d6000fd5b5050506040513d602081101561178457600080fd5b505198975050505050505050565b6000606081805b602081101561183c57828582601f03602081106117b257fe5b1a60f81b6040516020018083805190602001908083835b602083106117e85780518252601f1990920191602091820191016117c9565b6001836020036101000a038019825116818451168082178552505050505050905001826001600160f81b03191681526001019250505060405160208183030381529060405292508080600101915050611799565b50506020015192915050565b60606118526138bd565b600154604080516375a31bb160e01b815290516000926001600160a01b0316916375a31bb1916004808301926020929190829003018186803b15801561189757600080fd5b505afa1580156118ab573d6000803e3d6000fd5b505050506040513d60208110156118c157600080fd5b505190506118cf88826124eb565b6001600160401b03909116835292506118e7836125d1565b6001600160a01b031660208301526118fe836125ec565b6001600160401b0316606083015261191583612607565b1515604083015261192583612654565b60ff1660808301526119368361266e565b6001600160401b031660c08301526080820151600114156119695760e08201879052610100820186905261012082018590525b8160800151600214156119b05761197f8361267e565b6001600160a01b03166101808301526119978361268e565b6fffffffffffffffffffffffffffffffff166101608301525b600160a0830181815260008681526002602081815260409283902087518155818801519581018054948901516001600160a01b03199095166001600160a01b039097169690961760ff60a01b1916600160a01b941515949094029390931790945560608601519082015560808501516003820155905160048201805460ff191691151591909117905560c0840151600582015560e0840151600682015561010084015180518593611a6892600785019291019061393d565b50610120820151600882015561014082015160098201805460ff1916911515919091179055610160820151600a82015561018090910151600b90910180546001600160a01b0319166001600160a01b039092169190911790555050505050505050565b60008060009054906101000a90046001600160a01b03166001600160a01b03166373b63c828888888888886040518763ffffffff1660e01b815260040180878152602001868152602001806020018581526020018415158152602001838152602001828103825286818151815260200191508051906020019080838360005b83811015611b62578181015183820152602001611b4a565b50505050905090810190601f168015611b8f5780820380516001836020036101000a031916815260200191505b50975050505050505050602060405180830381600087803b158015611bb357600080fd5b505af1158015611bc7573d6000803e3d6000fd5b505050506040513d6020811015611bdd57600080fd5b5051979650505050505050565b6000818152600260205260408120600190810154600160a01b900460ff1615151415611ec7576003546001600160a01b0316331415611cc05760065460035460008481526002602090815260408083205481516340c10f1960e01b81526001600160a01b0395861660048201526024810191909152905193909416936340c10f199360448083019491928390030190829087803b158015611c8a57600080fd5b505af1158015611c9e573d6000803e3d6000fd5b505050506040513d6020811015611cb457600080fd5b50600191506106c29050565b6003546001600160a01b03163314611ec7576000828152600260205260409020600501544311611d37576040805162461bcd60e51b815260206004820152601b60248201527f646561646c696e6520686173206e6f7420706173736564207965740000000000604482015290519081900360640190fd5b600082815260026020819052604090912080549101541115611d9d576040805162461bcd60e51b815260206004820152601a6024820152790e8cad8cae0dee4e8cae440cccaca40d2e640e8dede40daeac6d60331b604482015290519081900360640190fd5b6000828152600260208190526040909120015415611e445760065460008381526002602081815260408084209092015482516340c10f1960e01b8152336004820152602481019190915291516001600160a01b03909416936340c10f19936044808501948390030190829087803b158015611e1757600080fd5b505af1158015611e2b573d6000803e3d6000fd5b505050506040513d6020811015611e4157600080fd5b50505b600654600083815260026020819052604090912060018101549181015490546001600160a01b03938416936340c10f19931691611e8191906126a9565b6040518363ffffffff1660e01b815260040180836001600160a01b0316815260200182815260200192505050602060405180830381600087803b158015611c8a57600080fd5b600082815260026020526040902060010154600160a01b900460ff166106c2576000828152600260208190526040909120805491015410611d9d576040805162461bcd60e51b815260206004820152601a6024820152790e8cad8cae0dee4e8cae440cccaca40d2e640e8dede40daeac6d60331b604482015290519081900360640190fd5b6005546040805163794cc65960e11b815290516000926001600160a01b03169163f2998cb2916004808301926020929190829003018186803b158015611f9157600080fd5b505afa158015611fa5573d6000803e3d6000fd5b505050506040513d6020811015611fbb57600080fd5b5051905090565b6000818152600260205260408120600190810154600160a01b900460ff161515141561209b576003546001600160a01b03163314156120815760035460008381526002602052604090208054600690910154612028926001600160a01b031691906126ff565b612079576040805162461bcd60e51b815260206004820152601860248201527f66617374207472616e7366657220776173206661696c65640000000000000000604482015290519081900360640190fd5b5060016106c2565b6003546001600160a01b0316331461209b575060016106c2565b600082815260026020526040902060010154600160a01b900460ff166106c2576000828152600260208190526040909120015415612136576000828152600260208190526040909120808201546006909101546120fb92339204906126ff565b6121365760405162461bcd60e51b81526004018080602001828103825260268152602001806139df6026913960400191505060405180910390fd5b60008281526002602081905260409091206001810154918101548154600690920154612170936001600160a01b03169291909103906126ff565b612079576040805162461bcd60e51b815260206004820181905260248201527f66617374207472616e7366657220746f207573657220776173206661696c6564604482015290519081900360640190fd5b60008181526002602081905260408220805491015410612225576040805162461bcd60e51b815260206004820152601a6024820152790e8cad8cae0dee4e8cae440cccaca40d2e640e8dede40daeac6d60331b604482015290519081900360640190fd5b60008281526002602081905260409091200154156122cc5760065460008381526002602081815260408084209092015482516340c10f1960e01b8152336004820152602481019190915291516001600160a01b03909416936340c10f19936044808501948390030190829087803b15801561229f57600080fd5b505af11580156122b3573d6000803e3d6000fd5b505050506040513d60208110156122c957600080fd5b50505b60065460008381526002602081905260409091209081015490546001600160a01b03909216916340c10f19913091612303916126a9565b6040518363ffffffff1660e01b815260040180836001600160a01b0316815260200182815260200192505050602060405180830381600087803b15801561234957600080fd5b505af115801561235d573d6000803e3d6000fd5b505050506040513d602081101561237357600080fd5b505060065460045460008481526002602081905260409091209081015490546001600160a01b039384169363095ea7b39316916123b091906126a9565b6040518363ffffffff1660e01b815260040180836001600160a01b0316815260200182815260200192505050602060405180830381600087803b1580156123f657600080fd5b505af115801561240a573d6000803e3d6000fd5b505050506040513d602081101561242057600080fd5b50506004546000838152600260208190526040822090810154905491926001600160a01b031691634324a0009161245791906126a9565b60008681526002602090815260408083206001015481516001600160e01b031960e088901b16815260048101959095526001600160a01b0316602485015251604480850194929391928390030190829087803b1580156124b657600080fd5b505af11580156124ca573d6000803e3d6000fd5b505050506040513d60208110156124e057600080fd5b506001949350505050565b60006060816125086124fd8683612795565b62ffffff19166127b9565b90506000806000806000606060006125218860006128e7565b6001600160401b0316905060005b818110156125bf576125418982612a00565b975061254c88612b07565b955061255786612b5d565b945062ffffff1980861614156125a55761257862ffffff1987166003612c2e565b93508b6001600160a01b0316846001600160a01b031614156125a05761259d88612c3c565b96505b6125b7565b6125b462ffffff198616612c50565b92505b60010161252f565b50949b909a5098505050505050505050565b6000806125e18360006013612c8f565b601401519392505050565b6000806125fc836014601b612c8f565b600801519392505050565b60008061261683601c80612c8f565b805190915060009081908390829061262a57fe5b01602001516001600160f81b0319161415612648576000925061264d565b600192505b5050919050565b60008061266383601d80612c8f565b600101519392505050565b6000806125fc8360426049612c8f565b6000806125e183601e6031612c8f565b60008061269e8360326041612c8f565b601001519392505050565b808203828111156126f9576040805162461bcd60e51b815260206004820152601560248201527464732d6d6174682d7375622d756e646572666c6f7760581b604482015290519081900360640190fd5b92915050565b60055460408051632049504760e01b81526001600160a01b03868116600483015260248201869052604482018590529151600093929092169163204950479160648082019260209290919082900301818787803b15801561275f57600080fd5b505af1158015612773573d6000803e3d6000fd5b505050506040513d602081101561278957600080fd5b505190505b9392505050565b8151600090602084016127b064ffffffffff85168284612d4a565b95945050505050565b600081816127cf815b62ffffff19841690612d84565b506127df62ffffff198516612ec2565b6001600160601b03166127fb576127f4612ed1565b925061264d565b60006128088560006128e7565b9050600061281b62ffffff198716612ec2565b6001600160601b031690506001600160401b0382166128455761283c612ed1565b9450505061264d565b600061285083612ed9565b60ff16905060005b836001600160401b03168110156128b15782821061288357612878612ed1565b96505050505061264d565b600061289962ffffff198a16848603600e612f32565b90506128a481612f63565b9092019150600101612858565b508181146128cb576128c1612ed1565b955050505061264d565b6128dc62ffffff198816600f612fa5565b979650505050505050565b6000806128fc62ffffff198516846001612fb7565b905060fc811161290d5790506126f9565b8060fd14156129635761292b62ffffff198516600185016002612fd8565b915061293682612ed9565b60ff1660031461295e5761295c61295762ffffff1986168560036000612fed565b613052565b505b6129f9565b8060fe14156129ad5761298162ffffff198516600185016004612fd8565b915061298c82612ed9565b60ff1660051461295e5761295c61295762ffffff1986168560056000612fed565b8060ff14156129f9576129cb62ffffff198516600185016008612fd8565b91506129d682612ed9565b60ff166009146129f9576129f761295762ffffff1986168560096000612fed565b505b5092915050565b600080612a0e8460006128e7565b6001600160401b031690506000612a2a62ffffff198616612ec2565b6001600160601b03169050818410612a7d576040805162461bcd60e51b81526020600482015260116024820152702b37baba103932b0b21037bb32b9393ab760791b604482015290519081900360640190fd5b6000612a8883612ed9565b60ff1690506000805b86811015612ac457612aad62ffffff198916848603600e612f32565b9150612ab882612f63565b90920191600101612a91565b50612ad962ffffff198816838503600e612f32565b90506000612ae682612f63565b9050612afb62ffffff1989168483600d612fed565b98975050505050505050565b600081600d612b15816127c2565b506000612b238560086128e7565b90506127b0600882612b3484612ed9565b60ff16016001600160401b031660076014811115612b4e57fe5b62ffffff198916929190612fed565b6000816007612b6b816127c2565b506000612b798560006128e7565b90506000612b9062ffffff19871660026001612fb7565b9050604d826001600160401b03161180612bb357506004826001600160401b0316105b80612bd05750612bcb62ffffff198716600180612fb7565b606a14155b80612bfa57506001600160401b03600119830116612bf762ffffff19881660026001612fb7565b14155b15612c075761283c612ed1565b612c2462ffffff19871660036001600160401b038416600c612fed565b9695505050505050565b600061278e83836014612fb7565b60006126f962ffffff198316826008612fd8565b6060600080612c5e84612ec2565b6001600160601b031690506040519150819250612c7e8483602001613120565b508181016020016040529052919050565b60606000835b83600101811015612d4157858181518110612cac57fe5b602001015160f81c60f81b915082826040516020018083805190602001908083835b60208310612ced5780518252601f199092019160209182019101612cce565b6001836020036101000a038019825116818451168082178552505050505050905001826001600160f81b03191681526001019250505060405160208183030381529060405292508080600101915050612c95565b50509392505050565b600080612d57848461320e565b9050604051811115612d67575060005b80612d795762ffffff1991505061278e565b6127b085858561325d565b6000612d908383613270565b612ebb576000612dae612da285613292565b64ffffffffff16613298565b9150506000612dc38464ffffffffff16613298565b604080517f5479706520617373657274696f6e206661696c65642e20476f742030780000006020808301919091526001600160b01b031960b088811b8216603d8501526c05c408af0e0cac6e8cac84060f609b1b604785015285901b1660548301528251603e818403018152605e83019384905262461bcd60e51b909352606282018181528351608284015283519496509294508493839260a2019185019080838360005b83811015612e80578181015183820152602001612e68565b50505050905090810190601f168015612ead5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5090919050565b60181c6001600160601b031690565b62ffffff1990565b600060fc826001600160401b031611612ef4575060016106c2565b61ffff826001600160401b031611612f0e575060036106c2565b63ffffffff826001600160401b031611612f2a575060056106c2565b5060096106c2565b6000612f5b84612f5485612f4588612ec2565b6001600160601b0316906126a9565b8585612fed565b949350505050565b600081600e612f71816127c2565b506000612f7f8560086128e7565b9050806001600160401b0316612f9482612ed9565b60ff16016008019350505050919050565b60d81b6001600160d81b039091161790565b60008160200360080260ff16612fce858585613330565b901c949350505050565b6000612f5b612fe8858585613330565b613456565b600080612ff986613590565b6001600160601b0316905061300d8661359f565b6130218561301b848961320e565b9061320e565b11156130345762ffffff19915050612f5b565b61303e818661320e565b9050612c248364ffffffffff168286612d4a565b6060600061307f61307a8261306c62ffffff198716612ec2565b62ffffff1987169190612fb7565b613298565b604080517f4e6f6e2d6d696e696d616c2076617220696e742e20476f742030780000000000602080830191909152607084901b6dffffffffffffffffffffffffffff1916603b8301528251808303602d018152604d83019384905262461bcd60e51b90935260518201818152835160718401528351949650929450849383926091019185019080838360008315612e80578181015183820152602001612e68565b600061312b836135c4565b6131665760405162461bcd60e51b8152600401808060200182810382526028815260200180613b6c6028913960400191505060405180910390fd5b61316f836135d6565b6131aa5760405162461bcd60e51b815260040180806020018281038252602b815260200180613b94602b913960400191505060405180910390fd5b60006131b584612ec2565b6001600160601b0316905060006131cb85613590565b6001600160601b0316905060006040519050848111156131eb5760206060fd5b8285848460045afa50612c2461320087613292565b64ffffffffff16868561325d565b808201828110156126f9576040805162461bcd60e51b815260206004820152601460248201527364732d6d6174682d6164642d6f766572666c6f7760601b604482015290519081900360640190fd5b606092831b9190911790911b1760181b90565b60008164ffffffffff1661328384613292565b64ffffffffff16149392505050565b60d81c90565b600080601f5b600f8160ff1611156132e25760ff600882021684901c6132bd81613613565b61ffff16841793508160ff166010146132d857601084901b93505b506000190161329e565b50600f5b60ff8160ff16101561332a5760ff600882021684901c61330581613613565b61ffff16831792508160ff1660001461332057601083901b92505b50600019016132e6565b50915091565b600060ff82166133425750600061278e565b61334b84612ec2565b6001600160601b03166133618460ff851661320e565b11156133df5761339861337385613590565b6001600160601b031661338586612ec2565b6001600160601b0316858560ff16613643565b60405162461bcd60e51b8152602060048201818152835160248401528351909283926044909101919085019080838360008315612e80578181015183820152602001612e68565b60208260ff1611156134225760405162461bcd60e51b815260040180806020018281038252603a815260200180613aee603a913960400191505060405180910390fd5b60088202600061343186613590565b6001600160601b03169050600061344783613736565b91909501511695945050505050565b600881811c7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff167fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff009290911b9190911617601081811c7dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff167fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff00009290911b9190911617602081811c7bffffffff00000000ffffffff00000000ffffffff00000000ffffffff167fffffffff00000000ffffffff00000000ffffffff00000000ffffffff000000009290911b9190911617604081811c77ffffffffffffffff0000000000000000ffffffffffffffff1677ffffffffffffffff0000000000000000ffffffffffffffff199290911b9190911617608081811c91901b1790565b60781c6001600160601b031690565b60006135aa82612ec2565b6135b383613590565b016001600160601b03169050919050565b60006135cf82613745565b1592915050565b60006135e182613292565b64ffffffffff1664ffffffffff14156135fc575060006106c2565b60006136078361359f565b60405110199392505050565b600061362560048360ff16901c613751565b60ff161760081b62ffff001661363a82613751565b60ff1617919050565b6060600061365086613298565b915050600061365e86613298565b915050600061366c86613298565b915050600061367a86613298565b915050838383836040516020018080613bbf603591396001600160d01b031960d087811b821660358401526e040eed2e8d040d8cadccee8d04060f608b1b603b84015286901b16604a8201526050016021613a8182396001600160d01b031960d094851b811660218301526e040eed2e8d040d8cadccee8d04060f608b1b60278301529290931b909116603683015250601760f91b603c82015260408051601d818403018152603d90920190529b9a5050505050505050505050565b600160ff1b6000199091011d90565b62ffffff199081161490565b600060f08083179060ff8216141561376d5760309150506106c2565b8060ff1660f114156137835760319150506106c2565b8060ff1660f214156137995760329150506106c2565b8060ff1660f314156137af5760339150506106c2565b8060ff1660f414156137c55760349150506106c2565b8060ff1660f514156137db5760359150506106c2565b8060ff1660f614156137f15760369150506106c2565b8060ff1660f714156138075760379150506106c2565b8060ff1660f8141561381d5760389150506106c2565b8060ff1660f914156138335760399150506106c2565b8060ff1660fa14156138495760619150506106c2565b8060ff1660fb141561385f5760629150506106c2565b8060ff1660fc14156138755760639150506106c2565b8060ff1660fd141561388b5760649150506106c2565b8060ff1660fe14156138a15760659150506106c2565b8060ff1660ff14156138b75760669150506106c2565b50919050565b604051806101a001604052806000815260200160006001600160a01b031681526020016000151581526020016000815260200160008152602001600015158152602001600081526020016000815260200160608152602001600081526020016000151581526020016000815260200160006001600160a01b031681525090565b828054600181600116156101000203166002900490600052602060002090601f01602090048101928261397357600085556139b9565b82601f1061398c57805160ff19168380011785556139b9565b828001600101855582156139b9579182015b828111156139b957825182559160200191906001019061399e565b506139c59291506139c9565b5090565b5b808211156139c557600081556001016139ca56fe66617374207472616e7366657220746f2074656c65706f7274657220776173206661696c65645472616e73616374696f6e20686173206e6f7420726563656976656420656e6f75676820636f6e6669726d6174696f6e73696e7374616e74206363207472616e7366657220776173206e6f74207375636365737366756c6e6f726d616c206363207472616e7366657220776173206e6f74207375636365737366756c2e20417474656d7074656420746f20696e646578206174206f6666736574203078546865207265757165737420686173206e6f74206265656e207375626d6974746564206265666f726566617374206363207472616e7366657220776173206e6f74207375636365737366756c54797065644d656d566965772f696e646578202d20417474656d7074656420746f20696e646578206d6f7265207468616e203332206279746573546865207265757165737420686173206265656e206d696e746564206265666f72655472616e73616374696f6e20686173206e6f74206265656e2066696e616c697a656454797065644d656d566965772f636f7079546f202d204e756c6c20706f696e74657220646572656654797065644d656d566965772f636f7079546f202d20496e76616c696420706f696e74657220646572656654797065644d656d566965772f696e646578202d204f76657272616e2074686520766965772e20536c696365206973206174203078a2646970667358221220395a7663b0e38285610e35b9ff1b38c39bc9110d9a28956668cfeb085648c76264736f6c63430007060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061014d5760003560e01c80638c99247b116100c3578063c6f461821161007c578063c6f4618214610623578063cc1c29901461062b578063d1d8d2ed14610645578063e35a0a881461064d578063e7740b2714610655578063e97fe07d146106725761014d565b80638c99247b146104e25780638da5cb5b146105aa578063a6f9dae1146105b2578063a7edfd92146105d8578063aafcad75146105f5578063ae13be3b146105fd5761014d565b806339c3d40c1161011557806339c3d40c146102e15780635615e16f146104545780636006bb441461045c5780637a7db8c71461048257806380bc47261461049f578063870ba6cf146104bc5761014d565b806302b0b472146101525780630981a666146101765780630c03c205146101b05780630e232b45146101d857806325dcd36a146102d9575b600080fd5b61015a61067a565b604080516001600160a01b039092168252519081900360200190f35b61019c6004803603602081101561018c57600080fd5b50356001600160a01b0316610689565b604080519115158252519081900360200190f35b6101d6600480360360208110156101c657600080fd5b50356001600160a01b03166106c7565b005b6101f5600480360360208110156101ee57600080fd5b5035610788565b604051808e81526020018d6001600160a01b031681526020018c151581526020018b81526020018a81526020018915158152602001888152602001878152602001806020018681526020018515158152602001848152602001836001600160a01b03168152602001828103825287818151815260200191508051906020019080838360005b8381101561029257818101518382015260200161027a565b50505050905090810190601f1680156102bf5780820380516001836020036101000a031916815260200191505b509e50505050505050505050505050505060405180910390f35b61015a610893565b61019c60048036036101008110156102f857600080fd5b6001600160e01b03198235169190810190604081016020820135600160201b81111561032357600080fd5b82018360208201111561033557600080fd5b803590602001918460018302840111600160201b8311171561035657600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295949360208101935035915050600160201b8111156103a857600080fd5b8201836020820111156103ba57600080fd5b803590602001918460018302840111600160201b831117156103db57600080fd5b919390926001600160e01b0319833516926020810135929190606081019060400135600160201b81111561040e57600080fd5b82018360208201111561042057600080fd5b803590602001918460018302840111600160201b8311171561044157600080fd5b91935091508035906020013515156108a2565b61015a610e1e565b6101d66004803603602081101561047257600080fd5b50356001600160a01b0316610e2d565b6101d66004803603602081101561049857600080fd5b5035610e66565b61019c600480360360208110156104b557600080fd5b5035610e82565b6101d6600480360360208110156104d257600080fd5b50356001600160a01b0316610eb1565b61019c600480360360a08110156104f857600080fd5b6001600160a01b038235169190810190604081016020820135600160201b81111561052257600080fd5b82018360208201111561053457600080fd5b803590602001918460018302840111600160201b8311171561055557600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550506001600160a01b038335169350505060208101359060400135610f6e565b61015a6110eb565b6101d6600480360360208110156105c857600080fd5b50356001600160a01b03166110fa565b61019c600480360360208110156105ee57600080fd5b5035611133565b61015a61115a565b6101d66004803603602081101561061357600080fd5b50356001600160a01b0316611169565b61015a6111a2565b6106336111b1565b60408051918252519081900360200190f35b61015a6111b7565b61015a6111c6565b61019c6004803603602081101561066b57600080fd5b50356111d5565b61015a6115aa565b6008546001600160a01b031681565b600a546000906001600160a01b031633146106a357600080fd5b50600680546001600160a01b0319166001600160a01b03831617905560015b919050565b600a546001600160a01b031633146106de57600080fd5b600580546001600160a01b0319166001600160a01b0383811691909117918290556040805163637a30c160e11b81529051929091169163c6f4618291600480820192602092909190829003018186803b15801561073a57600080fd5b505afa15801561074e573d6000803e3d6000fd5b505050506040513d602081101561076457600080fd5b5051600780546001600160a01b0319166001600160a01b0390921691909117905550565b60026020818152600092835260409283902080546001808301548386015460038501546004860154600587015460068801546007890180548d51610100998216159990990260001901169b909b04601f81018b90048b0288018b01909c528b8752969a6001600160a01b0386169a600160a01b90960460ff9081169a95999498931696919592949192918301828280156108635780601f1061083857610100808354040283529160200191610863565b820191906000526020600020905b81548152906001019060200180831161084657829003601f168201915b5050505060088301546009840154600a850154600b909501549394919360ff90911692506001600160a01b03168d565b6005546001600160a01b031681565b6000806108b28c8c8c8c8c6115b9565b90506108bd81611792565b60008181526002602052604090206004015490915060ff1615610927576040805162461bcd60e51b815260206004820152601c60248201527f5265717565737420686173206265656e2075736564206265666f726500000000604482015290519081900360640190fd5b6109a08a8a8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050604080516020601f8c018190048102820181019092528a81528c935091508a908a90819084018382808284376000920191909152508a92508791506118489050565b600081815260026020526040902060030154610b10576109fd818888888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250506009548a9250899150611acb565b610a4e576040805162461bcd60e51b815260206004820152601d60248201527f5472616e73616374696f6e20686173206e6f742066696e616c697a6564000000604482015290519081900360640190fd5b610a5781611bea565b610a925760405162461bcd60e51b8152600401808060200182810382526025815260200180613a5c6025913960400191505060405180910390fd5b6000818152600260209081526040918290206001810154600654825460039093015485516001600160a01b039384168152919092169381019390935282840191909152606082015290517f4dd447d32b0eb26431cafc536583d8145b95b1eb93077de974f521fcea816e1c9181900360800190a16001915050610e10565b60008181526002602052604090206003015460011415610d1757610b71818888888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250506009548a9250899150611acb565b151560011415610c4157610b8481611bea565b610bbf5760405162461bcd60e51b8152600401808060200182810382526023815260200180613acb6023913960400191505060405180910390fd5b600081815260026020908152604080832060098101805460ff19166001908117909155810154600654915483516001600160a01b039283168152919092169381019390935282820152606082019290925290517f4dd447d32b0eb26431cafc536583d8145b95b1eb93077de974f521fcea816e1c9181900360800190a1610d0d565b610c8e818888888080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508a9250899150610c899050611f4c565b611acb565b610cc95760405162461bcd60e51b8152600401808060200182810382526031815260200180613a056031913960400191505060405180910390fd5b610cd281611fc2565b610a925760405162461bcd60e51b8152600401808060200182810382526023815260200180613acb6023913960400191505060405180910390fd5b6001915050610e10565b6000818152600260208190526040909120600301541415610e0e57610d79818888888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250506009548a9250899150611acb565b610dca576040805162461bcd60e51b815260206004820152601d60248201527f5472616e73616374696f6e20686173206e6f742066696e616c697a6564000000604482015290519081900360640190fd5b610dd3816121c1565b610d0d5760405162461bcd60e51b8152600401808060200182810382526026815260200180613a366026913960400191505060405180910390fd5b505b9a9950505050505050505050565b6006546001600160a01b031681565b600a546001600160a01b03163314610e4457600080fd5b600080546001600160a01b0319166001600160a01b0392909216919091179055565b600a546001600160a01b03163314610e7d57600080fd5b600955565b60008181526002602052604081206004015460ff16151560011415610ea9575060016106c2565b5060006106c2565b600a546001600160a01b03163314610ec857600080fd5b600480546001600160a01b0319166001600160a01b0383811691909117808355604080516301585a3960e11b8152905191909216926302b0b47292808201926020929091829003018186803b158015610f2057600080fd5b505afa158015610f34573d6000803e3d6000fd5b505050506040513d6020811015610f4a57600080fd5b5051600880546001600160a01b0319166001600160a01b0390921691909117905550565b6000600460009054906101000a90046001600160a01b03166001600160a01b0316638c99247b87878787876040518663ffffffff1660e01b815260040180866001600160a01b0316815260200180602001856001600160a01b03168152602001848152602001838152602001828103825286818151815260200191508051906020019080838360005b8381101561100f578181015183820152602001610ff7565b50505050905090810190601f16801561103c5780820380516001836020036101000a031916815260200191505b509650505050505050602060405180830381600087803b15801561105f57600080fd5b505af1158015611073573d6000803e3d6000fd5b505050506040513d602081101561108957600080fd5b5050600654604080516001600160a01b038088168252909216602083015281810185905260026060830152517f4dd447d32b0eb26431cafc536583d8145b95b1eb93077de974f521fcea816e1c9181900360800190a150600195945050505050565b600a546001600160a01b031681565b600a546001600160a01b0316331461111157600080fd5b600a80546001600160a01b0319166001600160a01b0392909216919091179055565b60008181526002602052604081206009015460ff16151560011415610ea9575060016106c2565b6000546001600160a01b031681565b600a546001600160a01b0316331461118057600080fd5b600380546001600160a01b0319166001600160a01b0392909216919091179055565b6007546001600160a01b031681565b60095481565b6001546001600160a01b031681565b6004546001600160a01b031681565b60006111df6138bd565b60008381526002602081815260409283902083516101a081018552815481526001808301546001600160a01b03811683860152600160a01b900460ff90811615158388015283860154606084015260038401546080840152600484015416151560a0830152600583015460c0830152600683015460e083015260078301805487516101009382161584026000190190911696909604601f810186900486028701860190975286865291959294908601939092908301828280156112e35780601f106112b8576101008083540402835291602001916112e3565b820191906000526020600020905b8154815290600101906020018083116112c657829003601f168201915b505050918352505060088201546020820152600982015460ff1615156040820152600a8201546060820152600b909101546001600160a01b031660809091015260a0810151909150151560011461136b5760405162461bcd60e51b8152600401808060200182810382526029815260200180613aa26029913960400191505060405180910390fd5b610140810151156113ad5760405162461bcd60e51b8152600401808060200182810382526022815260200180613b286022913960400191505060405180910390fd5b6113cc838260e001518361010001518461012001516001600954611acb565b6114075760405162461bcd60e51b8152600401808060200182810382526022815260200180613b4a6022913960400191505060405180910390fd5b600083815260026020818152604080842060098101805460ff1916600117905560065460075482860154925484516340c10f1960e01b81526001600160a01b03928316600482015296909304909203602486015291519116936340c10f19936044808201949392918390030190829087803b15801561148557600080fd5b505af1158015611499573d6000803e3d6000fd5b505050506040513d60208110156114af57600080fd5b5050600654600084815260026020818152604080842083015481516340c10f1960e01b81523360048201529390046024840152516001600160a01b03909416936340c10f19936044808501948390030190829087803b15801561151157600080fd5b505af1158015611525573d6000803e3d6000fd5b505050506040513d602081101561153b57600080fd5b5050600083815260026020818152604092839020600181015481840154915485516001600160a01b039092168252939091049092039082015281517f04b4e6dca8cce7a9ba30efb65be30df4386de23abacb58603039fbd821ab9038929181900390910190a150600192915050565b6003546001600160a01b031681565b6000806002878787878760405160200180866001600160e01b031916815260040185805190602001908083835b602083106116055780518252601f1990920191602091820191016115e6565b6001836020036101000a03801982511681845116808217855250505050505090500184848082843780830192505050826001600160e01b0319168152600401955050505050506040516020818303038152906040526040518082805190602001908083835b602083106116895780518252601f19909201916020918201910161166a565b51815160209384036101000a60001901801990921691161790526040519190930194509192505080830381855afa1580156116c8573d6000803e3d6000fd5b5050506040513d60208110156116dd57600080fd5b5051604080516020818101849052825180830382018152918301928390528151939450600093600293918291908401908083835b602083106117305780518252601f199092019160209182019101611711565b51815160209384036101000a60001901801990921691161790526040519190930194509192505080830381855afa15801561176f573d6000803e3d6000fd5b5050506040513d602081101561178457600080fd5b505198975050505050505050565b6000606081805b602081101561183c57828582601f03602081106117b257fe5b1a60f81b6040516020018083805190602001908083835b602083106117e85780518252601f1990920191602091820191016117c9565b6001836020036101000a038019825116818451168082178552505050505050905001826001600160f81b03191681526001019250505060405160208183030381529060405292508080600101915050611799565b50506020015192915050565b60606118526138bd565b600154604080516375a31bb160e01b815290516000926001600160a01b0316916375a31bb1916004808301926020929190829003018186803b15801561189757600080fd5b505afa1580156118ab573d6000803e3d6000fd5b505050506040513d60208110156118c157600080fd5b505190506118cf88826124eb565b6001600160401b03909116835292506118e7836125d1565b6001600160a01b031660208301526118fe836125ec565b6001600160401b0316606083015261191583612607565b1515604083015261192583612654565b60ff1660808301526119368361266e565b6001600160401b031660c08301526080820151600114156119695760e08201879052610100820186905261012082018590525b8160800151600214156119b05761197f8361267e565b6001600160a01b03166101808301526119978361268e565b6fffffffffffffffffffffffffffffffff166101608301525b600160a0830181815260008681526002602081815260409283902087518155818801519581018054948901516001600160a01b03199095166001600160a01b039097169690961760ff60a01b1916600160a01b941515949094029390931790945560608601519082015560808501516003820155905160048201805460ff191691151591909117905560c0840151600582015560e0840151600682015561010084015180518593611a6892600785019291019061393d565b50610120820151600882015561014082015160098201805460ff1916911515919091179055610160820151600a82015561018090910151600b90910180546001600160a01b0319166001600160a01b039092169190911790555050505050505050565b60008060009054906101000a90046001600160a01b03166001600160a01b03166373b63c828888888888886040518763ffffffff1660e01b815260040180878152602001868152602001806020018581526020018415158152602001838152602001828103825286818151815260200191508051906020019080838360005b83811015611b62578181015183820152602001611b4a565b50505050905090810190601f168015611b8f5780820380516001836020036101000a031916815260200191505b50975050505050505050602060405180830381600087803b158015611bb357600080fd5b505af1158015611bc7573d6000803e3d6000fd5b505050506040513d6020811015611bdd57600080fd5b5051979650505050505050565b6000818152600260205260408120600190810154600160a01b900460ff1615151415611ec7576003546001600160a01b0316331415611cc05760065460035460008481526002602090815260408083205481516340c10f1960e01b81526001600160a01b0395861660048201526024810191909152905193909416936340c10f199360448083019491928390030190829087803b158015611c8a57600080fd5b505af1158015611c9e573d6000803e3d6000fd5b505050506040513d6020811015611cb457600080fd5b50600191506106c29050565b6003546001600160a01b03163314611ec7576000828152600260205260409020600501544311611d37576040805162461bcd60e51b815260206004820152601b60248201527f646561646c696e6520686173206e6f7420706173736564207965740000000000604482015290519081900360640190fd5b600082815260026020819052604090912080549101541115611d9d576040805162461bcd60e51b815260206004820152601a6024820152790e8cad8cae0dee4e8cae440cccaca40d2e640e8dede40daeac6d60331b604482015290519081900360640190fd5b6000828152600260208190526040909120015415611e445760065460008381526002602081815260408084209092015482516340c10f1960e01b8152336004820152602481019190915291516001600160a01b03909416936340c10f19936044808501948390030190829087803b158015611e1757600080fd5b505af1158015611e2b573d6000803e3d6000fd5b505050506040513d6020811015611e4157600080fd5b50505b600654600083815260026020819052604090912060018101549181015490546001600160a01b03938416936340c10f19931691611e8191906126a9565b6040518363ffffffff1660e01b815260040180836001600160a01b0316815260200182815260200192505050602060405180830381600087803b158015611c8a57600080fd5b600082815260026020526040902060010154600160a01b900460ff166106c2576000828152600260208190526040909120805491015410611d9d576040805162461bcd60e51b815260206004820152601a6024820152790e8cad8cae0dee4e8cae440cccaca40d2e640e8dede40daeac6d60331b604482015290519081900360640190fd5b6005546040805163794cc65960e11b815290516000926001600160a01b03169163f2998cb2916004808301926020929190829003018186803b158015611f9157600080fd5b505afa158015611fa5573d6000803e3d6000fd5b505050506040513d6020811015611fbb57600080fd5b5051905090565b6000818152600260205260408120600190810154600160a01b900460ff161515141561209b576003546001600160a01b03163314156120815760035460008381526002602052604090208054600690910154612028926001600160a01b031691906126ff565b612079576040805162461bcd60e51b815260206004820152601860248201527f66617374207472616e7366657220776173206661696c65640000000000000000604482015290519081900360640190fd5b5060016106c2565b6003546001600160a01b0316331461209b575060016106c2565b600082815260026020526040902060010154600160a01b900460ff166106c2576000828152600260208190526040909120015415612136576000828152600260208190526040909120808201546006909101546120fb92339204906126ff565b6121365760405162461bcd60e51b81526004018080602001828103825260268152602001806139df6026913960400191505060405180910390fd5b60008281526002602081905260409091206001810154918101548154600690920154612170936001600160a01b03169291909103906126ff565b612079576040805162461bcd60e51b815260206004820181905260248201527f66617374207472616e7366657220746f207573657220776173206661696c6564604482015290519081900360640190fd5b60008181526002602081905260408220805491015410612225576040805162461bcd60e51b815260206004820152601a6024820152790e8cad8cae0dee4e8cae440cccaca40d2e640e8dede40daeac6d60331b604482015290519081900360640190fd5b60008281526002602081905260409091200154156122cc5760065460008381526002602081815260408084209092015482516340c10f1960e01b8152336004820152602481019190915291516001600160a01b03909416936340c10f19936044808501948390030190829087803b15801561229f57600080fd5b505af11580156122b3573d6000803e3d6000fd5b505050506040513d60208110156122c957600080fd5b50505b60065460008381526002602081905260409091209081015490546001600160a01b03909216916340c10f19913091612303916126a9565b6040518363ffffffff1660e01b815260040180836001600160a01b0316815260200182815260200192505050602060405180830381600087803b15801561234957600080fd5b505af115801561235d573d6000803e3d6000fd5b505050506040513d602081101561237357600080fd5b505060065460045460008481526002602081905260409091209081015490546001600160a01b039384169363095ea7b39316916123b091906126a9565b6040518363ffffffff1660e01b815260040180836001600160a01b0316815260200182815260200192505050602060405180830381600087803b1580156123f657600080fd5b505af115801561240a573d6000803e3d6000fd5b505050506040513d602081101561242057600080fd5b50506004546000838152600260208190526040822090810154905491926001600160a01b031691634324a0009161245791906126a9565b60008681526002602090815260408083206001015481516001600160e01b031960e088901b16815260048101959095526001600160a01b0316602485015251604480850194929391928390030190829087803b1580156124b657600080fd5b505af11580156124ca573d6000803e3d6000fd5b505050506040513d60208110156124e057600080fd5b506001949350505050565b60006060816125086124fd8683612795565b62ffffff19166127b9565b90506000806000806000606060006125218860006128e7565b6001600160401b0316905060005b818110156125bf576125418982612a00565b975061254c88612b07565b955061255786612b5d565b945062ffffff1980861614156125a55761257862ffffff1987166003612c2e565b93508b6001600160a01b0316846001600160a01b031614156125a05761259d88612c3c565b96505b6125b7565b6125b462ffffff198616612c50565b92505b60010161252f565b50949b909a5098505050505050505050565b6000806125e18360006013612c8f565b601401519392505050565b6000806125fc836014601b612c8f565b600801519392505050565b60008061261683601c80612c8f565b805190915060009081908390829061262a57fe5b01602001516001600160f81b0319161415612648576000925061264d565b600192505b5050919050565b60008061266383601d80612c8f565b600101519392505050565b6000806125fc8360426049612c8f565b6000806125e183601e6031612c8f565b60008061269e8360326041612c8f565b601001519392505050565b808203828111156126f9576040805162461bcd60e51b815260206004820152601560248201527464732d6d6174682d7375622d756e646572666c6f7760581b604482015290519081900360640190fd5b92915050565b60055460408051632049504760e01b81526001600160a01b03868116600483015260248201869052604482018590529151600093929092169163204950479160648082019260209290919082900301818787803b15801561275f57600080fd5b505af1158015612773573d6000803e3d6000fd5b505050506040513d602081101561278957600080fd5b505190505b9392505050565b8151600090602084016127b064ffffffffff85168284612d4a565b95945050505050565b600081816127cf815b62ffffff19841690612d84565b506127df62ffffff198516612ec2565b6001600160601b03166127fb576127f4612ed1565b925061264d565b60006128088560006128e7565b9050600061281b62ffffff198716612ec2565b6001600160601b031690506001600160401b0382166128455761283c612ed1565b9450505061264d565b600061285083612ed9565b60ff16905060005b836001600160401b03168110156128b15782821061288357612878612ed1565b96505050505061264d565b600061289962ffffff198a16848603600e612f32565b90506128a481612f63565b9092019150600101612858565b508181146128cb576128c1612ed1565b955050505061264d565b6128dc62ffffff198816600f612fa5565b979650505050505050565b6000806128fc62ffffff198516846001612fb7565b905060fc811161290d5790506126f9565b8060fd14156129635761292b62ffffff198516600185016002612fd8565b915061293682612ed9565b60ff1660031461295e5761295c61295762ffffff1986168560036000612fed565b613052565b505b6129f9565b8060fe14156129ad5761298162ffffff198516600185016004612fd8565b915061298c82612ed9565b60ff1660051461295e5761295c61295762ffffff1986168560056000612fed565b8060ff14156129f9576129cb62ffffff198516600185016008612fd8565b91506129d682612ed9565b60ff166009146129f9576129f761295762ffffff1986168560096000612fed565b505b5092915050565b600080612a0e8460006128e7565b6001600160401b031690506000612a2a62ffffff198616612ec2565b6001600160601b03169050818410612a7d576040805162461bcd60e51b81526020600482015260116024820152702b37baba103932b0b21037bb32b9393ab760791b604482015290519081900360640190fd5b6000612a8883612ed9565b60ff1690506000805b86811015612ac457612aad62ffffff198916848603600e612f32565b9150612ab882612f63565b90920191600101612a91565b50612ad962ffffff198816838503600e612f32565b90506000612ae682612f63565b9050612afb62ffffff1989168483600d612fed565b98975050505050505050565b600081600d612b15816127c2565b506000612b238560086128e7565b90506127b0600882612b3484612ed9565b60ff16016001600160401b031660076014811115612b4e57fe5b62ffffff198916929190612fed565b6000816007612b6b816127c2565b506000612b798560006128e7565b90506000612b9062ffffff19871660026001612fb7565b9050604d826001600160401b03161180612bb357506004826001600160401b0316105b80612bd05750612bcb62ffffff198716600180612fb7565b606a14155b80612bfa57506001600160401b03600119830116612bf762ffffff19881660026001612fb7565b14155b15612c075761283c612ed1565b612c2462ffffff19871660036001600160401b038416600c612fed565b9695505050505050565b600061278e83836014612fb7565b60006126f962ffffff198316826008612fd8565b6060600080612c5e84612ec2565b6001600160601b031690506040519150819250612c7e8483602001613120565b508181016020016040529052919050565b60606000835b83600101811015612d4157858181518110612cac57fe5b602001015160f81c60f81b915082826040516020018083805190602001908083835b60208310612ced5780518252601f199092019160209182019101612cce565b6001836020036101000a038019825116818451168082178552505050505050905001826001600160f81b03191681526001019250505060405160208183030381529060405292508080600101915050612c95565b50509392505050565b600080612d57848461320e565b9050604051811115612d67575060005b80612d795762ffffff1991505061278e565b6127b085858561325d565b6000612d908383613270565b612ebb576000612dae612da285613292565b64ffffffffff16613298565b9150506000612dc38464ffffffffff16613298565b604080517f5479706520617373657274696f6e206661696c65642e20476f742030780000006020808301919091526001600160b01b031960b088811b8216603d8501526c05c408af0e0cac6e8cac84060f609b1b604785015285901b1660548301528251603e818403018152605e83019384905262461bcd60e51b909352606282018181528351608284015283519496509294508493839260a2019185019080838360005b83811015612e80578181015183820152602001612e68565b50505050905090810190601f168015612ead5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5090919050565b60181c6001600160601b031690565b62ffffff1990565b600060fc826001600160401b031611612ef4575060016106c2565b61ffff826001600160401b031611612f0e575060036106c2565b63ffffffff826001600160401b031611612f2a575060056106c2565b5060096106c2565b6000612f5b84612f5485612f4588612ec2565b6001600160601b0316906126a9565b8585612fed565b949350505050565b600081600e612f71816127c2565b506000612f7f8560086128e7565b9050806001600160401b0316612f9482612ed9565b60ff16016008019350505050919050565b60d81b6001600160d81b039091161790565b60008160200360080260ff16612fce858585613330565b901c949350505050565b6000612f5b612fe8858585613330565b613456565b600080612ff986613590565b6001600160601b0316905061300d8661359f565b6130218561301b848961320e565b9061320e565b11156130345762ffffff19915050612f5b565b61303e818661320e565b9050612c248364ffffffffff168286612d4a565b6060600061307f61307a8261306c62ffffff198716612ec2565b62ffffff1987169190612fb7565b613298565b604080517f4e6f6e2d6d696e696d616c2076617220696e742e20476f742030780000000000602080830191909152607084901b6dffffffffffffffffffffffffffff1916603b8301528251808303602d018152604d83019384905262461bcd60e51b90935260518201818152835160718401528351949650929450849383926091019185019080838360008315612e80578181015183820152602001612e68565b600061312b836135c4565b6131665760405162461bcd60e51b8152600401808060200182810382526028815260200180613b6c6028913960400191505060405180910390fd5b61316f836135d6565b6131aa5760405162461bcd60e51b815260040180806020018281038252602b815260200180613b94602b913960400191505060405180910390fd5b60006131b584612ec2565b6001600160601b0316905060006131cb85613590565b6001600160601b0316905060006040519050848111156131eb5760206060fd5b8285848460045afa50612c2461320087613292565b64ffffffffff16868561325d565b808201828110156126f9576040805162461bcd60e51b815260206004820152601460248201527364732d6d6174682d6164642d6f766572666c6f7760601b604482015290519081900360640190fd5b606092831b9190911790911b1760181b90565b60008164ffffffffff1661328384613292565b64ffffffffff16149392505050565b60d81c90565b600080601f5b600f8160ff1611156132e25760ff600882021684901c6132bd81613613565b61ffff16841793508160ff166010146132d857601084901b93505b506000190161329e565b50600f5b60ff8160ff16101561332a5760ff600882021684901c61330581613613565b61ffff16831792508160ff1660001461332057601083901b92505b50600019016132e6565b50915091565b600060ff82166133425750600061278e565b61334b84612ec2565b6001600160601b03166133618460ff851661320e565b11156133df5761339861337385613590565b6001600160601b031661338586612ec2565b6001600160601b0316858560ff16613643565b60405162461bcd60e51b8152602060048201818152835160248401528351909283926044909101919085019080838360008315612e80578181015183820152602001612e68565b60208260ff1611156134225760405162461bcd60e51b815260040180806020018281038252603a815260200180613aee603a913960400191505060405180910390fd5b60088202600061343186613590565b6001600160601b03169050600061344783613736565b91909501511695945050505050565b600881811c7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff167fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff009290911b9190911617601081811c7dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff167fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff00009290911b9190911617602081811c7bffffffff00000000ffffffff00000000ffffffff00000000ffffffff167fffffffff00000000ffffffff00000000ffffffff00000000ffffffff000000009290911b9190911617604081811c77ffffffffffffffff0000000000000000ffffffffffffffff1677ffffffffffffffff0000000000000000ffffffffffffffff199290911b9190911617608081811c91901b1790565b60781c6001600160601b031690565b60006135aa82612ec2565b6135b383613590565b016001600160601b03169050919050565b60006135cf82613745565b1592915050565b60006135e182613292565b64ffffffffff1664ffffffffff14156135fc575060006106c2565b60006136078361359f565b60405110199392505050565b600061362560048360ff16901c613751565b60ff161760081b62ffff001661363a82613751565b60ff1617919050565b6060600061365086613298565b915050600061365e86613298565b915050600061366c86613298565b915050600061367a86613298565b915050838383836040516020018080613bbf603591396001600160d01b031960d087811b821660358401526e040eed2e8d040d8cadccee8d04060f608b1b603b84015286901b16604a8201526050016021613a8182396001600160d01b031960d094851b811660218301526e040eed2e8d040d8cadccee8d04060f608b1b60278301529290931b909116603683015250601760f91b603c82015260408051601d818403018152603d90920190529b9a5050505050505050505050565b600160ff1b6000199091011d90565b62ffffff199081161490565b600060f08083179060ff8216141561376d5760309150506106c2565b8060ff1660f114156137835760319150506106c2565b8060ff1660f214156137995760329150506106c2565b8060ff1660f314156137af5760339150506106c2565b8060ff1660f414156137c55760349150506106c2565b8060ff1660f514156137db5760359150506106c2565b8060ff1660f614156137f15760369150506106c2565b8060ff1660f714156138075760379150506106c2565b8060ff1660f8141561381d5760389150506106c2565b8060ff1660f914156138335760399150506106c2565b8060ff1660fa14156138495760619150506106c2565b8060ff1660fb141561385f5760629150506106c2565b8060ff1660fc14156138755760639150506106c2565b8060ff1660fd141561388b5760649150506106c2565b8060ff1660fe14156138a15760659150506106c2565b8060ff1660ff14156138b75760669150506106c2565b50919050565b604051806101a001604052806000815260200160006001600160a01b031681526020016000151581526020016000815260200160008152602001600015158152602001600081526020016000815260200160608152602001600081526020016000151581526020016000815260200160006001600160a01b031681525090565b828054600181600116156101000203166002900490600052602060002090601f01602090048101928261397357600085556139b9565b82601f1061398c57805160ff19168380011785556139b9565b828001600101855582156139b9579182015b828111156139b957825182559160200191906001019061399e565b506139c59291506139c9565b5090565b5b808211156139c557600081556001016139ca56fe66617374207472616e7366657220746f2074656c65706f7274657220776173206661696c65645472616e73616374696f6e20686173206e6f7420726563656976656420656e6f75676820636f6e6669726d6174696f6e73696e7374616e74206363207472616e7366657220776173206e6f74207375636365737366756c6e6f726d616c206363207472616e7366657220776173206e6f74207375636365737366756c2e20417474656d7074656420746f20696e646578206174206f6666736574203078546865207265757165737420686173206e6f74206265656e207375626d6974746564206265666f726566617374206363207472616e7366657220776173206e6f74207375636365737366756c54797065644d656d566965772f696e646578202d20417474656d7074656420746f20696e646578206d6f7265207468616e203332206279746573546865207265757165737420686173206265656e206d696e746564206265666f72655472616e73616374696f6e20686173206e6f74206265656e2066696e616c697a656454797065644d656d566965772f636f7079546f202d204e756c6c20706f696e74657220646572656654797065644d656d566965772f636f7079546f202d20496e76616c696420706f696e74657220646572656654797065644d656d566965772f696e646578202d204f76657272616e2074686520766965772e20536c696365206973206174203078a2646970667358221220395a7663b0e38285610e35b9ff1b38c39bc9110d9a28956668cfeb085648c76264736f6c63430007060033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 12902,
        "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
        "label": "bitcoinRelay",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 12904,
        "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
        "label": "bitcoinTeleporter",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 12908,
        "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
        "label": "wrapRequests",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_bytes32,t_struct(wrapRequest)17919_storage)"
      },
      {
        "astId": 12910,
        "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
        "label": "ccExchangeRouter",
        "offset": 0,
        "slot": "3",
        "type": "t_address"
      },
      {
        "astId": 12912,
        "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
        "label": "instantRouter",
        "offset": 0,
        "slot": "4",
        "type": "t_address"
      },
      {
        "astId": 12914,
        "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
        "label": "fastRouter",
        "offset": 0,
        "slot": "5",
        "type": "t_address"
      },
      {
        "astId": 12917,
        "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
        "label": "wrappedBitcoin",
        "offset": 0,
        "slot": "6",
        "type": "t_address"
      },
      {
        "astId": 12920,
        "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
        "label": "bitcoinFastPool",
        "offset": 0,
        "slot": "7",
        "type": "t_address"
      },
      {
        "astId": 12922,
        "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
        "label": "bitcoinInstantPool",
        "offset": 0,
        "slot": "8",
        "type": "t_address"
      },
      {
        "astId": 12925,
        "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
        "label": "normalConfirmationParameter",
        "offset": 0,
        "slot": "9",
        "type": "t_uint256"
      },
      {
        "astId": 12928,
        "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
        "label": "owner",
        "offset": 0,
        "slot": "10",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_bytes_storage": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_mapping(t_bytes32,t_struct(wrapRequest)17919_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct ICCTransferRouter.wrapRequest)",
        "numberOfBytes": "32",
        "value": "t_struct(wrapRequest)17919_storage"
      },
      "t_struct(wrapRequest)17919_storage": {
        "encoding": "inplace",
        "label": "struct ICCTransferRouter.wrapRequest",
        "members": [
          {
            "astId": 17894,
            "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
            "label": "bitcoinAmount",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 17896,
            "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
            "label": "recipientAddress",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 17898,
            "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
            "label": "isExchange",
            "offset": 20,
            "slot": "1",
            "type": "t_bool"
          },
          {
            "astId": 17900,
            "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
            "label": "teleporterFee",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 17902,
            "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
            "label": "speed",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 17904,
            "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
            "label": "isUsed",
            "offset": 0,
            "slot": "4",
            "type": "t_bool"
          },
          {
            "astId": 17906,
            "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
            "label": "deadline",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 17908,
            "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
            "label": "blockNumber",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 17910,
            "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
            "label": "intermediateNodes",
            "offset": 0,
            "slot": "7",
            "type": "t_bytes_storage"
          },
          {
            "astId": 17912,
            "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
            "label": "index",
            "offset": 0,
            "slot": "8",
            "type": "t_uint256"
          },
          {
            "astId": 17914,
            "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
            "label": "isMinted",
            "offset": 0,
            "slot": "9",
            "type": "t_bool"
          },
          {
            "astId": 17916,
            "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
            "label": "exchangeAmount",
            "offset": 0,
            "slot": "10",
            "type": "t_uint256"
          },
          {
            "astId": 17918,
            "contract": "contracts/routers/CCTransferRouter.sol:CCTransferRouter",
            "label": "exchangeToken",
            "offset": 0,
            "slot": "11",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "384"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}